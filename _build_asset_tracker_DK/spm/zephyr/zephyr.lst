
zephyr.elf:     file format elf32-littlearm


Disassembly of section text:

0000c200 <_vector_table>:
    c200:	20000a90 	.word	0x20000a90
    c204:	0000d4d5 	.word	0x0000d4d5
    c208:	0000fdf1 	.word	0x0000fdf1
    c20c:	0000d415 	.word	0x0000d415
    c210:	0000d415 	.word	0x0000d415
    c214:	0000d415 	.word	0x0000d415
    c218:	0000d415 	.word	0x0000d415
    c21c:	0000d415 	.word	0x0000d415
    c220:	0000d415 	.word	0x0000d415
    c224:	0000d415 	.word	0x0000d415
    c228:	0000d415 	.word	0x0000d415
    c22c:	0000d2f1 	.word	0x0000d2f1
    c230:	0000d415 	.word	0x0000d415
    c234:	0000d415 	.word	0x0000d415
    c238:	0000d29d 	.word	0x0000d29d
    c23c:	0000fcef 	.word	0x0000fcef

0000c240 <_irq_vector_table>:
    c240:	0000d495 0000d495 0000d495 0000d495     ................
    c250:	0000d495 0000d495 0000d495 0000d495     ................
    c260:	0000d495 0000d495 0000d495 0000d495     ................
    c270:	0000d495 0000d495 0000d495 0000d495     ................
    c280:	0000d495 0000d495 0000d495 0000d495     ................
    c290:	0000d495 0000d495 0000d495 0000d495     ................
    c2a0:	0000d495 0000d495 0000d495 0000d495     ................
    c2b0:	0000d495 0000d495 0000d495 0000d495     ................
    c2c0:	0000d495 0000d495 0000d495 0000d495     ................
    c2d0:	0000d495 0000d495 0000d495 0000d495     ................
    c2e0:	0000d495 0000d495 0000d495 0000d495     ................
    c2f0:	0000d495 0000d495 0000d495 0000d495     ................
    c300:	0000d495 0000d495 0000d495 0000d495     ................
    c310:	0000d495 0000d495 0000d495 0000d495     ................
    c320:	0000d495 0000d495 0000d495 0000d495     ................
    c330:	0000d495 0000d495 0000d495 0000d495     ................
    c340:	0000d495                                ....

0000c344 <_vector_end>:
	...

0000c400 <m_firmware_info>:
    c400:	281ee6de 8fcebb4c 00005b01 0000be00     ...(L....[......
    c410:	00000001 0000c200 200013d0 0000dc3d     ........... =...

Disassembly of section _TEXT_SECTION_NAME_2:

0000c420 <__aeabi_ldivmod>:
    c420:	b97b      	cbnz	r3, c442 <__aeabi_ldivmod+0x22>
    c422:	b972      	cbnz	r2, c442 <__aeabi_ldivmod+0x22>
    c424:	2900      	cmp	r1, #0
    c426:	bfbe      	ittt	lt
    c428:	2000      	movlt	r0, #0
    c42a:	f04f 4100 	movlt.w	r1, #2147483648	; 0x80000000
    c42e:	e006      	blt.n	c43e <__aeabi_ldivmod+0x1e>
    c430:	bf08      	it	eq
    c432:	2800      	cmpeq	r0, #0
    c434:	bf1c      	itt	ne
    c436:	f06f 4100 	mvnne.w	r1, #2147483648	; 0x80000000
    c43a:	f04f 30ff 	movne.w	r0, #4294967295	; 0xffffffff
    c43e:	f000 b9a3 	b.w	c788 <__aeabi_idiv0>
    c442:	f1ad 0c08 	sub.w	ip, sp, #8
    c446:	e96d ce04 	strd	ip, lr, [sp, #-16]!
    c44a:	2900      	cmp	r1, #0
    c44c:	db09      	blt.n	c462 <__aeabi_ldivmod+0x42>
    c44e:	2b00      	cmp	r3, #0
    c450:	db1a      	blt.n	c488 <__aeabi_ldivmod+0x68>
    c452:	f000 f835 	bl	c4c0 <__udivmoddi4>
    c456:	f8dd e004 	ldr.w	lr, [sp, #4]
    c45a:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
    c45e:	b004      	add	sp, #16
    c460:	4770      	bx	lr
    c462:	4240      	negs	r0, r0
    c464:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
    c468:	2b00      	cmp	r3, #0
    c46a:	db1b      	blt.n	c4a4 <__aeabi_ldivmod+0x84>
    c46c:	f000 f828 	bl	c4c0 <__udivmoddi4>
    c470:	f8dd e004 	ldr.w	lr, [sp, #4]
    c474:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
    c478:	b004      	add	sp, #16
    c47a:	4240      	negs	r0, r0
    c47c:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
    c480:	4252      	negs	r2, r2
    c482:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
    c486:	4770      	bx	lr
    c488:	4252      	negs	r2, r2
    c48a:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
    c48e:	f000 f817 	bl	c4c0 <__udivmoddi4>
    c492:	f8dd e004 	ldr.w	lr, [sp, #4]
    c496:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
    c49a:	b004      	add	sp, #16
    c49c:	4240      	negs	r0, r0
    c49e:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
    c4a2:	4770      	bx	lr
    c4a4:	4252      	negs	r2, r2
    c4a6:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
    c4aa:	f000 f809 	bl	c4c0 <__udivmoddi4>
    c4ae:	f8dd e004 	ldr.w	lr, [sp, #4]
    c4b2:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
    c4b6:	b004      	add	sp, #16
    c4b8:	4252      	negs	r2, r2
    c4ba:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
    c4be:	4770      	bx	lr

0000c4c0 <__udivmoddi4>:
    c4c0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    c4c4:	9e09      	ldr	r6, [sp, #36]	; 0x24
    c4c6:	4604      	mov	r4, r0
    c4c8:	4689      	mov	r9, r1
    c4ca:	2b00      	cmp	r3, #0
    c4cc:	f040 8083 	bne.w	c5d6 <__udivmoddi4+0x116>
    c4d0:	428a      	cmp	r2, r1
    c4d2:	4615      	mov	r5, r2
    c4d4:	d945      	bls.n	c562 <__udivmoddi4+0xa2>
    c4d6:	fab2 f282 	clz	r2, r2
    c4da:	b14a      	cbz	r2, c4f0 <__udivmoddi4+0x30>
    c4dc:	f1c2 0720 	rsb	r7, r2, #32
    c4e0:	fa01 f302 	lsl.w	r3, r1, r2
    c4e4:	4095      	lsls	r5, r2
    c4e6:	4094      	lsls	r4, r2
    c4e8:	fa20 f707 	lsr.w	r7, r0, r7
    c4ec:	ea47 0903 	orr.w	r9, r7, r3
    c4f0:	ea4f 4e15 	mov.w	lr, r5, lsr #16
    c4f4:	0c23      	lsrs	r3, r4, #16
    c4f6:	fa1f f885 	uxth.w	r8, r5
    c4fa:	fbb9 fcfe 	udiv	ip, r9, lr
    c4fe:	fb0e 991c 	mls	r9, lr, ip, r9
    c502:	fb0c f108 	mul.w	r1, ip, r8
    c506:	ea43 4309 	orr.w	r3, r3, r9, lsl #16
    c50a:	4299      	cmp	r1, r3
    c50c:	d90a      	bls.n	c524 <__udivmoddi4+0x64>
    c50e:	18eb      	adds	r3, r5, r3
    c510:	bf2c      	ite	cs
    c512:	2001      	movcs	r0, #1
    c514:	2000      	movcc	r0, #0
    c516:	4299      	cmp	r1, r3
    c518:	d902      	bls.n	c520 <__udivmoddi4+0x60>
    c51a:	2800      	cmp	r0, #0
    c51c:	f000 811d 	beq.w	c75a <__udivmoddi4+0x29a>
    c520:	f10c 3cff 	add.w	ip, ip, #4294967295	; 0xffffffff
    c524:	1a59      	subs	r1, r3, r1
    c526:	b2a3      	uxth	r3, r4
    c528:	fbb1 f0fe 	udiv	r0, r1, lr
    c52c:	fb0e 1110 	mls	r1, lr, r0, r1
    c530:	fb00 f808 	mul.w	r8, r0, r8
    c534:	ea43 4401 	orr.w	r4, r3, r1, lsl #16
    c538:	45a0      	cmp	r8, r4
    c53a:	d905      	bls.n	c548 <__udivmoddi4+0x88>
    c53c:	192c      	adds	r4, r5, r4
    c53e:	d202      	bcs.n	c546 <__udivmoddi4+0x86>
    c540:	45a0      	cmp	r8, r4
    c542:	f200 810e 	bhi.w	c762 <__udivmoddi4+0x2a2>
    c546:	3801      	subs	r0, #1
    c548:	eba4 0408 	sub.w	r4, r4, r8
    c54c:	ea40 400c 	orr.w	r0, r0, ip, lsl #16
    c550:	2700      	movs	r7, #0
    c552:	b11e      	cbz	r6, c55c <__udivmoddi4+0x9c>
    c554:	40d4      	lsrs	r4, r2
    c556:	2300      	movs	r3, #0
    c558:	e9c6 4300 	strd	r4, r3, [r6]
    c55c:	4639      	mov	r1, r7
    c55e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    c562:	2a00      	cmp	r2, #0
    c564:	d051      	beq.n	c60a <__udivmoddi4+0x14a>
    c566:	fab2 f282 	clz	r2, r2
    c56a:	2a00      	cmp	r2, #0
    c56c:	f040 80af 	bne.w	c6ce <__udivmoddi4+0x20e>
    c570:	1b49      	subs	r1, r1, r5
    c572:	ea4f 4e15 	mov.w	lr, r5, lsr #16
    c576:	fa1f f885 	uxth.w	r8, r5
    c57a:	2701      	movs	r7, #1
    c57c:	0c23      	lsrs	r3, r4, #16
    c57e:	fbb1 fcfe 	udiv	ip, r1, lr
    c582:	fb0e 111c 	mls	r1, lr, ip, r1
    c586:	fb08 f00c 	mul.w	r0, r8, ip
    c58a:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
    c58e:	4298      	cmp	r0, r3
    c590:	d90a      	bls.n	c5a8 <__udivmoddi4+0xe8>
    c592:	18eb      	adds	r3, r5, r3
    c594:	bf2c      	ite	cs
    c596:	2101      	movcs	r1, #1
    c598:	2100      	movcc	r1, #0
    c59a:	4298      	cmp	r0, r3
    c59c:	d902      	bls.n	c5a4 <__udivmoddi4+0xe4>
    c59e:	2900      	cmp	r1, #0
    c5a0:	f000 80d7 	beq.w	c752 <__udivmoddi4+0x292>
    c5a4:	f10c 3cff 	add.w	ip, ip, #4294967295	; 0xffffffff
    c5a8:	1a19      	subs	r1, r3, r0
    c5aa:	b2a3      	uxth	r3, r4
    c5ac:	fbb1 f0fe 	udiv	r0, r1, lr
    c5b0:	fb0e 1110 	mls	r1, lr, r0, r1
    c5b4:	fb08 f800 	mul.w	r8, r8, r0
    c5b8:	ea43 4401 	orr.w	r4, r3, r1, lsl #16
    c5bc:	45a0      	cmp	r8, r4
    c5be:	d905      	bls.n	c5cc <__udivmoddi4+0x10c>
    c5c0:	192c      	adds	r4, r5, r4
    c5c2:	d202      	bcs.n	c5ca <__udivmoddi4+0x10a>
    c5c4:	45a0      	cmp	r8, r4
    c5c6:	f200 80c1 	bhi.w	c74c <__udivmoddi4+0x28c>
    c5ca:	3801      	subs	r0, #1
    c5cc:	eba4 0408 	sub.w	r4, r4, r8
    c5d0:	ea40 400c 	orr.w	r0, r0, ip, lsl #16
    c5d4:	e7bd      	b.n	c552 <__udivmoddi4+0x92>
    c5d6:	428b      	cmp	r3, r1
    c5d8:	d908      	bls.n	c5ec <__udivmoddi4+0x12c>
    c5da:	2e00      	cmp	r6, #0
    c5dc:	d074      	beq.n	c6c8 <__udivmoddi4+0x208>
    c5de:	2700      	movs	r7, #0
    c5e0:	e9c6 0100 	strd	r0, r1, [r6]
    c5e4:	4638      	mov	r0, r7
    c5e6:	4639      	mov	r1, r7
    c5e8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    c5ec:	fab3 f783 	clz	r7, r3
    c5f0:	b967      	cbnz	r7, c60c <__udivmoddi4+0x14c>
    c5f2:	428b      	cmp	r3, r1
    c5f4:	f0c0 80a4 	bcc.w	c740 <__udivmoddi4+0x280>
    c5f8:	4282      	cmp	r2, r0
    c5fa:	f240 80a1 	bls.w	c740 <__udivmoddi4+0x280>
    c5fe:	4638      	mov	r0, r7
    c600:	2e00      	cmp	r6, #0
    c602:	d0ab      	beq.n	c55c <__udivmoddi4+0x9c>
    c604:	e9c6 4900 	strd	r4, r9, [r6]
    c608:	e7a8      	b.n	c55c <__udivmoddi4+0x9c>
    c60a:	deff      	udf	#255	; 0xff
    c60c:	f1c7 0520 	rsb	r5, r7, #32
    c610:	40bb      	lsls	r3, r7
    c612:	fa02 fc07 	lsl.w	ip, r2, r7
    c616:	fa01 f407 	lsl.w	r4, r1, r7
    c61a:	40ea      	lsrs	r2, r5
    c61c:	fa20 f805 	lsr.w	r8, r0, r5
    c620:	40e9      	lsrs	r1, r5
    c622:	fa00 fe07 	lsl.w	lr, r0, r7
    c626:	431a      	orrs	r2, r3
    c628:	ea48 0404 	orr.w	r4, r8, r4
    c62c:	ea4f 4812 	mov.w	r8, r2, lsr #16
    c630:	0c20      	lsrs	r0, r4, #16
    c632:	fa1f f982 	uxth.w	r9, r2
    c636:	fbb1 faf8 	udiv	sl, r1, r8
    c63a:	fb08 111a 	mls	r1, r8, sl, r1
    c63e:	fb0a fb09 	mul.w	fp, sl, r9
    c642:	ea40 4101 	orr.w	r1, r0, r1, lsl #16
    c646:	458b      	cmp	fp, r1
    c648:	d90a      	bls.n	c660 <__udivmoddi4+0x1a0>
    c64a:	1851      	adds	r1, r2, r1
    c64c:	bf2c      	ite	cs
    c64e:	2301      	movcs	r3, #1
    c650:	2300      	movcc	r3, #0
    c652:	458b      	cmp	fp, r1
    c654:	d902      	bls.n	c65c <__udivmoddi4+0x19c>
    c656:	2b00      	cmp	r3, #0
    c658:	f000 8088 	beq.w	c76c <__udivmoddi4+0x2ac>
    c65c:	f10a 3aff 	add.w	sl, sl, #4294967295	; 0xffffffff
    c660:	eba1 010b 	sub.w	r1, r1, fp
    c664:	b2a4      	uxth	r4, r4
    c666:	fbb1 f0f8 	udiv	r0, r1, r8
    c66a:	fb08 1110 	mls	r1, r8, r0, r1
    c66e:	fb00 f909 	mul.w	r9, r0, r9
    c672:	ea44 4101 	orr.w	r1, r4, r1, lsl #16
    c676:	4589      	cmp	r9, r1
    c678:	d904      	bls.n	c684 <__udivmoddi4+0x1c4>
    c67a:	1851      	adds	r1, r2, r1
    c67c:	d201      	bcs.n	c682 <__udivmoddi4+0x1c2>
    c67e:	4589      	cmp	r9, r1
    c680:	d87b      	bhi.n	c77a <__udivmoddi4+0x2ba>
    c682:	3801      	subs	r0, #1
    c684:	ea40 400a 	orr.w	r0, r0, sl, lsl #16
    c688:	eba1 0109 	sub.w	r1, r1, r9
    c68c:	fba0 890c 	umull	r8, r9, r0, ip
    c690:	4549      	cmp	r1, r9
    c692:	4644      	mov	r4, r8
    c694:	464b      	mov	r3, r9
    c696:	d302      	bcc.n	c69e <__udivmoddi4+0x1de>
    c698:	d106      	bne.n	c6a8 <__udivmoddi4+0x1e8>
    c69a:	45c6      	cmp	lr, r8
    c69c:	d204      	bcs.n	c6a8 <__udivmoddi4+0x1e8>
    c69e:	3801      	subs	r0, #1
    c6a0:	ebb8 040c 	subs.w	r4, r8, ip
    c6a4:	eb69 0302 	sbc.w	r3, r9, r2
    c6a8:	2e00      	cmp	r6, #0
    c6aa:	d05d      	beq.n	c768 <__udivmoddi4+0x2a8>
    c6ac:	ebbe 0204 	subs.w	r2, lr, r4
    c6b0:	eb61 0103 	sbc.w	r1, r1, r3
    c6b4:	fa01 f505 	lsl.w	r5, r1, r5
    c6b8:	fa22 f307 	lsr.w	r3, r2, r7
    c6bc:	40f9      	lsrs	r1, r7
    c6be:	2700      	movs	r7, #0
    c6c0:	431d      	orrs	r5, r3
    c6c2:	e9c6 5100 	strd	r5, r1, [r6]
    c6c6:	e749      	b.n	c55c <__udivmoddi4+0x9c>
    c6c8:	4637      	mov	r7, r6
    c6ca:	4630      	mov	r0, r6
    c6cc:	e746      	b.n	c55c <__udivmoddi4+0x9c>
    c6ce:	f1c2 0020 	rsb	r0, r2, #32
    c6d2:	4095      	lsls	r5, r2
    c6d4:	fa01 f702 	lsl.w	r7, r1, r2
    c6d8:	fa21 f300 	lsr.w	r3, r1, r0
    c6dc:	ea4f 4e15 	mov.w	lr, r5, lsr #16
    c6e0:	fa24 f100 	lsr.w	r1, r4, r0
    c6e4:	fa1f f885 	uxth.w	r8, r5
    c6e8:	4094      	lsls	r4, r2
    c6ea:	4339      	orrs	r1, r7
    c6ec:	fbb3 f0fe 	udiv	r0, r3, lr
    c6f0:	0c0f      	lsrs	r7, r1, #16
    c6f2:	fb0e 3310 	mls	r3, lr, r0, r3
    c6f6:	fb00 fc08 	mul.w	ip, r0, r8
    c6fa:	ea47 4303 	orr.w	r3, r7, r3, lsl #16
    c6fe:	459c      	cmp	ip, r3
    c700:	d907      	bls.n	c712 <__udivmoddi4+0x252>
    c702:	18eb      	adds	r3, r5, r3
    c704:	bf2c      	ite	cs
    c706:	2701      	movcs	r7, #1
    c708:	2700      	movcc	r7, #0
    c70a:	459c      	cmp	ip, r3
    c70c:	d900      	bls.n	c710 <__udivmoddi4+0x250>
    c70e:	b38f      	cbz	r7, c774 <__udivmoddi4+0x2b4>
    c710:	3801      	subs	r0, #1
    c712:	eba3 030c 	sub.w	r3, r3, ip
    c716:	b289      	uxth	r1, r1
    c718:	fbb3 f7fe 	udiv	r7, r3, lr
    c71c:	fb0e 3317 	mls	r3, lr, r7, r3
    c720:	fb07 fc08 	mul.w	ip, r7, r8
    c724:	ea41 4103 	orr.w	r1, r1, r3, lsl #16
    c728:	458c      	cmp	ip, r1
    c72a:	d904      	bls.n	c736 <__udivmoddi4+0x276>
    c72c:	1869      	adds	r1, r5, r1
    c72e:	d201      	bcs.n	c734 <__udivmoddi4+0x274>
    c730:	458c      	cmp	ip, r1
    c732:	d825      	bhi.n	c780 <__udivmoddi4+0x2c0>
    c734:	3f01      	subs	r7, #1
    c736:	eba1 010c 	sub.w	r1, r1, ip
    c73a:	ea47 4700 	orr.w	r7, r7, r0, lsl #16
    c73e:	e71d      	b.n	c57c <__udivmoddi4+0xbc>
    c740:	1a84      	subs	r4, r0, r2
    c742:	eb61 0303 	sbc.w	r3, r1, r3
    c746:	2001      	movs	r0, #1
    c748:	4699      	mov	r9, r3
    c74a:	e759      	b.n	c600 <__udivmoddi4+0x140>
    c74c:	3802      	subs	r0, #2
    c74e:	442c      	add	r4, r5
    c750:	e73c      	b.n	c5cc <__udivmoddi4+0x10c>
    c752:	f1ac 0c02 	sub.w	ip, ip, #2
    c756:	442b      	add	r3, r5
    c758:	e726      	b.n	c5a8 <__udivmoddi4+0xe8>
    c75a:	f1ac 0c02 	sub.w	ip, ip, #2
    c75e:	442b      	add	r3, r5
    c760:	e6e0      	b.n	c524 <__udivmoddi4+0x64>
    c762:	3802      	subs	r0, #2
    c764:	442c      	add	r4, r5
    c766:	e6ef      	b.n	c548 <__udivmoddi4+0x88>
    c768:	4637      	mov	r7, r6
    c76a:	e6f7      	b.n	c55c <__udivmoddi4+0x9c>
    c76c:	f1aa 0a02 	sub.w	sl, sl, #2
    c770:	4411      	add	r1, r2
    c772:	e775      	b.n	c660 <__udivmoddi4+0x1a0>
    c774:	3802      	subs	r0, #2
    c776:	442b      	add	r3, r5
    c778:	e7cb      	b.n	c712 <__udivmoddi4+0x252>
    c77a:	3802      	subs	r0, #2
    c77c:	4411      	add	r1, r2
    c77e:	e781      	b.n	c684 <__udivmoddi4+0x1c4>
    c780:	3f02      	subs	r7, #2
    c782:	4429      	add	r1, r5
    c784:	e7d7      	b.n	c736 <__udivmoddi4+0x276>
    c786:	bf00      	nop

0000c788 <__aeabi_idiv0>:
    c788:	4770      	bx	lr
    c78a:	bf00      	nop

0000c78c <__gnu_cmse_nonsecure_call>:
    c78c:	e92d 4fe0 	stmdb	sp!, {r5, r6, r7, r8, r9, sl, fp, lr}
    c790:	4627      	mov	r7, r4
    c792:	46a0      	mov	r8, r4
    c794:	46a1      	mov	r9, r4
    c796:	46a2      	mov	sl, r4
    c798:	46a3      	mov	fp, r4
    c79a:	46a4      	mov	ip, r4
    c79c:	ed2d 8b10 	vpush	{d8-d15}
    c7a0:	f04f 0500 	mov.w	r5, #0
    c7a4:	ec45 5b18 	vmov	d8, r5, r5
    c7a8:	ec45 5a19 	vmov	s18, s19, r5, r5
    c7ac:	ec45 5a1a 	vmov	s20, s21, r5, r5
    c7b0:	ec45 5a1b 	vmov	s22, s23, r5, r5
    c7b4:	ec45 5a1c 	vmov	s24, s25, r5, r5
    c7b8:	ec45 5a1d 	vmov	s26, s27, r5, r5
    c7bc:	ec45 5a1e 	vmov	s28, s29, r5, r5
    c7c0:	ec45 5a1f 	vmov	s30, s31, r5, r5
    c7c4:	eef1 5a10 	vmrs	r5, fpscr
    c7c8:	f64f 7660 	movw	r6, #65376	; 0xff60
    c7cc:	f6c0 76ff 	movt	r6, #4095	; 0xfff
    c7d0:	4035      	ands	r5, r6
    c7d2:	eee1 5a10 	vmsr	fpscr, r5
    c7d6:	f384 8800 	msr	CPSR_f, r4
    c7da:	4625      	mov	r5, r4
    c7dc:	4626      	mov	r6, r4
    c7de:	47a4      	blxns	r4
    c7e0:	ecbd 8b10 	vpop	{d8-d15}
    c7e4:	e8bd 8fe0 	ldmia.w	sp!, {r5, r6, r7, r8, r9, sl, fp, pc}

0000c7e8 <tz_nonsecure_state_setup>:
}
#endif /* CONFIG_ARMV8_M_MAINLINE */

void tz_nonsecure_state_setup(const tz_nonsecure_setup_conf_t *p_ns_conf)
{
	configure_nonsecure_vtor_offset(p_ns_conf->vtor_ns);
    c7e8:	6882      	ldr	r2, [r0, #8]
	SCB_NS->VTOR = vtor_ns;
    c7ea:	4b0c      	ldr	r3, [pc, #48]	; (c81c <tz_nonsecure_state_setup+0x34>)
    c7ec:	609a      	str	r2, [r3, #8]
  \details Assigns the given value to the non-secure Main Stack Pointer (MSP) when in secure state.
  \param [in]    topOfMainStack  Main Stack Pointer value to set
 */
__STATIC_FORCEINLINE void __TZ_set_MSP_NS(uint32_t topOfMainStack)
{
  __ASM volatile ("MSR msp_ns, %0" : : "r" (topOfMainStack) : );
    c7ee:	6803      	ldr	r3, [r0, #0]
    c7f0:	f383 8888 	msr	MSP_NS, r3
  __ASM volatile ("MSR psp_ns, %0" : : "r" (topOfProcStack) : );
    c7f4:	6843      	ldr	r3, [r0, #4]
    c7f6:	f383 8889 	msr	PSP_NS, r3
	configure_nonsecure_psp(p_ns_conf->psp_ns);
	/* Select which stack-pointer to use (MSP or PSP) and
	 * the privilege level for thread mode.
	 */
	configure_nonsecure_control(p_ns_conf->control_ns.spsel,
		p_ns_conf->control_ns.npriv);
    c7fa:	7b02      	ldrb	r2, [r0, #12]
    c7fc:	f002 0101 	and.w	r1, r2, #1
  __ASM volatile ("MRS %0, control_ns" : "=r" (result) );
    c800:	f3ef 8394 	mrs	r3, CONTROL_NS
	control_ns &= ~(CONTROL_SPSEL_Msk | CONTROL_nPRIV_Msk);
    c804:	f023 0303 	bic.w	r3, r3, #3
	if (spsel_ns) {
    c808:	0792      	lsls	r2, r2, #30
		control_ns |= CONTROL_SPSEL_Msk;
    c80a:	bf48      	it	mi
    c80c:	f043 0302 	orrmi.w	r3, r3, #2
	if (npriv_ns) {
    c810:	b109      	cbz	r1, c816 <tz_nonsecure_state_setup+0x2e>
		control_ns |= CONTROL_nPRIV_Msk;
    c812:	f043 0301 	orr.w	r3, r3, #1
  __ASM volatile ("MSR control_ns, %0" : : "r" (control) : "memory");
    c816:	f383 8894 	msr	CONTROL_NS, r3
}
    c81a:	4770      	bx	lr
    c81c:	e002ed00 	.word	0xe002ed00

0000c820 <tz_nbanked_exception_target_state_set>:

void tz_nbanked_exception_target_state_set(int secure_state)
{
	u32_t aircr_payload = SCB->AIRCR & (~(SCB_AIRCR_VECTKEY_Msk));
    c820:	4a08      	ldr	r2, [pc, #32]	; (c844 <tz_nbanked_exception_target_state_set+0x24>)
    c822:	68d3      	ldr	r3, [r2, #12]
	if (secure_state) {
    c824:	b148      	cbz	r0, c83a <tz_nbanked_exception_target_state_set+0x1a>
		aircr_payload &= ~(SCB_AIRCR_BFHFNMINS_Msk);
    c826:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
    c82a:	041b      	lsls	r3, r3, #16
    c82c:	0c1b      	lsrs	r3, r3, #16
	} else {
		aircr_payload |= SCB_AIRCR_BFHFNMINS_Msk;
	}
	SCB->AIRCR = ((AIRCR_VECT_KEY_PERMIT_WRITE << SCB_AIRCR_VECTKEY_Pos)
			& SCB_AIRCR_VECTKEY_Msk)
		| aircr_payload;
    c82e:	f043 63bf 	orr.w	r3, r3, #100139008	; 0x5f80000
    c832:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
	SCB->AIRCR = ((AIRCR_VECT_KEY_PERMIT_WRITE << SCB_AIRCR_VECTKEY_Pos)
    c836:	60d3      	str	r3, [r2, #12]
}
    c838:	4770      	bx	lr
	u32_t aircr_payload = SCB->AIRCR & (~(SCB_AIRCR_VECTKEY_Msk));
    c83a:	b29b      	uxth	r3, r3
		aircr_payload |= SCB_AIRCR_BFHFNMINS_Msk;
    c83c:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
    c840:	e7f5      	b.n	c82e <tz_nbanked_exception_target_state_set+0xe>
    c842:	bf00      	nop
    c844:	e000ed00 	.word	0xe000ed00

0000c848 <tz_nonsecure_exception_prio_config>:

void tz_nonsecure_exception_prio_config(int secure_boost)
{
	u32_t aircr_payload = SCB->AIRCR & (~(SCB_AIRCR_VECTKEY_Msk));
    c848:	4a08      	ldr	r2, [pc, #32]	; (c86c <tz_nonsecure_exception_prio_config+0x24>)
    c84a:	68d3      	ldr	r3, [r2, #12]
	if (secure_boost) {
    c84c:	b140      	cbz	r0, c860 <tz_nonsecure_exception_prio_config+0x18>
	u32_t aircr_payload = SCB->AIRCR & (~(SCB_AIRCR_VECTKEY_Msk));
    c84e:	b29b      	uxth	r3, r3
		aircr_payload |= SCB_AIRCR_PRIS_Msk;
    c850:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
	} else {
		aircr_payload &= ~(SCB_AIRCR_PRIS_Msk);
	}
	SCB->AIRCR = ((AIRCR_VECT_KEY_PERMIT_WRITE << SCB_AIRCR_VECTKEY_Pos)
			& SCB_AIRCR_VECTKEY_Msk)
		| aircr_payload;
    c854:	f043 63bf 	orr.w	r3, r3, #100139008	; 0x5f80000
    c858:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
	SCB->AIRCR = ((AIRCR_VECT_KEY_PERMIT_WRITE << SCB_AIRCR_VECTKEY_Pos)
    c85c:	60d3      	str	r3, [r2, #12]
}
    c85e:	4770      	bx	lr
		aircr_payload &= ~(SCB_AIRCR_PRIS_Msk);
    c860:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
    c864:	041b      	lsls	r3, r3, #16
    c866:	0c1b      	lsrs	r3, r3, #16
    c868:	e7f4      	b.n	c854 <tz_nonsecure_exception_prio_config+0xc>
    c86a:	bf00      	nop
    c86c:	e000ed00 	.word	0xe000ed00

0000c870 <tz_nonsecure_system_reset_req_block>:

void tz_nonsecure_system_reset_req_block(int block)
{
	u32_t aircr_payload = SCB->AIRCR & (~(SCB_AIRCR_VECTKEY_Msk));
    c870:	4a08      	ldr	r2, [pc, #32]	; (c894 <tz_nonsecure_system_reset_req_block+0x24>)
    c872:	68d3      	ldr	r3, [r2, #12]
	if (block) {
    c874:	b140      	cbz	r0, c888 <tz_nonsecure_system_reset_req_block+0x18>
	u32_t aircr_payload = SCB->AIRCR & (~(SCB_AIRCR_VECTKEY_Msk));
    c876:	b29b      	uxth	r3, r3
		aircr_payload |= SCB_AIRCR_SYSRESETREQS_Msk;
    c878:	f043 0308 	orr.w	r3, r3, #8
	} else {
		aircr_payload &= ~(SCB_AIRCR_SYSRESETREQS_Msk);
	}
	SCB->AIRCR = ((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)
			& SCB_AIRCR_VECTKEY_Msk)
		| aircr_payload;
    c87c:	f043 63bf 	orr.w	r3, r3, #100139008	; 0x5f80000
    c880:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
	SCB->AIRCR = ((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)
    c884:	60d3      	str	r3, [r2, #12]
}
    c886:	4770      	bx	lr
		aircr_payload &= ~(SCB_AIRCR_SYSRESETREQS_Msk);
    c888:	f023 0308 	bic.w	r3, r3, #8
    c88c:	041b      	lsls	r3, r3, #16
    c88e:	0c1b      	lsrs	r3, r3, #16
    c890:	e7f4      	b.n	c87c <tz_nonsecure_system_reset_req_block+0xc>
    c892:	bf00      	nop
    c894:	e000ed00 	.word	0xe000ed00

0000c898 <tz_nonsecure_fpu_access_enable>:

#if defined(CONFIG_ARMV7_M_ARMV8_M_FP)
void tz_nonsecure_fpu_access_enable(void)
{
	SCB->NSACR |=
    c898:	4a03      	ldr	r2, [pc, #12]	; (c8a8 <tz_nonsecure_fpu_access_enable+0x10>)
    c89a:	f8d2 308c 	ldr.w	r3, [r2, #140]	; 0x8c
    c89e:	f443 6340 	orr.w	r3, r3, #3072	; 0xc00
    c8a2:	f8c2 308c 	str.w	r3, [r2, #140]	; 0x8c
		(1UL << SCB_NSACR_CP10_Pos) | (1UL << SCB_NSACR_CP11_Pos);
}
    c8a6:	4770      	bx	lr
    c8a8:	e000ed00 	.word	0xe000ed00

0000c8ac <tz_sau_configure>:
#endif /* CONFIG_ARMV7_M_ARMV8_M_FP */

void tz_sau_configure(int enable, int allns)
{
	if (enable) {
    c8ac:	4b08      	ldr	r3, [pc, #32]	; (c8d0 <tz_sau_configure+0x24>)
  \brief   Enable SAU
  \details Enables the Security Attribution Unit (SAU).
 */
__STATIC_INLINE void TZ_SAU_Enable(void)
{
    SAU->CTRL |=  (SAU_CTRL_ENABLE_Msk);
    c8ae:	681a      	ldr	r2, [r3, #0]
    c8b0:	b118      	cbz	r0, c8ba <tz_sau_configure+0xe>
    c8b2:	f042 0201 	orr.w	r2, r2, #1
	} else {
		TZ_SAU_Disable();
		if (allns) {
			SAU->CTRL |= SAU_CTRL_ALLNS_Msk;
		} else {
			SAU->CTRL &= ~(SAU_CTRL_ALLNS_Msk);
    c8b6:	601a      	str	r2, [r3, #0]
		}
	}
}
    c8b8:	4770      	bx	lr
  \brief   Disable SAU
  \details Disables the Security Attribution Unit (SAU).
 */
__STATIC_INLINE void TZ_SAU_Disable(void)
{
    SAU->CTRL &= ~(SAU_CTRL_ENABLE_Msk);
    c8ba:	f022 0201 	bic.w	r2, r2, #1
    c8be:	601a      	str	r2, [r3, #0]
			SAU->CTRL |= SAU_CTRL_ALLNS_Msk;
    c8c0:	681a      	ldr	r2, [r3, #0]
		if (allns) {
    c8c2:	b111      	cbz	r1, c8ca <tz_sau_configure+0x1e>
			SAU->CTRL |= SAU_CTRL_ALLNS_Msk;
    c8c4:	f042 0202 	orr.w	r2, r2, #2
    c8c8:	e7f5      	b.n	c8b6 <tz_sau_configure+0xa>
			SAU->CTRL &= ~(SAU_CTRL_ALLNS_Msk);
    c8ca:	f022 0202 	bic.w	r2, r2, #2
    c8ce:	e7f2      	b.n	c8b6 <tz_sau_configure+0xa>
    c8d0:	e000edd0 	.word	0xe000edd0

0000c8d4 <char_out>:

static int char_out(int c, void *ctx_p)
{
	struct out_context *ctx = ctx_p;

	ctx->count++;
    c8d4:	680b      	ldr	r3, [r1, #0]
    c8d6:	3301      	adds	r3, #1
    c8d8:	600b      	str	r3, [r1, #0]
	return _char_out(c);
    c8da:	4b01      	ldr	r3, [pc, #4]	; (c8e0 <char_out+0xc>)
    c8dc:	681b      	ldr	r3, [r3, #0]
    c8de:	4718      	bx	r3
    c8e0:	200013d4 	.word	0x200013d4

0000c8e4 <_printk_dec_ulong>:
 * @return N/A
 */
static void _printk_dec_ulong(out_func_t out, void *ctx,
			      const unsigned long num, enum pad_type padding,
			      int min_width)
{
    c8e4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    c8e8:	b085      	sub	sp, #20
    c8ea:	9c0e      	ldr	r4, [sp, #56]	; 0x38
    c8ec:	469b      	mov	fp, r3
    c8ee:	2c01      	cmp	r4, #1
    c8f0:	bfb8      	it	lt
    c8f2:	2401      	movlt	r4, #1
    c8f4:	2b01      	cmp	r3, #1
    c8f6:	bf0c      	ite	eq
    c8f8:	2330      	moveq	r3, #48	; 0x30
    c8fa:	2320      	movne	r3, #32
    c8fc:	4616      	mov	r6, r2
    c8fe:	4682      	mov	sl, r0
    c900:	4688      	mov	r8, r1
    c902:	2501      	movs	r5, #1
    c904:	270a      	movs	r7, #10
    c906:	2200      	movs	r2, #0
    c908:	f8df 906c 	ldr.w	r9, [pc, #108]	; c978 <_printk_dec_ulong+0x94>
    c90c:	9302      	str	r3, [sp, #8]
	if (min_width <= 0) {
		min_width = 1;
	}

	while (pos >= 10) {
		if (found_largest_digit != 0 || remainder >= pos) {
    c90e:	fbb6 f3f9 	udiv	r3, r6, r9
    c912:	9301      	str	r3, [sp, #4]
    c914:	b90a      	cbnz	r2, c91a <_printk_dec_ulong+0x36>
    c916:	45b1      	cmp	r9, r6
    c918:	d81c      	bhi.n	c954 <_printk_dec_ulong+0x70>
			found_largest_digit = 1;
			out((int)(remainder / pos + 48), ctx);
    c91a:	9b01      	ldr	r3, [sp, #4]
    c91c:	4641      	mov	r1, r8
    c91e:	f103 0030 	add.w	r0, r3, #48	; 0x30
    c922:	47d0      	blx	sl
			found_largest_digit = 1;
    c924:	2201      	movs	r2, #1
			digits++;
    c926:	3501      	adds	r5, #1
				&& padding < PAD_SPACE_AFTER) {
			out((int)(padding == PAD_ZERO_BEFORE ? '0' : ' '), ctx);
			digits++;
		}
		remaining--;
		remainder %= pos;
    c928:	9b01      	ldr	r3, [sp, #4]
		remaining--;
    c92a:	3f01      	subs	r7, #1
		remainder %= pos;
    c92c:	fb09 6613 	mls	r6, r9, r3, r6
		pos /= 10;
    c930:	230a      	movs	r3, #10
	while (pos >= 10) {
    c932:	2f01      	cmp	r7, #1
		pos /= 10;
    c934:	fbb9 f9f3 	udiv	r9, r9, r3
	while (pos >= 10) {
    c938:	d1e9      	bne.n	c90e <_printk_dec_ulong+0x2a>
	}
	out((int)(remainder + 48), ctx);
    c93a:	4641      	mov	r1, r8
    c93c:	f106 0030 	add.w	r0, r6, #48	; 0x30
    c940:	47d0      	blx	sl

	if (padding == PAD_SPACE_AFTER) {
    c942:	f1bb 0f03 	cmp.w	fp, #3
    c946:	d102      	bne.n	c94e <_printk_dec_ulong+0x6a>
		remaining = min_width - digits;
    c948:	1b64      	subs	r4, r4, r5
		while (remaining-- > 0) {
    c94a:	2c00      	cmp	r4, #0
    c94c:	dc0e      	bgt.n	c96c <_printk_dec_ulong+0x88>
			out(' ', ctx);
		}
	}
}
    c94e:	b005      	add	sp, #20
    c950:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		} else if (remaining <= min_width
    c954:	42bc      	cmp	r4, r7
    c956:	dbe7      	blt.n	c928 <_printk_dec_ulong+0x44>
				&& padding < PAD_SPACE_AFTER) {
    c958:	f1bb 0f02 	cmp.w	fp, #2
    c95c:	d8e4      	bhi.n	c928 <_printk_dec_ulong+0x44>
			out((int)(padding == PAD_ZERO_BEFORE ? '0' : ' '), ctx);
    c95e:	4641      	mov	r1, r8
    c960:	9802      	ldr	r0, [sp, #8]
    c962:	9203      	str	r2, [sp, #12]
			digits++;
    c964:	3501      	adds	r5, #1
			out((int)(padding == PAD_ZERO_BEFORE ? '0' : ' '), ctx);
    c966:	47d0      	blx	sl
			digits++;
    c968:	9a03      	ldr	r2, [sp, #12]
    c96a:	e7dd      	b.n	c928 <_printk_dec_ulong+0x44>
			out(' ', ctx);
    c96c:	4641      	mov	r1, r8
    c96e:	2020      	movs	r0, #32
    c970:	47d0      	blx	sl
    c972:	3c01      	subs	r4, #1
    c974:	e7e9      	b.n	c94a <_printk_dec_ulong+0x66>
    c976:	bf00      	nop
    c978:	3b9aca00 	.word	0x3b9aca00

0000c97c <__printk_hook_install>:
	_char_out = fn;
    c97c:	4b01      	ldr	r3, [pc, #4]	; (c984 <__printk_hook_install+0x8>)
    c97e:	6018      	str	r0, [r3, #0]
}
    c980:	4770      	bx	lr
    c982:	bf00      	nop
    c984:	200013d4 	.word	0x200013d4

0000c988 <vprintk>:
	struct out_context ctx = { 0 };
    c988:	2300      	movs	r3, #0
{
    c98a:	b507      	push	{r0, r1, r2, lr}
	z_vprintk(char_out, &ctx, fmt, ap);
    c98c:	4602      	mov	r2, r0
	struct out_context ctx = { 0 };
    c98e:	9301      	str	r3, [sp, #4]
	z_vprintk(char_out, &ctx, fmt, ap);
    c990:	4803      	ldr	r0, [pc, #12]	; (c9a0 <vprintk+0x18>)
    c992:	460b      	mov	r3, r1
    c994:	a901      	add	r1, sp, #4
    c996:	f002 ff69 	bl	f86c <z_vprintk>
}
    c99a:	b003      	add	sp, #12
    c99c:	f85d fb04 	ldr.w	pc, [sp], #4
    c9a0:	0000c8d5 	.word	0x0000c8d5

0000c9a4 <nordicsemi_nrf91_init>:
		:
		: "memory");
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	unsigned int tmp;

	__asm__ volatile(
    c9a4:	f04f 0220 	mov.w	r2, #32
    c9a8:	f3ef 8311 	mrs	r3, BASEPRI
    c9ac:	f382 8811 	msr	BASEPRI, r2
    c9b0:	f3bf 8f6f 	isb	sy

	key = irq_lock();

#ifdef CONFIG_NRF_ENABLE_ICACHE
	/* Enable the instruction cache */
	NRF_NVMC->ICACHECNF = NVMC_ICACHECNF_CACHEEN_Msk;
    c9b4:	2101      	movs	r1, #1
    c9b6:	4a04      	ldr	r2, [pc, #16]	; (c9c8 <nordicsemi_nrf91_init+0x24>)
    c9b8:	f8c2 1540 	str.w	r1, [r2, #1344]	; 0x540
	__asm__ volatile(
		"cpsie i;"
		"isb"
		: : : "memory");
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	__asm__ volatile(
    c9bc:	f383 8811 	msr	BASEPRI, r3
    c9c0:	f3bf 8f6f 	isb	sy
	NMI_INIT();

	irq_unlock(key);

	return 0;
}
    c9c4:	2000      	movs	r0, #0
    c9c6:	4770      	bx	lr
    c9c8:	50039000 	.word	0x50039000

0000c9cc <console_out>:
		return c;
	}

#endif  /* CONFIG_UART_CONSOLE_DEBUG_SERVER_HOOKS */

	if ('\n' == c) {
    c9cc:	280a      	cmp	r0, #10
{
    c9ce:	b538      	push	{r3, r4, r5, lr}
    c9d0:	4604      	mov	r4, r0
    c9d2:	4d07      	ldr	r5, [pc, #28]	; (c9f0 <console_out+0x24>)
	if ('\n' == c) {
    c9d4:	d104      	bne.n	c9e0 <console_out+0x14>
    c9d6:	6828      	ldr	r0, [r5, #0]
						unsigned char out_char)
{
	const struct uart_driver_api *api =
		(const struct uart_driver_api *)dev->driver_api;

	api->poll_out(dev, out_char);
    c9d8:	6843      	ldr	r3, [r0, #4]
    c9da:	210d      	movs	r1, #13
    c9dc:	685b      	ldr	r3, [r3, #4]
    c9de:	4798      	blx	r3
		uart_poll_out(uart_console_dev, '\r');
	}
	uart_poll_out(uart_console_dev, c);
    c9e0:	6828      	ldr	r0, [r5, #0]
    c9e2:	6843      	ldr	r3, [r0, #4]
    c9e4:	b2e1      	uxtb	r1, r4
    c9e6:	685b      	ldr	r3, [r3, #4]
    c9e8:	4798      	blx	r3

	return c;
}
    c9ea:	4620      	mov	r0, r4
    c9ec:	bd38      	pop	{r3, r4, r5, pc}
    c9ee:	bf00      	nop
    c9f0:	20000008 	.word	0x20000008

0000c9f4 <uart_console_hook_install>:
 *
 * @return N/A
 */

void uart_console_hook_install(void)
{
    c9f4:	b510      	push	{r4, lr}
	__stdout_hook_install(console_out);
    c9f6:	4c04      	ldr	r4, [pc, #16]	; (ca08 <uart_console_hook_install+0x14>)
    c9f8:	4620      	mov	r0, r4
    c9fa:	f001 f827 	bl	da4c <__stdout_hook_install>
	__printk_hook_install(console_out);
    c9fe:	4620      	mov	r0, r4
}
    ca00:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	__printk_hook_install(console_out);
    ca04:	f7ff bfba 	b.w	c97c <__printk_hook_install>
    ca08:	0000c9cd 	.word	0x0000c9cd

0000ca0c <uart_console_init>:
 * @brief Initialize one UART as the console/debug port
 *
 * @return 0 if successful, otherwise failed.
 */
static int uart_console_init(struct device *arg)
{
    ca0c:	b508      	push	{r3, lr}
	if (z_syscall_trap()) {
		return (struct device *) z_arch_syscall_invoke1(*(u32_t *)&name, K_SYSCALL_DEVICE_GET_BINDING);
	}
#endif
	compiler_barrier();
	return z_impl_device_get_binding(name);
    ca0e:	4804      	ldr	r0, [pc, #16]	; (ca20 <uart_console_init+0x14>)
    ca10:	f001 fa06 	bl	de20 <z_impl_device_get_binding>

	ARG_UNUSED(arg);

	uart_console_dev = device_get_binding(CONFIG_UART_CONSOLE_ON_DEV_NAME);
    ca14:	4b03      	ldr	r3, [pc, #12]	; (ca24 <uart_console_init+0x18>)
    ca16:	6018      	str	r0, [r3, #0]
		}
	}
	k_busy_wait(1000000);
#endif

	uart_console_hook_install();
    ca18:	f7ff ffec 	bl	c9f4 <uart_console_hook_install>

	return 0;
}
    ca1c:	2000      	movs	r0, #0
    ca1e:	bd08      	pop	{r3, pc}
    ca20:	00010897 	.word	0x00010897
    ca24:	20000008 	.word	0x20000008

0000ca28 <nrf_power_clock_isr>:
	}
#endif
}

void nrf_power_clock_isr(void *arg)
{
    ca28:	b508      	push	{r3, lr}
#endif
}

__STATIC_INLINE bool nrf_clock_event_check(nrf_clock_event_t event)
{
    return (bool)*((volatile uint32_t *)((uint8_t *)NRF_CLOCK + event));
    ca2a:	4b11      	ldr	r3, [pc, #68]	; (ca70 <nrf_power_clock_isr+0x48>)
    ca2c:	681a      	ldr	r2, [r3, #0]
	bool ret = nrf_clock_event_check(evt) &&
    ca2e:	b16a      	cbz	r2, ca4c <nrf_power_clock_isr+0x24>
    return (bool)(NRF_CLOCK->INTENCLR & int_mask);
    ca30:	f04f 2250 	mov.w	r2, #1342197760	; 0x50005000
    ca34:	f8d2 2308 	ldr.w	r2, [r2, #776]	; 0x308
	if (ret) {
    ca38:	07d1      	lsls	r1, r2, #31
    ca3a:	d507      	bpl.n	ca4c <nrf_power_clock_isr+0x24>
    *((volatile uint32_t *)((uint8_t *)NRF_CLOCK + event)) = 0x0UL;
    ca3c:	2200      	movs	r2, #0
	ARG_UNUSED(arg);

	if (clock_event_check_and_clean(NRF_CLOCK_EVENT_HFCLKSTARTED,
					NRF_CLOCK_INT_HF_STARTED_MASK)) {
		struct device *hfclk_dev = DEVICE_GET(clock_nrf5_m16src);
		struct nrf_clock_control *data = hfclk_dev->driver_data;
    ca3e:	480d      	ldr	r0, [pc, #52]	; (ca74 <nrf_power_clock_isr+0x4c>)
    ca40:	601a      	str	r2, [r3, #0]

		/* Check needed due to anomaly 201:
		 * HFCLKSTARTED may be generated twice.
		 */
		if (!data->started) {
    ca42:	6883      	ldr	r3, [r0, #8]
    ca44:	7a5b      	ldrb	r3, [r3, #9]
    ca46:	b90b      	cbnz	r3, ca4c <nrf_power_clock_isr+0x24>
			clkstarted_handle(hfclk_dev);
    ca48:	f003 f934 	bl	fcb4 <clkstarted_handle>
    return (bool)*((volatile uint32_t *)((uint8_t *)NRF_CLOCK + event));
    ca4c:	4b0a      	ldr	r3, [pc, #40]	; (ca78 <nrf_power_clock_isr+0x50>)
    ca4e:	681a      	ldr	r2, [r3, #0]
	bool ret = nrf_clock_event_check(evt) &&
    ca50:	b162      	cbz	r2, ca6c <nrf_power_clock_isr+0x44>
    return (bool)(NRF_CLOCK->INTENCLR & int_mask);
    ca52:	f04f 2250 	mov.w	r2, #1342197760	; 0x50005000
    ca56:	f8d2 2308 	ldr.w	r2, [r2, #776]	; 0x308
	if (ret) {
    ca5a:	0792      	lsls	r2, r2, #30
    ca5c:	d506      	bpl.n	ca6c <nrf_power_clock_isr+0x44>
    *((volatile uint32_t *)((uint8_t *)NRF_CLOCK + event)) = 0x0UL;
    ca5e:	2200      	movs	r2, #0

		if (IS_ENABLED(
			CONFIG_CLOCK_CONTROL_NRF_K32SRC_RC_CALIBRATION)) {
			z_nrf_clock_calibration_lfclk_started(lfclk_dev);
		}
		clkstarted_handle(lfclk_dev);
    ca60:	4806      	ldr	r0, [pc, #24]	; (ca7c <nrf_power_clock_isr+0x54>)
    ca62:	601a      	str	r2, [r3, #0]
	usb_power_isr();

	if (IS_ENABLED(CONFIG_CLOCK_CONTROL_NRF_K32SRC_RC_CALIBRATION)) {
		z_nrf_clock_calibration_isr();
	}
}
    ca64:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
		clkstarted_handle(lfclk_dev);
    ca68:	f003 b924 	b.w	fcb4 <clkstarted_handle>
}
    ca6c:	bd08      	pop	{r3, pc}
    ca6e:	bf00      	nop
    ca70:	50005100 	.word	0x50005100
    ca74:	20001484 	.word	0x20001484
    ca78:	50005104 	.word	0x50005104
    ca7c:	20001490 	.word	0x20001490

0000ca80 <rtc1_nrf_isr>:
 * symbol.
 */
void rtc1_nrf_isr(void *arg)
{
	ARG_UNUSED(arg);
	RTC->EVENTS_COMPARE[0] = 0;
    ca80:	2200      	movs	r2, #0
    ca82:	4b0d      	ldr	r3, [pc, #52]	; (cab8 <rtc1_nrf_isr+0x38>)
    ca84:	f8c3 2140 	str.w	r2, [r3, #320]	; 0x140
	__asm__ volatile(
    ca88:	f04f 0220 	mov.w	r2, #32
    ca8c:	f3ef 8111 	mrs	r1, BASEPRI
    ca90:	f382 8811 	msr	BASEPRI, r2
    ca94:	f3bf 8f6f 	isb	sy

	k_spinlock_key_t key = k_spin_lock(&lock);
	u32_t t = counter();
	u32_t dticks = counter_sub(t, last_count) / CYC_PER_TICK;
    ca98:	4a08      	ldr	r2, [pc, #32]	; (cabc <rtc1_nrf_isr+0x3c>)
#endif
}

__STATIC_INLINE uint32_t nrf_rtc_counter_get(NRF_RTC_Type * p_reg)
{
     return p_reg->COUNTER;
    ca9a:	f8d3 0504 	ldr.w	r0, [r3, #1284]	; 0x504
    ca9e:	6813      	ldr	r3, [r2, #0]
	return (a - b) & COUNTER_MAX;
    caa0:	1ac0      	subs	r0, r0, r3
    caa2:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000

	last_count += dticks * CYC_PER_TICK;
    caa6:	4403      	add	r3, r0
    caa8:	6013      	str	r3, [r2, #0]
	__asm__ volatile(
    caaa:	f381 8811 	msr	BASEPRI, r1
    caae:	f3bf 8f6f 	isb	sy
		}
		set_comparator(next);
	}

	k_spin_unlock(&lock, key);
	z_clock_announce(IS_ENABLED(CONFIG_TICKLESS_KERNEL) ? dticks : 1);
    cab2:	f001 bf29 	b.w	e908 <z_clock_announce>
    cab6:	bf00      	nop
    cab8:	50015000 	.word	0x50015000
    cabc:	20000024 	.word	0x20000024

0000cac0 <z_clock_driver_init>:
}

int z_clock_driver_init(struct device *device)
{
    cac0:	b570      	push	{r4, r5, r6, lr}
    cac2:	4818      	ldr	r0, [pc, #96]	; (cb24 <z_clock_driver_init+0x64>)
    cac4:	f001 f9ac 	bl	de20 <z_impl_device_get_binding>
	struct device *clock;

	ARG_UNUSED(device);

	clock = device_get_binding(DT_INST_0_NORDIC_NRF_CLOCK_LABEL "_32K");
	if (!clock) {
    cac8:	b348      	cbz	r0, cb1e <z_clock_driver_init+0x5e>
				   clock_control_subsys_t sys)
{
	const struct clock_control_driver_api *api =
		(const struct clock_control_driver_api *)dev->driver_api;

	return api->on(dev, sys);
    caca:	6843      	ldr	r3, [r0, #4]
    cacc:	2100      	movs	r1, #0
    cace:	681b      	ldr	r3, [r3, #0]
    cad0:	4798      	blx	r3
    p_reg->CC[ch] = cc_val;
    cad2:	2601      	movs	r6, #1
}

__STATIC_INLINE void nrf_rtc_prescaler_set(NRF_RTC_Type * p_reg, uint32_t val)
{
    NRFX_ASSERT(val <= (RTC_PRESCALER_PRESCALER_Msk >> RTC_PRESCALER_PRESCALER_Pos));
    p_reg->PRESCALER = val;
    cad4:	2400      	movs	r4, #0
    p_reg->INTENSET = mask;
    cad6:	f44f 3380 	mov.w	r3, #65536	; 0x10000
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    cada:	f44f 1200 	mov.w	r2, #2097152	; 0x200000
    p_reg->PRESCALER = val;
    cade:	4d12      	ldr	r5, [pc, #72]	; (cb28 <z_clock_driver_init+0x68>)

	/* Clear the event flag and possible pending interrupt */
	nrf_rtc_event_clear(RTC, NRF_RTC_EVENT_COMPARE_0);
	NVIC_ClearPendingIRQ(RTC1_IRQn);

	IRQ_CONNECT(RTC1_IRQn, 1, rtc1_nrf_isr, 0, 0);
    cae0:	4631      	mov	r1, r6
    cae2:	f8c5 4508 	str.w	r4, [r5, #1288]	; 0x508
    p_reg->CC[ch] = cc_val;
    cae6:	f8c5 6540 	str.w	r6, [r5, #1344]	; 0x540
    p_reg->INTENSET = mask;
    caea:	f8c5 3304 	str.w	r3, [r5, #772]	; 0x304
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0;
    caee:	4b0f      	ldr	r3, [pc, #60]	; (cb2c <z_clock_driver_init+0x6c>)
    caf0:	2015      	movs	r0, #21
    caf2:	601c      	str	r4, [r3, #0]
    caf4:	4b0e      	ldr	r3, [pc, #56]	; (cb30 <z_clock_driver_init+0x70>)
    caf6:	f8c3 2180 	str.w	r2, [r3, #384]	; 0x180
    cafa:	4622      	mov	r2, r4
    cafc:	f000 fc18 	bl	d330 <z_arm_irq_priority_set>
	irq_enable(RTC1_IRQn);
    cb00:	2015      	movs	r0, #21
    cb02:	f000 fc05 	bl	d310 <z_arch_irq_enable>

	if (!IS_ENABLED(TICKLESS_KERNEL)) {
		set_comparator(counter() + CYC_PER_TICK);
	}

	return 0;
    cb06:	4620      	mov	r0, r4
    return (uint32_t)p_reg + task;
}

__STATIC_INLINE void nrf_rtc_task_trigger(NRF_RTC_Type * p_reg, nrf_rtc_task_t task)
{
    *(__IO uint32_t *)((uint32_t)p_reg + task) = 1;
    cb08:	4b0a      	ldr	r3, [pc, #40]	; (cb34 <z_clock_driver_init+0x74>)
    cb0a:	601e      	str	r6, [r3, #0]
    cb0c:	602e      	str	r6, [r5, #0]
     return p_reg->COUNTER;
    cb0e:	f8d5 3504 	ldr.w	r3, [r5, #1284]	; 0x504
		set_comparator(counter() + CYC_PER_TICK);
    cb12:	4433      	add	r3, r6
	nrf_rtc_cc_set(RTC, 0, cyc & COUNTER_MAX);
    cb14:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
    p_reg->CC[ch] = cc_val;
    cb18:	f8c5 3540 	str.w	r3, [r5, #1344]	; 0x540
}
    cb1c:	bd70      	pop	{r4, r5, r6, pc}
		return -1;
    cb1e:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    cb22:	e7fb      	b.n	cb1c <z_clock_driver_init+0x5c>
    cb24:	0001089e 	.word	0x0001089e
    cb28:	50015000 	.word	0x50015000
    cb2c:	50015140 	.word	0x50015140
    cb30:	e000e100 	.word	0xe000e100
    cb34:	50015008 	.word	0x50015008

0000cb38 <z_clock_set_timeout>:

void z_clock_set_timeout(s32_t ticks, bool idle)
{
    cb38:	b570      	push	{r4, r5, r6, lr}
	ARG_UNUSED(idle);

#ifdef CONFIG_TICKLESS_KERNEL
	ticks = (ticks == K_FOREVER) ? MAX_TICKS : ticks;
    cb3a:	4e21      	ldr	r6, [pc, #132]	; (cbc0 <z_clock_set_timeout+0x88>)
    cb3c:	f1b0 3fff 	cmp.w	r0, #4294967295	; 0xffffffff
    cb40:	bf08      	it	eq
    cb42:	4630      	moveq	r0, r6
	__asm__ volatile(
    cb44:	f04f 0320 	mov.w	r3, #32
    cb48:	f3ef 8411 	mrs	r4, BASEPRI
    cb4c:	f383 8811 	msr	BASEPRI, r3
    cb50:	f3bf 8f6f 	isb	sy
     return p_reg->COUNTER;
    cb54:	491b      	ldr	r1, [pc, #108]	; (cbc4 <z_clock_set_timeout+0x8c>)
	k_spinlock_key_t key = k_spin_lock(&lock);
	u32_t cyc, dt, t = counter();
	bool zli_fixup = IS_ENABLED(CONFIG_ZERO_LATENCY_IRQS);

	/* Round up to next tick boundary */
	cyc = ticks * CYC_PER_TICK + 1 + counter_sub(t, last_count);
    cb56:	4b1c      	ldr	r3, [pc, #112]	; (cbc8 <z_clock_set_timeout+0x90>)
    cb58:	f8d1 2504 	ldr.w	r2, [r1, #1284]	; 0x504
    cb5c:	681d      	ldr	r5, [r3, #0]
	ticks = MAX(MIN(ticks - 1, (s32_t)MAX_TICKS), 0);
    cb5e:	3801      	subs	r0, #1
	return (a - b) & COUNTER_MAX;
    cb60:	1b53      	subs	r3, r2, r5
    cb62:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
	cyc += (CYC_PER_TICK - 1);
	cyc = (cyc / CYC_PER_TICK) * CYC_PER_TICK;
	cyc += last_count;
    cb66:	3501      	adds	r5, #1
    cb68:	442b      	add	r3, r5
	cyc = ticks * CYC_PER_TICK + 1 + counter_sub(t, last_count);
    cb6a:	ea20 70e0 	bic.w	r0, r0, r0, asr #31
	cyc += last_count;
    cb6e:	42b0      	cmp	r0, r6
    cb70:	bfd4      	ite	le
    cb72:	1818      	addle	r0, r3, r0
    cb74:	1998      	addgt	r0, r3, r6
	return (a - b) & COUNTER_MAX;
    cb76:	1a82      	subs	r2, r0, r2
    cb78:	f022 427f 	bic.w	r2, r2, #4278190080	; 0xff000000
    cb7c:	f020 437f 	bic.w	r3, r0, #4278190080	; 0xff000000
	 * least on nRF52.  Some experimentation on nrf52840 shows
	 * that you need to be early by about 400 processor cycles
	 * (about 1/5th of a RTC cycle) in order to reliably get the
	 * interrupt.  The docs say two cycles, they mean two cycles.
	 */
	if (counter_sub(cyc, t) > 2) {
    cb80:	2a02      	cmp	r2, #2
    p_reg->CC[ch] = cc_val;
    cb82:	f8c1 3540 	str.w	r3, [r1, #1344]	; 0x540
    cb86:	d904      	bls.n	cb92 <z_clock_set_timeout+0x5a>
	__asm__ volatile(
    cb88:	f384 8811 	msr	BASEPRI, r4
    cb8c:	f3bf 8f6f 	isb	sy
	}
#endif

	k_spin_unlock(&lock, key);
#endif /* CONFIG_TICKLESS_KERNEL */
}
    cb90:	bd70      	pop	{r4, r5, r6, pc}
     return p_reg->COUNTER;
    cb92:	f8d1 3504 	ldr.w	r3, [r1, #1284]	; 0x504
		if (dt == 0 || dt > 0x7fffff) {
    cb96:	4a0d      	ldr	r2, [pc, #52]	; (cbcc <z_clock_set_timeout+0x94>)
	return (a - b) & COUNTER_MAX;
    cb98:	1ac3      	subs	r3, r0, r3
    cb9a:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
		if (dt == 0 || dt > 0x7fffff) {
    cb9e:	1e5d      	subs	r5, r3, #1
    cba0:	4295      	cmp	r5, r2
    cba2:	d905      	bls.n	cbb0 <z_clock_set_timeout+0x78>
    NVIC->ISPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    cba4:	f44f 1200 	mov.w	r2, #2097152	; 0x200000
    cba8:	4b09      	ldr	r3, [pc, #36]	; (cbd0 <z_clock_set_timeout+0x98>)
    cbaa:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
    cbae:	e7eb      	b.n	cb88 <z_clock_set_timeout+0x50>
		} else if (dt == 1) {
    cbb0:	2b01      	cmp	r3, #1
			set_comparator(cyc + 2);
    cbb2:	bf02      	ittt	eq
    cbb4:	3002      	addeq	r0, #2
	nrf_rtc_cc_set(RTC, 0, cyc & COUNTER_MAX);
    cbb6:	f020 407f 	biceq.w	r0, r0, #4278190080	; 0xff000000
    p_reg->CC[ch] = cc_val;
    cbba:	f8c1 0540 	streq.w	r0, [r1, #1344]	; 0x540
    cbbe:	e7e3      	b.n	cb88 <z_clock_set_timeout+0x50>
    cbc0:	00fffffe 	.word	0x00fffffe
    cbc4:	50015000 	.word	0x50015000
    cbc8:	20000024 	.word	0x20000024
    cbcc:	007ffffe 	.word	0x007ffffe
    cbd0:	e000e100 	.word	0xe000e100

0000cbd4 <z_clock_elapsed>:
	__asm__ volatile(
    cbd4:	f04f 0220 	mov.w	r2, #32
    cbd8:	f3ef 8311 	mrs	r3, BASEPRI
    cbdc:	f382 8811 	msr	BASEPRI, r2
    cbe0:	f3bf 8f6f 	isb	sy
     return p_reg->COUNTER;
    cbe4:	4a06      	ldr	r2, [pc, #24]	; (cc00 <z_clock_elapsed+0x2c>)
    cbe6:	f8d2 0504 	ldr.w	r0, [r2, #1284]	; 0x504
	if (!IS_ENABLED(CONFIG_TICKLESS_KERNEL)) {
		return 0;
	}

	k_spinlock_key_t key = k_spin_lock(&lock);
	u32_t ret = counter_sub(counter(), last_count) / CYC_PER_TICK;
    cbea:	4a06      	ldr	r2, [pc, #24]	; (cc04 <z_clock_elapsed+0x30>)
	return (a - b) & COUNTER_MAX;
    cbec:	6812      	ldr	r2, [r2, #0]
    cbee:	1a80      	subs	r0, r0, r2
    cbf0:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
	__asm__ volatile(
    cbf4:	f383 8811 	msr	BASEPRI, r3
    cbf8:	f3bf 8f6f 	isb	sy

	k_spin_unlock(&lock, key);
	return ret;
}
    cbfc:	4770      	bx	lr
    cbfe:	bf00      	nop
    cc00:	50015000 	.word	0x50015000
    cc04:	20000024 	.word	0x20000024

0000cc08 <spm_config_peripheral.constprop.1>:
		     SPU_PERIPHID_PERM_SECUREMAPPING_Split;

	return present && (usel || split);
}

static int spm_config_peripheral(u8_t id, bool dma_present)
    cc08:	b508      	push	{r3, lr}
	 * Assign DMA capabilities and lock down the attribution.
	 *
	 * Note: the function assumes that the peripheral ID matches
	 * the IRQ line.
	 */
	NVIC_DisableIRQ(id);
    cc0a:	b243      	sxtb	r3, r0
  if ((int32_t)(IRQn) >= 0)
    cc0c:	2b00      	cmp	r3, #0
    cc0e:	db0c      	blt.n	cc2a <spm_config_peripheral.constprop.1+0x22>
    NVIC->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    cc10:	2201      	movs	r2, #1
    cc12:	f000 011f 	and.w	r1, r0, #31
    cc16:	408a      	lsls	r2, r1
    cc18:	095b      	lsrs	r3, r3, #5
    cc1a:	4910      	ldr	r1, [pc, #64]	; (cc5c <spm_config_peripheral.constprop.1+0x54>)
    cc1c:	3320      	adds	r3, #32
    cc1e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__STATIC_FORCEINLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
    cc22:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    cc26:	f3bf 8f6f 	isb	sy
	const u32_t perm = NRF_SPU->PERIPHID[id].PERM;
    cc2a:	0083      	lsls	r3, r0, #2
    cc2c:	f103 43a0 	add.w	r3, r3, #1342177280	; 0x50000000
    cc30:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
	if (id == NRFX_PERIPHERAL_ID_GET(NRF_GPIOTE1_NS)) {
    cc34:	2831      	cmp	r0, #49	; 0x31
	const u32_t perm = NRF_SPU->PERIPHID[id].PERM;
    cc36:	f8d3 2800 	ldr.w	r2, [r3, #2048]	; 0x800
	if (id == NRFX_PERIPHERAL_ID_GET(NRF_GPIOTE1_NS)) {
    cc3a:	d006      	beq.n	cc4a <spm_config_peripheral.constprop.1+0x42>
	return present && (usel || split);
    cc3c:	2a00      	cmp	r2, #0
    cc3e:	da07      	bge.n	cc50 <spm_config_peripheral.constprop.1+0x48>
	bool usel = (perm & SPU_PERIPHID_PERM_SECUREMAPPING_Msk) ==
    cc40:	f002 0203 	and.w	r2, r2, #3
	return present && (usel || split);
    cc44:	3a02      	subs	r2, #2
    cc46:	2a01      	cmp	r2, #1
    cc48:	d802      	bhi.n	cc50 <spm_config_peripheral.constprop.1+0x48>

	if (usel_or_split(id)) {
		NRF_SPU->PERIPHID[id].PERM = PERIPH_PRESENT | PERIPH_NONSEC |
    cc4a:	4a05      	ldr	r2, [pc, #20]	; (cc60 <spm_config_peripheral.constprop.1+0x58>)
    cc4c:	f8c3 2800 	str.w	r2, [r3, #2048]	; 0x800
	}

	/* Even for non-present peripherals we force IRQs to be routed
	 * to Non-Secure state.
	 */
	irq_target_state_set(id, 0);
    cc50:	2100      	movs	r1, #0
    cc52:	f003 f89c 	bl	fd8e <irq_target_state_set>
	return 0;
}
    cc56:	2000      	movs	r0, #0
    cc58:	bd08      	pop	{r3, pc}
    cc5a:	bf00      	nop
    cc5c:	e000e100 	.word	0xe000e100
    cc60:	80000100 	.word	0x80000100

0000cc64 <spm_jump>:
	tz_nonsecure_fpu_access_enable();
#endif /* CONFIG_ARMV7_M_ARMV8_M_FP */
}

void spm_jump(void)
{
    cc64:	b530      	push	{r4, r5, lr}
	 * The assumption is that the MSP is located at VTOR_NS[0].
	 */
	u32_t *vtor_ns = (u32_t *)NON_SECURE_APP_ADDRESS;

	PRINT("SPM: NS image at 0x%x\n", (u32_t)vtor_ns);
	PRINT("SPM: NS MSP at 0x%x\n", vtor_ns[0]);
    cc66:	f44f 34c1 	mov.w	r4, #98816	; 0x18200
{
    cc6a:	b085      	sub	sp, #20
	PRINT("SPM: NS reset vector at 0x%x\n", vtor_ns[1]);
    cc6c:	4d2e      	ldr	r5, [pc, #184]	; (cd28 <spm_jump+0xc4>)
	PRINT("SPM: NS image at 0x%x\n", (u32_t)vtor_ns);
    cc6e:	f44f 31c1 	mov.w	r1, #98816	; 0x18200
    cc72:	482e      	ldr	r0, [pc, #184]	; (cd2c <spm_jump+0xc8>)
    cc74:	f002 ff6a 	bl	fb4c <printk>
	PRINT("SPM: NS MSP at 0x%x\n", vtor_ns[0]);
    cc78:	6821      	ldr	r1, [r4, #0]
    cc7a:	482d      	ldr	r0, [pc, #180]	; (cd30 <spm_jump+0xcc>)
    cc7c:	f002 ff66 	bl	fb4c <printk>
	PRINT("SPM: NS reset vector at 0x%x\n", vtor_ns[1]);
    cc80:	6829      	ldr	r1, [r5, #0]
    cc82:	482c      	ldr	r0, [pc, #176]	; (cd34 <spm_jump+0xd0>)
    cc84:	f002 ff62 	bl	fb4c <printk>

	/* Configure Non-Secure stack */
	tz_nonsecure_setup_conf_t spm_ns_conf = {
    cc88:	2210      	movs	r2, #16
    cc8a:	2100      	movs	r1, #0
    cc8c:	4668      	mov	r0, sp
    cc8e:	f003 f92d 	bl	feec <memset>
		.vtor_ns = (u32_t)vtor_ns,
		.msp_ns = vtor_ns[0],
    cc92:	6823      	ldr	r3, [r4, #0]
	tz_nonsecure_state_setup(spm_ns_conf);
    cc94:	4668      	mov	r0, sp
	tz_nonsecure_setup_conf_t spm_ns_conf = {
    cc96:	9300      	str	r3, [sp, #0]
    cc98:	9402      	str	r4, [sp, #8]
	tz_nonsecure_state_setup(spm_ns_conf);
    cc9a:	f7ff fda5 	bl	c7e8 <tz_nonsecure_state_setup>
	tz_nonsecure_exception_prio_config(1);
    cc9e:	2001      	movs	r0, #1
    cca0:	f7ff fdd2 	bl	c848 <tz_nonsecure_exception_prio_config>
	tz_nbanked_exception_target_state_set(0);
    cca4:	2000      	movs	r0, #0
    cca6:	f7ff fdbb 	bl	c820 <tz_nbanked_exception_target_state_set>
	tz_nonsecure_system_reset_req_block(
    ccaa:	2000      	movs	r0, #0
    ccac:	f7ff fde0 	bl	c870 <tz_nonsecure_system_reset_req_block>
	tz_sau_configure(0, 1);
    ccb0:	2101      	movs	r1, #1
    ccb2:	2000      	movs	r0, #0
    ccb4:	f7ff fdfa 	bl	c8ac <tz_sau_configure>
	tz_nonsecure_fpu_access_enable();
    ccb8:	f7ff fdee 	bl	c898 <tz_nonsecure_fpu_access_enable>

	spm_configure_ns(&spm_ns_conf);

	/* Generate function pointer for Non-Secure function call. */
	TZ_NONSECURE_FUNC_PTR_DECLARE(reset_ns);
	reset_ns = TZ_NONSECURE_FUNC_PTR_CREATE(vtor_ns[1]);
    ccbc:	682c      	ldr	r4, [r5, #0]

	if (TZ_NONSECURE_FUNC_PTR_IS_NS(reset_ns)) {
		PRINT("SPM: prepare to jump to Non-Secure image.\n");
    ccbe:	481e      	ldr	r0, [pc, #120]	; (cd38 <spm_jump+0xd4>)
    ccc0:	f002 ff44 	bl	fb4c <printk>
		/* Note: Move UARTE0 before jumping, if it is
		 * to be used on the Non-Secure domain.
		 */

		/* Configure UARTE0 as non-secure */
		spm_config_peripheral(
    ccc4:	2008      	movs	r0, #8
    ccc6:	f7ff ff9f 	bl	cc08 <spm_config_peripheral.constprop.1>
	reset_ns = TZ_NONSECURE_FUNC_PTR_CREATE(vtor_ns[1]);
    ccca:	f024 0401 	bic.w	r4, r4, #1
  __ASM volatile ("dsb 0xF":::"memory");
    ccce:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    ccd2:	f3bf 8f6f 	isb	sy

		__DSB();
		__ISB();

		/* Jump to Non-Secure firmware */
		reset_ns();
    ccd6:	0864      	lsrs	r4, r4, #1
    ccd8:	0064      	lsls	r4, r4, #1
    ccda:	4620      	mov	r0, r4
    ccdc:	4621      	mov	r1, r4
    ccde:	4622      	mov	r2, r4
    cce0:	4623      	mov	r3, r4
    cce2:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
    cce6:	eef7 0a00 	vmov.f32	s1, #112	; 0x3f800000  1.0
    ccea:	eeb7 1a00 	vmov.f32	s2, #112	; 0x3f800000  1.0
    ccee:	eef7 1a00 	vmov.f32	s3, #112	; 0x3f800000  1.0
    ccf2:	eeb7 2a00 	vmov.f32	s4, #112	; 0x3f800000  1.0
    ccf6:	eef7 2a00 	vmov.f32	s5, #112	; 0x3f800000  1.0
    ccfa:	eeb7 3a00 	vmov.f32	s6, #112	; 0x3f800000  1.0
    ccfe:	eef7 3a00 	vmov.f32	s7, #112	; 0x3f800000  1.0
    cd02:	eeb7 4a00 	vmov.f32	s8, #112	; 0x3f800000  1.0
    cd06:	eef7 4a00 	vmov.f32	s9, #112	; 0x3f800000  1.0
    cd0a:	eeb7 5a00 	vmov.f32	s10, #112	; 0x3f800000  1.0
    cd0e:	eef7 5a00 	vmov.f32	s11, #112	; 0x3f800000  1.0
    cd12:	eeb7 6a00 	vmov.f32	s12, #112	; 0x3f800000  1.0
    cd16:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
    cd1a:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
    cd1e:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
    cd22:	f7ff fd33 	bl	c78c <__gnu_cmse_nonsecure_call>

		CODE_UNREACHABLE;
    cd26:	bf00      	nop
    cd28:	00018204 	.word	0x00018204
    cd2c:	00010a00 	.word	0x00010a00
    cd30:	00010a17 	.word	0x00010a17
    cd34:	00010a2c 	.word	0x00010a2c
    cd38:	00010a4a 	.word	0x00010a4a

0000cd3c <spm_config>:
		      (u32_t)reset_ns);
	}
}

void spm_config(void)
{
    cd3c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	PRINT("Flash region\t\tDomain\t\tPermissions\n");
    cd40:	4871      	ldr	r0, [pc, #452]	; (cf08 <spm_config+0x1cc>)
    cd42:	f002 ff03 	bl	fb4c <printk>
	for (size_t i = 0; i < ARRAY_SIZE(flash_perm); i++) {
    cd46:	2100      	movs	r1, #0
    cd48:	4e70      	ldr	r6, [pc, #448]	; (cf0c <spm_config+0x1d0>)
		NRF_SPU->FLASHREGION[i].PERM = flash_perm[i];
    cd4a:	f8df 91dc 	ldr.w	r9, [pc, #476]	; cf28 <spm_config+0x1ec>
		PRINT("%02u 0x%05x 0x%05x \t", i, 32 * KB(i), 32 * KB(i + 1));
    cd4e:	f8df 8204 	ldr.w	r8, [pc, #516]	; cf54 <spm_config+0x218>
		PRINT("%c", flash_perm[i] & FLASH_READ  ? 'r' : '-');
    cd52:	4d6f      	ldr	r5, [pc, #444]	; (cf10 <spm_config+0x1d4>)
		NRF_SPU->FLASHREGION[i].PERM = flash_perm[i];
    cd54:	f856 4b04 	ldr.w	r4, [r6], #4
    cd58:	03ca      	lsls	r2, r1, #15
    cd5a:	f501 73c0 	add.w	r3, r1, #384	; 0x180
    cd5e:	f849 4023 	str.w	r4, [r9, r3, lsl #2]
		PRINT("%02u 0x%05x 0x%05x \t", i, 32 * KB(i), 32 * KB(i + 1));
    cd62:	4640      	mov	r0, r8
    cd64:	f502 4300 	add.w	r3, r2, #32768	; 0x8000
    cd68:	1c4f      	adds	r7, r1, #1
    cd6a:	f002 feef 	bl	fb4c <printk>
		PRINT("%s", flash_perm[i] & FLASH_SECURE ? "Secure\t\t" :
    cd6e:	4b69      	ldr	r3, [pc, #420]	; (cf14 <spm_config+0x1d8>)
    cd70:	f014 0f10 	tst.w	r4, #16
    cd74:	4968      	ldr	r1, [pc, #416]	; (cf18 <spm_config+0x1dc>)
    cd76:	4869      	ldr	r0, [pc, #420]	; (cf1c <spm_config+0x1e0>)
    cd78:	bf08      	it	eq
    cd7a:	4619      	moveq	r1, r3
    cd7c:	f002 fee6 	bl	fb4c <printk>
		PRINT("%c", flash_perm[i] & FLASH_READ  ? 'r' : '-');
    cd80:	f014 0f04 	tst.w	r4, #4
    cd84:	bf14      	ite	ne
    cd86:	2172      	movne	r1, #114	; 0x72
    cd88:	212d      	moveq	r1, #45	; 0x2d
    cd8a:	4628      	mov	r0, r5
    cd8c:	f002 fede 	bl	fb4c <printk>
		PRINT("%c", flash_perm[i] & FLASH_WRITE ? 'w' : '-');
    cd90:	f014 0f02 	tst.w	r4, #2
    cd94:	bf14      	ite	ne
    cd96:	2177      	movne	r1, #119	; 0x77
    cd98:	212d      	moveq	r1, #45	; 0x2d
    cd9a:	4628      	mov	r0, r5
    cd9c:	f002 fed6 	bl	fb4c <printk>
		PRINT("%c", flash_perm[i] & FLASH_EXEC  ? 'x' : '-');
    cda0:	f014 0f01 	tst.w	r4, #1
    cda4:	bf14      	ite	ne
    cda6:	2178      	movne	r1, #120	; 0x78
    cda8:	212d      	moveq	r1, #45	; 0x2d
    cdaa:	4628      	mov	r0, r5
    cdac:	f002 fece 	bl	fb4c <printk>
		PRINT("%c", flash_perm[i] & FLASH_LOCK  ? 'l' : '-');
    cdb0:	f414 7f80 	tst.w	r4, #256	; 0x100
    cdb4:	bf14      	ite	ne
    cdb6:	216c      	movne	r1, #108	; 0x6c
    cdb8:	212d      	moveq	r1, #45	; 0x2d
    cdba:	4628      	mov	r0, r5
    cdbc:	f002 fec6 	bl	fb4c <printk>
		PRINT("\n");
    cdc0:	4857      	ldr	r0, [pc, #348]	; (cf20 <spm_config+0x1e4>)
    cdc2:	f002 fec3 	bl	fb4c <printk>
	for (size_t i = 0; i < ARRAY_SIZE(flash_perm); i++) {
    cdc6:	2f20      	cmp	r7, #32
    cdc8:	4639      	mov	r1, r7
    cdca:	d1c3      	bne.n	cd54 <spm_config+0x18>
	u32_t nsc_size = FLASH_NSC_SIZE_FROM_ADDR(__sg_start);
    cdcc:	4b55      	ldr	r3, [pc, #340]	; (cf24 <spm_config+0x1e8>)
	NRF_SPU->FLASHNSC[0].REGION = FLASH_NSC_REGION_FROM_ADDR(__sg_start);
    cdce:	4a56      	ldr	r2, [pc, #344]	; (cf28 <spm_config+0x1ec>)
    cdd0:	f3c3 31c4 	ubfx	r1, r3, #15, #5
	u32_t nsc_size = FLASH_NSC_SIZE_FROM_ADDR(__sg_start);
    cdd4:	f3c3 030e 	ubfx	r3, r3, #0, #15
    cdd8:	f5c3 4300 	rsb	r3, r3, #32768	; 0x8000
	NRF_SPU->FLASHNSC[0].SIZE = FLASH_NSC_SIZE_REG(nsc_size);
    cddc:	f3c3 1343 	ubfx	r3, r3, #5, #4
	NRF_SPU->FLASHNSC[0].REGION = FLASH_NSC_REGION_FROM_ADDR(__sg_start);
    cde0:	f8c2 1500 	str.w	r1, [r2, #1280]	; 0x500
	NRF_SPU->FLASHNSC[0].SIZE = FLASH_NSC_SIZE_REG(nsc_size);
    cde4:	f8c2 3504 	str.w	r3, [r2, #1284]	; 0x504
	PRINT("Non-secure callable region 0 placed in flash region %d with size %d.\n",
    cde8:	f8d2 1500 	ldr.w	r1, [r2, #1280]	; 0x500
    cdec:	f8d2 2504 	ldr.w	r2, [r2, #1284]	; 0x504
    cdf0:	484e      	ldr	r0, [pc, #312]	; (cf2c <spm_config+0x1f0>)
    cdf2:	0152      	lsls	r2, r2, #5
    cdf4:	f002 feaa 	bl	fb4c <printk>
	PRINT("\n");
    cdf8:	4849      	ldr	r0, [pc, #292]	; (cf20 <spm_config+0x1e4>)
    cdfa:	f002 fea7 	bl	fb4c <printk>
	int err = spm_secure_services_init();
    cdfe:	f002 ff78 	bl	fcf2 <spm_secure_services_init>
	if (err != 0) {
    ce02:	4601      	mov	r1, r0
    ce04:	b110      	cbz	r0, ce0c <spm_config+0xd0>
		PRINT("Could not initialize secure services (err %d).\n", err);
    ce06:	484a      	ldr	r0, [pc, #296]	; (cf30 <spm_config+0x1f4>)
    ce08:	f002 fea0 	bl	fb4c <printk>
	PRINT("\n");
    ce0c:	4844      	ldr	r0, [pc, #272]	; (cf20 <spm_config+0x1e4>)
    ce0e:	f002 fe9d 	bl	fb4c <printk>
	PRINT("SRAM region\t\tDomain\t\tPermissions\n");
    ce12:	4848      	ldr	r0, [pc, #288]	; (cf34 <spm_config+0x1f8>)
    ce14:	f002 fe9a 	bl	fb4c <printk>
	for (size_t i = 0; i < ARRAY_SIZE(sram_perm); i++) {
    ce18:	2100      	movs	r1, #0
    ce1a:	4e47      	ldr	r6, [pc, #284]	; (cf38 <spm_config+0x1fc>)
		NRF_SPU->RAMREGION[i].PERM = sram_perm[i];
    ce1c:	f8df 9108 	ldr.w	r9, [pc, #264]	; cf28 <spm_config+0x1ec>
		PRINT("%02u 0x%05x 0x%05x\t", i, 8 * KB(i), 8 * KB(i + 1));
    ce20:	f8df 8134 	ldr.w	r8, [pc, #308]	; cf58 <spm_config+0x21c>
		PRINT("%c", sram_perm[i] & SRAM_READ  ? 'r' : '-');
    ce24:	4d3a      	ldr	r5, [pc, #232]	; (cf10 <spm_config+0x1d4>)
		NRF_SPU->RAMREGION[i].PERM = sram_perm[i];
    ce26:	f856 4b04 	ldr.w	r4, [r6], #4
    ce2a:	034a      	lsls	r2, r1, #13
    ce2c:	f501 73e0 	add.w	r3, r1, #448	; 0x1c0
    ce30:	f849 4023 	str.w	r4, [r9, r3, lsl #2]
		PRINT("%02u 0x%05x 0x%05x\t", i, 8 * KB(i), 8 * KB(i + 1));
    ce34:	4640      	mov	r0, r8
    ce36:	f502 5300 	add.w	r3, r2, #8192	; 0x2000
    ce3a:	1c4f      	adds	r7, r1, #1
    ce3c:	f002 fe86 	bl	fb4c <printk>
		PRINT("%s", sram_perm[i] & SRAM_SECURE ? "Secure\t\t" :
    ce40:	4b34      	ldr	r3, [pc, #208]	; (cf14 <spm_config+0x1d8>)
    ce42:	f014 0f10 	tst.w	r4, #16
    ce46:	4934      	ldr	r1, [pc, #208]	; (cf18 <spm_config+0x1dc>)
    ce48:	4834      	ldr	r0, [pc, #208]	; (cf1c <spm_config+0x1e0>)
    ce4a:	bf08      	it	eq
    ce4c:	4619      	moveq	r1, r3
    ce4e:	f002 fe7d 	bl	fb4c <printk>
		PRINT("%c", sram_perm[i] & SRAM_READ  ? 'r' : '-');
    ce52:	f014 0f04 	tst.w	r4, #4
    ce56:	bf14      	ite	ne
    ce58:	2172      	movne	r1, #114	; 0x72
    ce5a:	212d      	moveq	r1, #45	; 0x2d
    ce5c:	4628      	mov	r0, r5
    ce5e:	f002 fe75 	bl	fb4c <printk>
		PRINT("%c", sram_perm[i] & SRAM_WRITE ? 'w' : '-');
    ce62:	f014 0f02 	tst.w	r4, #2
    ce66:	bf14      	ite	ne
    ce68:	2177      	movne	r1, #119	; 0x77
    ce6a:	212d      	moveq	r1, #45	; 0x2d
    ce6c:	4628      	mov	r0, r5
    ce6e:	f002 fe6d 	bl	fb4c <printk>
		PRINT("%c", sram_perm[i] & SRAM_EXEC  ? 'x' : '-');
    ce72:	f014 0f01 	tst.w	r4, #1
    ce76:	bf14      	ite	ne
    ce78:	2178      	movne	r1, #120	; 0x78
    ce7a:	212d      	moveq	r1, #45	; 0x2d
    ce7c:	4628      	mov	r0, r5
    ce7e:	f002 fe65 	bl	fb4c <printk>
		PRINT("%c", sram_perm[i] & SRAM_LOCK  ? 'l' : '-');
    ce82:	f414 7f80 	tst.w	r4, #256	; 0x100
    ce86:	bf14      	ite	ne
    ce88:	216c      	movne	r1, #108	; 0x6c
    ce8a:	212d      	moveq	r1, #45	; 0x2d
    ce8c:	4628      	mov	r0, r5
    ce8e:	f002 fe5d 	bl	fb4c <printk>
		PRINT("\n");
    ce92:	4823      	ldr	r0, [pc, #140]	; (cf20 <spm_config+0x1e4>)
    ce94:	f002 fe5a 	bl	fb4c <printk>
	for (size_t i = 0; i < ARRAY_SIZE(sram_perm); i++) {
    ce98:	2f20      	cmp	r7, #32
    ce9a:	4639      	mov	r1, r7
    ce9c:	d1c3      	bne.n	ce26 <spm_config+0xea>
	PRINT("\n");
    ce9e:	4820      	ldr	r0, [pc, #128]	; (cf20 <spm_config+0x1e4>)
    cea0:	f002 fe54 	bl	fb4c <printk>
	NRF_SPU->DPPI[0].PERM = mask;
    cea4:	f64f 73ff 	movw	r3, #65535	; 0xffff
		NRF_SPU->GPIOPORT[0].PERM = 0;
    cea8:	2400      	movs	r4, #0
	NRF_SPU->DPPI[0].PERM = mask;
    ceaa:	4d1f      	ldr	r5, [pc, #124]	; (cf28 <spm_config+0x1ec>)
	PRINT("Peripheral\t\tDomain\t\tStatus\n");
    ceac:	4823      	ldr	r0, [pc, #140]	; (cf3c <spm_config+0x200>)
	NRF_SPU->DPPI[0].PERM = mask;
    ceae:	f8c5 3480 	str.w	r3, [r5, #1152]	; 0x480
	PRINT("Peripheral\t\tDomain\t\tStatus\n");
    ceb2:	f002 fe4b 	bl	fb4c <printk>
		PRINT("%02u %-21s%s", i, periph[i].name,
    ceb6:	4f22      	ldr	r7, [pc, #136]	; (cf40 <spm_config+0x204>)
		NRF_SPU->GPIOPORT[0].PERM = 0;
    ceb8:	f8c5 44c0 	str.w	r4, [r5, #1216]	; 0x4c0
		PRINT("%02u %-21s%s", i, periph[i].name,
    cebc:	f8df 809c 	ldr.w	r8, [pc, #156]	; cf5c <spm_config+0x220>
    cec0:	4d20      	ldr	r5, [pc, #128]	; (cf44 <spm_config+0x208>)
    cec2:	f8df 909c 	ldr.w	r9, [pc, #156]	; cf60 <spm_config+0x224>
    cec6:	796e      	ldrb	r6, [r5, #5]
    cec8:	682a      	ldr	r2, [r5, #0]
    ceca:	2e00      	cmp	r6, #0
    cecc:	bf14      	ite	ne
    cece:	463b      	movne	r3, r7
    ced0:	4643      	moveq	r3, r8
    ced2:	4621      	mov	r1, r4
    ced4:	4648      	mov	r0, r9
    ced6:	f002 fe39 	bl	fb4c <printk>
		if (!periph[i].nonsecure) {
    ceda:	b966      	cbnz	r6, cef6 <spm_config+0x1ba>
			PRINT("\tSKIP\n");
    cedc:	481a      	ldr	r0, [pc, #104]	; (cf48 <spm_config+0x20c>)
	for (size_t i = 0; i < ARRAY_SIZE(periph); i++) {
    cede:	3401      	adds	r4, #1
			PRINT("\tOK\n");
    cee0:	f002 fe34 	bl	fb4c <printk>
	for (size_t i = 0; i < ARRAY_SIZE(periph); i++) {
    cee4:	2c19      	cmp	r4, #25
    cee6:	f105 0508 	add.w	r5, r5, #8
    ceea:	d1ec      	bne.n	cec6 <spm_config+0x18a>
	PRINT("\n");
    ceec:	480c      	ldr	r0, [pc, #48]	; (cf20 <spm_config+0x1e4>)
	spm_config_flash();
	spm_config_sram();
	spm_config_peripherals();
}
    ceee:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	PRINT("\n");
    cef2:	f002 be2b 	b.w	fb4c <printk>
		err = spm_config_peripheral(periph[i].id, false);
    cef6:	7928      	ldrb	r0, [r5, #4]
    cef8:	f7ff fe86 	bl	cc08 <spm_config_peripheral.constprop.1>
		if (err) {
    cefc:	b108      	cbz	r0, cf02 <spm_config+0x1c6>
			PRINT("\tERROR\n");
    cefe:	4813      	ldr	r0, [pc, #76]	; (cf4c <spm_config+0x210>)
    cf00:	e7ed      	b.n	cede <spm_config+0x1a2>
			PRINT("\tOK\n");
    cf02:	4813      	ldr	r0, [pc, #76]	; (cf50 <spm_config+0x214>)
    cf04:	e7eb      	b.n	cede <spm_config+0x1a2>
    cf06:	bf00      	nop
    cf08:	000108dc 	.word	0x000108dc
    cf0c:	00010564 	.word	0x00010564
    cf10:	00010914 	.word	0x00010914
    cf14:	000108c5 	.word	0x000108c5
    cf18:	000108bc 	.word	0x000108bc
    cf1c:	000109e9 	.word	0x000109e9
    cf20:	00010c0a 	.word	0x00010c0a
    cf24:	00017fe0 	.word	0x00017fe0
    cf28:	50003000 	.word	0x50003000
    cf2c:	00010917 	.word	0x00010917
    cf30:	0001095d 	.word	0x0001095d
    cf34:	0001098d 	.word	0x0001098d
    cf38:	000106ac 	.word	0x000106ac
    cf3c:	000109c3 	.word	0x000109c3
    cf40:	000108d1 	.word	0x000108d1
    cf44:	000105e4 	.word	0x000105e4
    cf48:	000109ec 	.word	0x000109ec
    cf4c:	000109f3 	.word	0x000109f3
    cf50:	000109fb 	.word	0x000109fb
    cf54:	000108ff 	.word	0x000108ff
    cf58:	000109af 	.word	0x000109af
    cf5c:	000108c9 	.word	0x000108c9
    cf60:	000109df 	.word	0x000109df

0000cf64 <__acle_se_spm_request_read>:
	size_t size;
};

__TZ_NONSECURE_ENTRY_FUNC
int spm_request_read(void *destination, u32_t addr, size_t len)
{
    cf64:	b510      	push	{r4, lr}
		 .size = FICR_PUBLIC_SIZE},
		{.start = FICR_RESTRICTED_ADDR,
		 .size = FICR_RESTRICTED_SIZE},
	};

	if (destination == NULL || len <= 0) {
    cf66:	2800      	cmp	r0, #0
    cf68:	d050      	beq.n	d00c <__acle_se_spm_request_read+0xa8>
    cf6a:	2a00      	cmp	r2, #0
    cf6c:	d04e      	beq.n	d00c <__acle_se_spm_request_read+0xa8>

	for (size_t i = 0; i < ARRAY_SIZE(ranges); i++) {
		u32_t start = ranges[i].start;
		u32_t size = ranges[i].size;

		if (addr >= start && addr + len <= start + size) {
    cf6e:	f5b1 4f40 	cmp.w	r1, #49152	; 0xc000
    cf72:	d348      	bcc.n	d006 <__acle_se_spm_request_read+0xa2>
    cf74:	1853      	adds	r3, r2, r1
    cf76:	f5b3 4f42 	cmp.w	r3, #49664	; 0xc200
    cf7a:	d906      	bls.n	cf8a <__acle_se_spm_request_read+0x26>
    cf7c:	4c25      	ldr	r4, [pc, #148]	; (d014 <__acle_se_spm_request_read+0xb0>)
    cf7e:	42a1      	cmp	r1, r4
    cf80:	d93b      	bls.n	cffa <__acle_se_spm_request_read+0x96>
    cf82:	f604 241d 	addw	r4, r4, #2589	; 0xa1d
    cf86:	42a3      	cmp	r3, r4
    cf88:	d83a      	bhi.n	d000 <__acle_se_spm_request_read+0x9c>
			memcpy(destination, (const void *)addr, len);
    cf8a:	f002 ff85 	bl	fe98 <memcpy>
			return 0;
    cf8e:	2000      	movs	r0, #0
		}
	}

	return -EPERM;
}
    cf90:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    cf94:	4671      	mov	r1, lr
    cf96:	4672      	mov	r2, lr
    cf98:	4673      	mov	r3, lr
    cf9a:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
    cf9e:	eef7 0a00 	vmov.f32	s1, #112	; 0x3f800000  1.0
    cfa2:	eeb7 1a00 	vmov.f32	s2, #112	; 0x3f800000  1.0
    cfa6:	eef7 1a00 	vmov.f32	s3, #112	; 0x3f800000  1.0
    cfaa:	eeb7 2a00 	vmov.f32	s4, #112	; 0x3f800000  1.0
    cfae:	eef7 2a00 	vmov.f32	s5, #112	; 0x3f800000  1.0
    cfb2:	eeb7 3a00 	vmov.f32	s6, #112	; 0x3f800000  1.0
    cfb6:	eef7 3a00 	vmov.f32	s7, #112	; 0x3f800000  1.0
    cfba:	eeb7 4a00 	vmov.f32	s8, #112	; 0x3f800000  1.0
    cfbe:	eef7 4a00 	vmov.f32	s9, #112	; 0x3f800000  1.0
    cfc2:	eeb7 5a00 	vmov.f32	s10, #112	; 0x3f800000  1.0
    cfc6:	eef7 5a00 	vmov.f32	s11, #112	; 0x3f800000  1.0
    cfca:	eeb7 6a00 	vmov.f32	s12, #112	; 0x3f800000  1.0
    cfce:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
    cfd2:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
    cfd6:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
    cfda:	f38e 8c00 	msr	CPSR_fs, lr
    cfde:	b410      	push	{r4}
    cfe0:	eef1 ca10 	vmrs	ip, fpscr
    cfe4:	f64f 7460 	movw	r4, #65376	; 0xff60
    cfe8:	f6c0 74ff 	movt	r4, #4095	; 0xfff
    cfec:	ea0c 0c04 	and.w	ip, ip, r4
    cff0:	eee1 ca10 	vmsr	fpscr, ip
    cff4:	bc10      	pop	{r4}
    cff6:	46f4      	mov	ip, lr
    cff8:	4774      	bxns	lr
		if (addr >= start && addr + len <= start + size) {
    cffa:	4c07      	ldr	r4, [pc, #28]	; (d018 <__acle_se_spm_request_read+0xb4>)
    cffc:	42a1      	cmp	r1, r4
    cffe:	d902      	bls.n	d006 <__acle_se_spm_request_read+0xa2>
    d000:	4c06      	ldr	r4, [pc, #24]	; (d01c <__acle_se_spm_request_read+0xb8>)
    d002:	42a3      	cmp	r3, r4
    d004:	d9c1      	bls.n	cf8a <__acle_se_spm_request_read+0x26>
	return -EPERM;
    d006:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    d00a:	e7c1      	b.n	cf90 <__acle_se_spm_request_read+0x2c>
		return -EINVAL;
    d00c:	f06f 0015 	mvn.w	r0, #21
    d010:	e7be      	b.n	cf90 <__acle_se_spm_request_read+0x2c>
    d012:	bf00      	nop
    d014:	00ff0203 	.word	0x00ff0203
    d018:	00ff012f 	.word	0x00ff012f
    d01c:	00ff0138 	.word	0x00ff0138

0000d020 <__acle_se_spm_firmware_info>:
#endif /* CONFIG_SPM_SERVICE_RNG */

#ifdef CONFIG_SPM_SERVICE_FIND_FIRMWARE_INFO
__TZ_NONSECURE_ENTRY_FUNC
int spm_firmware_info(u32_t fw_address, struct fw_info *info)
{
    d020:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    d024:	4686      	mov	lr, r0
    d026:	b085      	sub	sp, #20
	const struct fw_info *tmp_info;

	if (info == NULL) {
    d028:	460f      	mov	r7, r1
    d02a:	2900      	cmp	r1, #0
    d02c:	d06d      	beq.n	d10a <__acle_se_spm_firmware_info+0xea>
/* Search for the firmware_info structure inside the firmware. */
static inline const struct fw_info *fw_info_find(u32_t firmware_address)
{
	const struct fw_info *finfo;

	for (u32_t i = 0; i < FW_INFO_OFFSET_COUNT; i++) {
    d02e:	2500      	movs	r5, #0
		if (expected_32[i] != actual_32[i]) {
    d030:	f645 3a01 	movw	sl, #23297	; 0x5b01
    d034:	f8df c0dc 	ldr.w	ip, [pc, #220]	; d114 <__acle_se_spm_firmware_info+0xf4>
	const u32_t fw_info_magic[] = {FIRMWARE_INFO_MAGIC};
    d038:	4e35      	ldr	r6, [pc, #212]	; (d110 <__acle_se_spm_firmware_info+0xf0>)
		if (expected_32[i] != actual_32[i]) {
    d03a:	f8df 80dc 	ldr.w	r8, [pc, #220]	; d118 <__acle_se_spm_firmware_info+0xf8>
    d03e:	f8df 90dc 	ldr.w	r9, [pc, #220]	; d11c <__acle_se_spm_firmware_info+0xfc>
	const u32_t fw_info_magic[] = {FIRMWARE_INFO_MAGIC};
    d042:	ac01      	add	r4, sp, #4
		finfo = fw_info_check(firmware_address +
						allowed_offsets[i]);
    d044:	f85c bb04 	ldr.w	fp, [ip], #4
	const u32_t fw_info_magic[] = {FIRMWARE_INFO_MAGIC};
    d048:	e896 0007 	ldmia.w	r6, {r0, r1, r2}
		finfo = fw_info_check(firmware_address +
    d04c:	eb0e 030b 	add.w	r3, lr, fp
	const u32_t fw_info_magic[] = {FIRMWARE_INFO_MAGIC};
    d050:	e884 0007 	stmia.w	r4, {r0, r1, r2}
	if (((u32_t)expected % 4) || ((u32_t)actual % 4) || ((u32_t)len % 4)) {
    d054:	079a      	lsls	r2, r3, #30
    d056:	d10f      	bne.n	d078 <__acle_se_spm_firmware_info+0x58>
		if (expected_32[i] != actual_32[i]) {
    d058:	f85e 200b 	ldr.w	r2, [lr, fp]
    d05c:	4542      	cmp	r2, r8
    d05e:	d105      	bne.n	d06c <__acle_se_spm_firmware_info+0x4c>
    d060:	685a      	ldr	r2, [r3, #4]
    d062:	454a      	cmp	r2, r9
    d064:	d102      	bne.n	d06c <__acle_se_spm_firmware_info+0x4c>
    d066:	689a      	ldr	r2, [r3, #8]
    d068:	4552      	cmp	r2, sl
    d06a:	d012      	beq.n	d092 <__acle_se_spm_firmware_info+0x72>
	for (u32_t i = 0; i < FW_INFO_OFFSET_COUNT; i++) {
    d06c:	3501      	adds	r5, #1
    d06e:	2d03      	cmp	r5, #3
    d070:	d1e8      	bne.n	d044 <__acle_se_spm_firmware_info+0x24>
	if (tmp_info != NULL) {
		memcpy(info, tmp_info, sizeof(*tmp_info));
		return 0;
	}

	return -EFAULT;
    d072:	f06f 000d 	mvn.w	r0, #13
    d076:	e012      	b.n	d09e <__acle_se_spm_firmware_info+0x7e>
    d078:	4621      	mov	r1, r4
	if (((u32_t)expected % 4) || ((u32_t)actual % 4) || ((u32_t)len % 4)) {
    d07a:	2200      	movs	r2, #0
		if (expected_8[i] != actual_8[i]) {
    d07c:	f811 0b01 	ldrb.w	r0, [r1], #1
    d080:	f813 b002 	ldrb.w	fp, [r3, r2]
    d084:	4583      	cmp	fp, r0
    d086:	d1f1      	bne.n	d06c <__acle_se_spm_firmware_info+0x4c>
	for (u32_t i = 0; i < len; i++) {
    d088:	3201      	adds	r2, #1
    d08a:	2a0c      	cmp	r2, #12
    d08c:	d1f6      	bne.n	d07c <__acle_se_spm_firmware_info+0x5c>
		if (finfo) {
    d08e:	2b00      	cmp	r3, #0
    d090:	d0ec      	beq.n	d06c <__acle_se_spm_firmware_info+0x4c>
		memcpy(info, tmp_info, sizeof(*tmp_info));
    d092:	2220      	movs	r2, #32
    d094:	4619      	mov	r1, r3
    d096:	4638      	mov	r0, r7
    d098:	f002 fefe 	bl	fe98 <memcpy>
		return 0;
    d09c:	2000      	movs	r0, #0
}
    d09e:	b005      	add	sp, #20
    d0a0:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
    d0a4:	eef7 0a00 	vmov.f32	s1, #112	; 0x3f800000  1.0
    d0a8:	eeb7 1a00 	vmov.f32	s2, #112	; 0x3f800000  1.0
    d0ac:	eef7 1a00 	vmov.f32	s3, #112	; 0x3f800000  1.0
    d0b0:	eeb7 2a00 	vmov.f32	s4, #112	; 0x3f800000  1.0
    d0b4:	eef7 2a00 	vmov.f32	s5, #112	; 0x3f800000  1.0
    d0b8:	eeb7 3a00 	vmov.f32	s6, #112	; 0x3f800000  1.0
    d0bc:	eef7 3a00 	vmov.f32	s7, #112	; 0x3f800000  1.0
    d0c0:	eeb7 4a00 	vmov.f32	s8, #112	; 0x3f800000  1.0
    d0c4:	eef7 4a00 	vmov.f32	s9, #112	; 0x3f800000  1.0
    d0c8:	eeb7 5a00 	vmov.f32	s10, #112	; 0x3f800000  1.0
    d0cc:	eef7 5a00 	vmov.f32	s11, #112	; 0x3f800000  1.0
    d0d0:	eeb7 6a00 	vmov.f32	s12, #112	; 0x3f800000  1.0
    d0d4:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
    d0d8:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
    d0dc:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    d0e0:	4671      	mov	r1, lr
    d0e2:	4672      	mov	r2, lr
    d0e4:	4673      	mov	r3, lr
    d0e6:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
    d0ea:	f38e 8c00 	msr	CPSR_fs, lr
    d0ee:	b410      	push	{r4}
    d0f0:	eef1 ca10 	vmrs	ip, fpscr
    d0f4:	f64f 7460 	movw	r4, #65376	; 0xff60
    d0f8:	f6c0 74ff 	movt	r4, #4095	; 0xfff
    d0fc:	ea0c 0c04 	and.w	ip, ip, r4
    d100:	eee1 ca10 	vmsr	fpscr, ip
    d104:	bc10      	pop	{r4}
    d106:	46f4      	mov	ip, lr
    d108:	4774      	bxns	lr
		return -EINVAL;
    d10a:	f06f 0015 	mvn.w	r0, #21
    d10e:	e7c6      	b.n	d09e <__acle_se_spm_firmware_info+0x7e>
    d110:	00010504 	.word	0x00010504
    d114:	0001072c 	.word	0x0001072c
    d118:	281ee6de 	.word	0x281ee6de
    d11c:	8fcebb4c 	.word	0x8fcebb4c

0000d120 <nrf_cc310_platform_abort_init>:

/** @brief Function to initialize the nrf_cc310_platform abort APIs.
 */
void nrf_cc310_platform_abort_init(void)
{
	nrf_cc310_platform_set_abort(&apis);
    d120:	4801      	ldr	r0, [pc, #4]	; (d128 <nrf_cc310_platform_abort_init+0x8>)
    d122:	f001 be51 	b.w	edc8 <nrf_cc310_platform_set_abort>
    d126:	bf00      	nop
    d128:	00010738 	.word	0x00010738

0000d12c <mutex_unlock>:
}


/** @brief Static function to unlock a mutex
 */
static int32_t mutex_unlock(nrf_cc310_platform_mutex_t *mutex) {
    d12c:	b508      	push	{r3, lr}
    struct k_mutex * p_mutex;

    /* Ensure that the mutex param is valid (not NULL) */
    if(mutex == NULL) {
    d12e:	b130      	cbz	r0, d13e <mutex_unlock+0x12>
        return NRF_CC310_PLATFORM_ERROR_PARAM_NULL;
    }

    /* Ensure that the mutex has been initialized */
    if (mutex->flags == NRF_CC310_PLATFORM_MUTEX_MASK_INVALID) {
    d130:	6843      	ldr	r3, [r0, #4]
    d132:	b13b      	cbz	r3, d144 <mutex_unlock+0x18>
        return NRF_CC310_PLATFORM_ERROR_MUTEX_NOT_INITIALIZED;
    }

    p_mutex = (struct k_mutex *)mutex->mutex;
    d134:	6800      	ldr	r0, [r0, #0]
		z_arch_syscall_invoke1(*(u32_t *)&mutex, K_SYSCALL_K_MUTEX_UNLOCK);
		return;
	}
#endif
	compiler_barrier();
	z_impl_k_mutex_unlock(mutex);
    d136:	f001 f85f 	bl	e1f8 <z_impl_k_mutex_unlock>

    k_mutex_unlock(p_mutex);
    return NRF_CC310_PLATFORM_SUCCESS;
    d13a:	2000      	movs	r0, #0
}
    d13c:	bd08      	pop	{r3, pc}
        return NRF_CC310_PLATFORM_ERROR_PARAM_NULL;
    d13e:	f46f 40e0 	mvn.w	r0, #28672	; 0x7000
    d142:	e7fb      	b.n	d13c <mutex_unlock+0x10>
        return NRF_CC310_PLATFORM_ERROR_MUTEX_NOT_INITIALIZED;
    d144:	4800      	ldr	r0, [pc, #0]	; (d148 <mutex_unlock+0x1c>)
    d146:	e7f9      	b.n	d13c <mutex_unlock+0x10>
    d148:	ffff8fea 	.word	0xffff8fea

0000d14c <mutex_free>:
static void mutex_free(nrf_cc310_platform_mutex_t *mutex) {
    d14c:	b538      	push	{r3, r4, r5, lr}
    if (mutex == NULL) {
    d14e:	4604      	mov	r4, r0
    d150:	b918      	cbnz	r0, d15a <mutex_free+0xe>
        platform_abort_apis.abort_fn(
    d152:	4b0b      	ldr	r3, [pc, #44]	; (d180 <mutex_free+0x34>)
    d154:	480b      	ldr	r0, [pc, #44]	; (d184 <mutex_free+0x38>)
    d156:	685b      	ldr	r3, [r3, #4]
    d158:	4798      	blx	r3
    if (mutex->flags == NRF_CC310_PLATFORM_MUTEX_MASK_INVALID) {
    d15a:	6865      	ldr	r5, [r4, #4]
    d15c:	b155      	cbz	r5, d174 <mutex_free+0x28>
    if ((mutex->flags & NRF_CC310_PLATFORM_MUTEX_MASK_IS_ALLOCATED) == 0) {
    d15e:	f015 0502 	ands.w	r5, r5, #2
    d162:	6820      	ldr	r0, [r4, #0]
    d164:	d107      	bne.n	d176 <mutex_free+0x2a>
        k_mem_slab_free(&mutex_slab, mutex->mutex);
    d166:	4601      	mov	r1, r0
    d168:	4807      	ldr	r0, [pc, #28]	; (d188 <mutex_free+0x3c>)
    d16a:	f000 ffa5 	bl	e0b8 <k_mem_slab_free>
        mutex->mutex = NULL;
    d16e:	6025      	str	r5, [r4, #0]
    mutex->flags = NRF_CC310_PLATFORM_MUTEX_MASK_INVALID;
    d170:	2300      	movs	r3, #0
    d172:	6063      	str	r3, [r4, #4]
}
    d174:	bd38      	pop	{r3, r4, r5, pc}
        memset(mutex->mutex, 0, sizeof(struct k_mutex));
    d176:	2214      	movs	r2, #20
    d178:	2100      	movs	r1, #0
    d17a:	f002 feb7 	bl	feec <memset>
    d17e:	e7f7      	b.n	d170 <mutex_free+0x24>
    d180:	20001428 	.word	0x20001428
    d184:	00010b68 	.word	0x00010b68
    d188:	20000028 	.word	0x20000028

0000d18c <mutex_init>:
static void mutex_init(nrf_cc310_platform_mutex_t *mutex) {
    d18c:	b510      	push	{r4, lr}
    if (mutex == NULL) {
    d18e:	4604      	mov	r4, r0
    d190:	b918      	cbnz	r0, d19a <mutex_init+0xe>
        platform_abort_apis.abort_fn(
    d192:	4b13      	ldr	r3, [pc, #76]	; (d1e0 <mutex_init+0x54>)
    d194:	4813      	ldr	r0, [pc, #76]	; (d1e4 <mutex_init+0x58>)
    d196:	685b      	ldr	r3, [r3, #4]
    d198:	4798      	blx	r3
    if (mutex->flags == NRF_CC310_PLATFORM_MUTEX_MASK_INVALID &&
    d19a:	6863      	ldr	r3, [r4, #4]
    d19c:	b9bb      	cbnz	r3, d1ce <mutex_init+0x42>
    d19e:	6823      	ldr	r3, [r4, #0]
    d1a0:	b9ab      	cbnz	r3, d1ce <mutex_init+0x42>
        ret = k_mem_slab_alloc(&mutex_slab, &mutex->mutex, K_FOREVER);
    d1a2:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    d1a6:	4621      	mov	r1, r4
    d1a8:	480f      	ldr	r0, [pc, #60]	; (d1e8 <mutex_init+0x5c>)
    d1aa:	f000 ff59 	bl	e060 <k_mem_slab_alloc>
        if(ret != 0 || mutex->mutex == NULL)
    d1ae:	b908      	cbnz	r0, d1b4 <mutex_init+0x28>
    d1b0:	6823      	ldr	r3, [r4, #0]
    d1b2:	b91b      	cbnz	r3, d1bc <mutex_init+0x30>
            platform_abort_apis.abort_fn(
    d1b4:	4b0a      	ldr	r3, [pc, #40]	; (d1e0 <mutex_init+0x54>)
    d1b6:	480d      	ldr	r0, [pc, #52]	; (d1ec <mutex_init+0x60>)
    d1b8:	685b      	ldr	r3, [r3, #4]
    d1ba:	4798      	blx	r3
        memset(mutex->mutex, 0, sizeof(struct k_mutex));
    d1bc:	2214      	movs	r2, #20
    d1be:	2100      	movs	r1, #0
    d1c0:	6820      	ldr	r0, [r4, #0]
    d1c2:	f002 fe93 	bl	feec <memset>
        mutex->flags |= NRF_CC310_PLATFORM_MUTEX_MASK_IS_ALLOCATED;
    d1c6:	6863      	ldr	r3, [r4, #4]
    d1c8:	f043 0302 	orr.w	r3, r3, #2
    d1cc:	6063      	str	r3, [r4, #4]
    p_mutex = (struct k_mutex *)mutex->mutex;
    d1ce:	6820      	ldr	r0, [r4, #0]
	z_impl_k_mutex_init(mutex);
    d1d0:	f002 ff28 	bl	10024 <z_impl_k_mutex_init>
    mutex->flags |= NRF_CC310_PLATFORM_MUTEX_MASK_IS_VALID;
    d1d4:	6863      	ldr	r3, [r4, #4]
    d1d6:	f043 0301 	orr.w	r3, r3, #1
    d1da:	6063      	str	r3, [r4, #4]
}
    d1dc:	bd10      	pop	{r4, pc}
    d1de:	bf00      	nop
    d1e0:	20001428 	.word	0x20001428
    d1e4:	00010b68 	.word	0x00010b68
    d1e8:	20000028 	.word	0x20000028
    d1ec:	00010b8e 	.word	0x00010b8e

0000d1f0 <mutex_lock>:
static int32_t mutex_lock(nrf_cc310_platform_mutex_t *mutex) {
    d1f0:	b508      	push	{r3, lr}
    if(mutex == NULL) {
    d1f2:	b158      	cbz	r0, d20c <mutex_lock+0x1c>
    if (mutex->flags == NRF_CC310_PLATFORM_MUTEX_MASK_INVALID) {
    d1f4:	6843      	ldr	r3, [r0, #4]
    d1f6:	b163      	cbz	r3, d212 <mutex_lock+0x22>
    p_mutex = (struct k_mutex *)mutex->mutex;
    d1f8:	6800      	ldr	r0, [r0, #0]
	return z_impl_k_mutex_lock(mutex, timeout);
    d1fa:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    d1fe:	f000 ff89 	bl	e114 <z_impl_k_mutex_lock>
        return NRF_CC310_PLATFORM_ERROR_MUTEX_FAILED;
    d202:	4b05      	ldr	r3, [pc, #20]	; (d218 <mutex_lock+0x28>)
    if (ret == 0) {
    d204:	2800      	cmp	r0, #0
        return NRF_CC310_PLATFORM_ERROR_MUTEX_FAILED;
    d206:	bf18      	it	ne
    d208:	4618      	movne	r0, r3
}
    d20a:	bd08      	pop	{r3, pc}
        return NRF_CC310_PLATFORM_ERROR_PARAM_NULL;
    d20c:	f46f 40e0 	mvn.w	r0, #28672	; 0x7000
    d210:	e7fb      	b.n	d20a <mutex_lock+0x1a>
        return NRF_CC310_PLATFORM_ERROR_MUTEX_NOT_INITIALIZED;
    d212:	4802      	ldr	r0, [pc, #8]	; (d21c <mutex_lock+0x2c>)
    d214:	e7f9      	b.n	d20a <mutex_lock+0x1a>
    d216:	bf00      	nop
    d218:	ffff8fe9 	.word	0xffff8fe9
    d21c:	ffff8fea 	.word	0xffff8fea

0000d220 <nrf_cc310_platform_mutex_init>:
};

/** @brief Function to initialize the nrf_cc310_platform mutex APIs
 */
void nrf_cc310_platform_mutex_init(void)
{
    d220:	b508      	push	{r3, lr}
    k_mem_slab_init(&mutex_slab,
    d222:	4906      	ldr	r1, [pc, #24]	; (d23c <nrf_cc310_platform_mutex_init+0x1c>)
    d224:	2340      	movs	r3, #64	; 0x40
    d226:	4806      	ldr	r0, [pc, #24]	; (d240 <nrf_cc310_platform_mutex_init+0x20>)
    d228:	2214      	movs	r2, #20
    d22a:	f002 fee9 	bl	10000 <k_mem_slab_init>
            mutex_slab_buffer,
            sizeof(struct k_mutex),
            NUM_MUTEXES);

    nrf_cc310_platform_set_mutexes(&mutex_apis, &mutexes);
}
    d22e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    nrf_cc310_platform_set_mutexes(&mutex_apis, &mutexes);
    d232:	4904      	ldr	r1, [pc, #16]	; (d244 <nrf_cc310_platform_mutex_init+0x24>)
    d234:	4804      	ldr	r0, [pc, #16]	; (d248 <nrf_cc310_platform_mutex_init+0x28>)
    d236:	f001 bdff 	b.w	ee38 <nrf_cc310_platform_set_mutexes>
    d23a:	bf00      	nop
    d23c:	20000044 	.word	0x20000044
    d240:	20000028 	.word	0x20000028
    d244:	00010750 	.word	0x00010750
    d248:	00010740 	.word	0x00010740

0000d24c <z_arm_exc_exit>:
    /* r0 contains the caller mode */
    push {r0, lr}
#endif

#ifdef CONFIG_PREEMPT_ENABLED
    ldr r0, =_kernel
    d24c:	4804      	ldr	r0, [pc, #16]	; (d260 <_EXIT_EXC+0x2>)

    ldr r1, [r0, #_kernel_offset_to_current]
    d24e:	6881      	ldr	r1, [r0, #8]

    ldr r0, [r0, #_kernel_offset_to_ready_q_cache]
    d250:	6a40      	ldr	r0, [r0, #36]	; 0x24
    cmp r0, r1
    d252:	4288      	cmp	r0, r1
    beq _EXIT_EXC
    d254:	d003      	beq.n	d25e <_EXIT_EXC>

#if defined(CONFIG_CPU_CORTEX_M)
    /* context switch required, pend the PendSV exception */
    ldr r1, =_SCS_ICSR
    d256:	4903      	ldr	r1, [pc, #12]	; (d264 <_EXIT_EXC+0x6>)
    ldr r2, =_SCS_ICSR_PENDSV
    d258:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    str r2, [r1]
    d25c:	600a      	str	r2, [r1, #0]

0000d25e <_EXIT_EXC>:
    bl z_check_stack_sentinel
#endif /* CONFIG_CPU_CORTEX_M */
#endif /* CONFIG_STACK_SENTINEL */

#if defined(CONFIG_CPU_CORTEX_M)
    bx lr
    d25e:	4770      	bx	lr
    ldr r0, =_kernel
    d260:	20000630 	.word	0x20000630
    ldr r1, =_SCS_ICSR
    d264:	e000ed04 	.word	0xe000ed04

0000d268 <z_arch_swap>:
#ifdef CONFIG_EXECUTION_BENCHMARKING
	read_timer_start_of_swap();
#endif

	/* store off key and return value */
	_current->arch.basepri = key;
    d268:	4a09      	ldr	r2, [pc, #36]	; (d290 <z_arch_swap+0x28>)
	_current->arch.swap_return_value = _k_neg_eagain;
    d26a:	490a      	ldr	r1, [pc, #40]	; (d294 <z_arch_swap+0x2c>)
	_current->arch.basepri = key;
    d26c:	6893      	ldr	r3, [r2, #8]
	_current->arch.swap_return_value = _k_neg_eagain;
    d26e:	6809      	ldr	r1, [r1, #0]
	_current->arch.basepri = key;
    d270:	6658      	str	r0, [r3, #100]	; 0x64
	_current->arch.swap_return_value = _k_neg_eagain;
    d272:	6699      	str	r1, [r3, #104]	; 0x68

#if defined(CONFIG_CPU_CORTEX_M)
	/* set pending bit to make sure we will take a PendSV exception */
	SCB->ICSR |= SCB_ICSR_PENDSVSET_Msk;
    d274:	4908      	ldr	r1, [pc, #32]	; (d298 <z_arch_swap+0x30>)
    d276:	684b      	ldr	r3, [r1, #4]
    d278:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
    d27c:	604b      	str	r3, [r1, #4]
    d27e:	2300      	movs	r3, #0
    d280:	f383 8811 	msr	BASEPRI, r3
    d284:	f3bf 8f6f 	isb	sy
#endif

	/* Context switch is performed here. Returning implies the
	 * thread has been context-switched-in again.
	 */
	return _current->arch.swap_return_value;
    d288:	6893      	ldr	r3, [r2, #8]
}
    d28a:	6e98      	ldr	r0, [r3, #104]	; 0x68
    d28c:	4770      	bx	lr
    d28e:	bf00      	nop
    d290:	20000630 	.word	0x20000630
    d294:	00010794 	.word	0x00010794
    d298:	e000ed00 	.word	0xe000ed00

0000d29c <z_arm_pendsv>:
    pop {r0, lr}
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
#endif /* CONFIG_TRACING */

    /* load _kernel into r1 and current k_thread into r2 */
    ldr r1, =_kernel
    d29c:	4912      	ldr	r1, [pc, #72]	; (d2e8 <z_arm_pendsv+0x4c>)
    ldr r2, [r1, #_kernel_offset_to_current]
    d29e:	688a      	ldr	r2, [r1, #8]

    /* addr of callee-saved regs in thread in r0 */
    ldr r0, =_thread_offset_to_callee_saved
    d2a0:	f04f 0028 	mov.w	r0, #40	; 0x28
    add r0, r2
    d2a4:	4410      	add	r0, r2

    /* save callee-saved + psp in thread */
#if defined(CONFIG_CPU_CORTEX_M)
    mrs ip, PSP
    d2a6:	f3ef 8c09 	mrs	ip, PSP
    mov r6, r11
    mov r7, ip
    /* store r8-12 */
    stmea r0!, {r3-r7}
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    stmia r0, {v1-v8, ip}
    d2aa:	e880 1ff0 	stmia.w	r0, {r4, r5, r6, r7, r8, r9, sl, fp, ip}

    /* Protect the kernel state while we play with the thread lists */
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
    cpsid i
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    movs.n r0, #_EXC_IRQ_DEFAULT_PRIO
    d2ae:	2020      	movs	r0, #32
    msr BASEPRI, r0
    d2b0:	f380 8811 	msr	BASEPRI, r0
    isb /* Make the effect of disabling interrupts be realized immediately */
    d2b4:	f3bf 8f6f 	isb	sy
     * the new thread is context-switched in since all decisions
     * to pend PendSV have been taken with the current kernel
     * state and this is what we're handling currently.
     */
#if defined(CONFIG_CPU_CORTEX_M)
    ldr v4, =_SCS_ICSR
    d2b8:	4f0c      	ldr	r7, [pc, #48]	; (d2ec <z_arm_pendsv+0x50>)
    ldr v3, =_SCS_ICSR_UNPENDSV
    d2ba:	f04f 6600 	mov.w	r6, #134217728	; 0x8000000
#endif

    /* _kernel is still in r1 */

    /* fetch the thread to run from the ready queue cache */
    ldr r2, [r1, #_kernel_offset_to_ready_q_cache]
    d2be:	6a4a      	ldr	r2, [r1, #36]	; 0x24

    str r2, [r1, #_kernel_offset_to_current]
    d2c0:	608a      	str	r2, [r1, #8]
     * has been handled.
     */

    /* _SCS_ICSR is still in v4 and _SCS_ICSR_UNPENDSV in v3 */
#if defined(CONFIG_CPU_CORTEX_M)
    str v3, [v4, #0]
    d2c2:	603e      	str	r6, [r7, #0]

    ldr r0, [r4]
    movs.n r3, #0
    str r3, [r4]
#else
    ldr r0, [r2, #_thread_offset_to_basepri]
    d2c4:	6e50      	ldr	r0, [r2, #100]	; 0x64
    movs r3, #0
    d2c6:	2300      	movs	r3, #0
    str r3, [r2, #_thread_offset_to_basepri]
    d2c8:	6653      	str	r3, [r2, #100]	; 0x64
    /* restore r4-r7, go back 9*4 bytes to the start of the stored block */
    subs r0, #36
    ldmia r0!, {r4-r7}
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    /* restore BASEPRI for the incoming thread */
    msr BASEPRI, r0
    d2ca:	f380 8811 	msr	BASEPRI, r0
    isb
#endif

#if defined (CONFIG_ARM_MPU)
    /* Re-program dynamic memory map */
    push {r2,lr}
    d2ce:	b504      	push	{r2, lr}
    mov r0, r2 /* _current thread */
    d2d0:	4610      	mov	r0, r2
    bl z_arm_configure_dynamic_mpu_regions
    d2d2:	f002 fd94 	bl	fdfe <z_arm_configure_dynamic_mpu_regions>
    pop {r2,lr}
    d2d6:	e8bd 4004 	ldmia.w	sp!, {r2, lr}
    isb

#endif

    /* load callee-saved + psp from thread */
    add r0, r2, #_thread_offset_to_callee_saved
    d2da:	f102 0028 	add.w	r0, r2, #40	; 0x28
    ldmia r0, {v1-v8, ip}
    d2de:	e890 1ff0 	ldmia.w	r0, {r4, r5, r6, r7, r8, r9, sl, fp, ip}
    mov r0, #0
    msr PSPLIM, r0
#endif /* CONFIG_BUILTIN_STACK_GUARD */

#if defined(CONFIG_CPU_CORTEX_M)
    msr PSP, ip
    d2e2:	f38c 8809 	msr	PSP, ip

    /*
     * Cortex-M: return from PendSV exception
     * Cortex-R: return to the caller (_IntExit or z_arm_svc)
     */
    bx lr
    d2e6:	4770      	bx	lr
    ldr r1, =_kernel
    d2e8:	20000630 	.word	0x20000630
    ldr v4, =_SCS_ICSR
    d2ec:	e000ed04 	.word	0xe000ed04

0000d2f0 <z_arm_svc>:
 */
SECTION_FUNC(TEXT, z_arm_svc)
  /* Use EXC_RETURN state to find out if stack frame is on the
   * MSP or PSP
   */
    tst lr, #0x4    /* did we come from thread mode ? */
    d2f0:	f01e 0f04 	tst.w	lr, #4
    ite eq  /* if zero (equal), came from handler mode */
    d2f4:	bf0c      	ite	eq
        mrseq r0, MSP   /* handler mode, stack frame is on MSP */
    d2f6:	f3ef 8008 	mrseq	r0, MSP
        mrsne r0, PSP   /* thread mode, stack frame is on PSP */
    d2fa:	f3ef 8009 	mrsne	r0, PSP


    /* Figure out what SVC call number was invoked */

    ldr r1, [r0, #24]   /* grab address of PC from stack frame */
    d2fe:	6981      	ldr	r1, [r0, #24]
    /* SVC is a two-byte instruction, point to it and read the
     * SVC number (lower byte of SCV instruction)
     */
    ldrb r1, [r1, #-2]
    d300:	f811 1c02 	ldrb.w	r1, [r1, #-2]
    tst r2, #0x1
    bne _oops

#endif /* CONFIG_USERSPACE */

    cmp r1, #2
    d304:	2902      	cmp	r1, #2
    beq _oops
    d306:	d0ff      	beq.n	d308 <_oops>

0000d308 <_oops>:
    /* exception return is done in z_arm_int_exit() */
    b z_arm_int_exit
#endif

_oops:
    push {r0, lr}
    d308:	b501      	push	{r0, lr}
    bl z_do_kernel_oops
    d30a:	f002 fd6d 	bl	fde8 <z_do_kernel_oops>
    pop {r0, pc}
    d30e:	bd01      	pop	{r0, pc}

0000d310 <z_arch_irq_enable>:
#define REG_FROM_IRQ(irq) (irq / NUM_IRQS_PER_REG)
#define BIT_FROM_IRQ(irq) (irq % NUM_IRQS_PER_REG)

void z_arch_irq_enable(unsigned int irq)
{
	NVIC_EnableIRQ((IRQn_Type)irq);
    d310:	b243      	sxtb	r3, r0
  if ((int32_t)(IRQn) >= 0)
    d312:	2b00      	cmp	r3, #0
    d314:	db08      	blt.n	d328 <z_arch_irq_enable+0x18>
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    d316:	2201      	movs	r2, #1
    d318:	f000 001f 	and.w	r0, r0, #31
    d31c:	fa02 f000 	lsl.w	r0, r2, r0
    d320:	4a02      	ldr	r2, [pc, #8]	; (d32c <z_arch_irq_enable+0x1c>)
    d322:	095b      	lsrs	r3, r3, #5
    d324:	f842 0023 	str.w	r0, [r2, r3, lsl #2]
}
    d328:	4770      	bx	lr
    d32a:	bf00      	nop
    d32c:	e000e100 	.word	0xe000e100

0000d330 <z_arm_irq_priority_set>:
	 */
	__ASSERT(prio <= (BIT(DT_NUM_IRQ_PRIO_BITS) - 1),
		 "invalid priority %d! values must be less than %lu\n",
		 prio - _IRQ_PRIO_OFFSET,
		 BIT(DT_NUM_IRQ_PRIO_BITS) - (_IRQ_PRIO_OFFSET));
	NVIC_SetPriority((IRQn_Type)irq, prio);
    d330:	b243      	sxtb	r3, r0
  if ((int32_t)(IRQn) >= 0)
    d332:	2b00      	cmp	r3, #0
	prio += _IRQ_PRIO_OFFSET;
    d334:	f101 0101 	add.w	r1, r1, #1
    NVIC->IPR[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
    d338:	bfa8      	it	ge
    d33a:	f103 4360 	addge.w	r3, r3, #3758096384	; 0xe0000000
    d33e:	ea4f 1141 	mov.w	r1, r1, lsl #5
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
    d342:	bfb8      	it	lt
    d344:	4b05      	ldrlt	r3, [pc, #20]	; (d35c <z_arm_irq_priority_set+0x2c>)
    d346:	b2c9      	uxtb	r1, r1
    NVIC->IPR[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
    d348:	bfab      	itete	ge
    d34a:	f503 4361 	addge.w	r3, r3, #57600	; 0xe100
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
    d34e:	f000 000f 	andlt.w	r0, r0, #15
    NVIC->IPR[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
    d352:	f883 1300 	strbge.w	r1, [r3, #768]	; 0x300
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
    d356:	5419      	strblt	r1, [r3, r0]
}
    d358:	4770      	bx	lr
    d35a:	bf00      	nop
    d35c:	e000ed14 	.word	0xe000ed14

0000d360 <z_arch_new_thread>:
 */
void z_arch_new_thread(struct k_thread *thread, k_thread_stack_t *stack,
		       size_t stackSize, k_thread_entry_t pEntry,
		       void *parameter1, void *parameter2, void *parameter3,
		       int priority, unsigned int options)
{
    d360:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
			- MPU_GUARD_ALIGN_AND_SIZE;
		stackSize -= MPU_GUARD_ALIGN_AND_SIZE_FLOAT
			- MPU_GUARD_ALIGN_AND_SIZE;
	}
#endif
	stackEnd = pStackMem + stackSize;
    d364:	188c      	adds	r4, r1, r2
{
    d366:	4688      	mov	r8, r1
    d368:	4617      	mov	r7, r2
    d36a:	461e      	mov	r6, r3
	 * if it isn't.
	 */
	*((u32_t *)pStack) = STACK_SENTINEL;
#endif /* CONFIG_STACK_SENTINEL */
	/* Initialize various struct k_thread members */
	z_init_thread_base(&thread->base, prio, _THREAD_PRESTART, options);
    d36c:	2204      	movs	r2, #4
    d36e:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    d370:	9909      	ldr	r1, [sp, #36]	; 0x24
    d372:	4605      	mov	r5, r0
    d374:	f002 ff33 	bl	101de <z_init_thread_base>

	/* static threads overwrite it afterwards with real value */
	thread->init_data = NULL;
    d378:	2200      	movs	r2, #0
	pInitCtx->basic.pc = (u32_t)z_thread_entry;
#endif

#if defined(CONFIG_CPU_CORTEX_M)
	/* force ARM mode by clearing LSB of address */
	pInitCtx->basic.pc &= 0xfffffffe;
    d37a:	490d      	ldr	r1, [pc, #52]	; (d3b0 <z_arch_new_thread+0x50>)
	pInitCtx = (struct __esf *)(STACK_ROUND_DOWN(stackEnd -
    d37c:	f1a4 0320 	sub.w	r3, r4, #32
    d380:	f023 0307 	bic.w	r3, r3, #7
	pInitCtx->basic.pc &= 0xfffffffe;
    d384:	f021 0101 	bic.w	r1, r1, #1
	thread->fn_abort = NULL;
    d388:	e9c5 2213 	strd	r2, r2, [r5, #76]	; 0x4c
	thread->mem_domain_info.mem_domain = NULL;
#endif /* CONFIG_USERSPACE */

#if defined(CONFIG_THREAD_STACK_INFO)
	thread->stack_info.start = (uintptr_t)pStack;
	thread->stack_info.size = (u32_t)stackSize;
    d38c:	e9c5 8716 	strd	r8, r7, [r5, #88]	; 0x58
    d390:	6199      	str	r1, [r3, #24]
#endif

	pInitCtx->basic.a1 = (u32_t)pEntry;
	pInitCtx->basic.a2 = (u32_t)parameter1;
    d392:	9906      	ldr	r1, [sp, #24]
	pInitCtx->basic.a1 = (u32_t)pEntry;
    d394:	601e      	str	r6, [r3, #0]
	pInitCtx->basic.a2 = (u32_t)parameter1;
    d396:	6059      	str	r1, [r3, #4]
	pInitCtx->basic.a3 = (u32_t)parameter2;
    d398:	9907      	ldr	r1, [sp, #28]
    d39a:	6099      	str	r1, [r3, #8]
	pInitCtx->basic.a4 = (u32_t)parameter3;
    d39c:	9908      	ldr	r1, [sp, #32]
    d39e:	60d9      	str	r1, [r3, #12]
	pInitCtx->basic.xpsr =
    d3a0:	f04f 7180 	mov.w	r1, #16777216	; 0x1000000
    d3a4:	61d9      	str	r1, [r3, #28]
		0x01000000UL; /* clear all, thumb bit is 1, even if RO */

	thread->callee_saved.psp = (u32_t)pInitCtx;
    d3a6:	64ab      	str	r3, [r5, #72]	; 0x48
#if defined(CONFIG_CPU_CORTEX_R)
	pInitCtx->basic.lr = (u32_t)pInitCtx->basic.pc;
	thread->callee_saved.spsr = A_BIT | T_BIT | MODE_SYS;
	thread->callee_saved.lr = (u32_t)pInitCtx->basic.pc;
#endif
	thread->arch.basepri = 0;
    d3a8:	666a      	str	r2, [r5, #100]	; 0x64

	/*
	 * initial values in all other registers/thread entries are
	 * irrelevant.
	 */
}
    d3aa:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    d3ae:	bf00      	nop
    d3b0:	0000f839 	.word	0x0000f839

0000d3b4 <z_arch_switch_to_main_thread>:

void z_arch_switch_to_main_thread(struct k_thread *main_thread,
				  k_thread_stack_t *main_stack,
				  size_t main_stack_size,
				  k_thread_entry_t _main)
{
    d3b4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    d3b6:	461e      	mov	r6, r3
    d3b8:	4605      	mov	r5, r0
    d3ba:	460c      	mov	r4, r1
    d3bc:	4617      	mov	r7, r2
  __ASM volatile ("VMSR fpscr, %0" : : "r" (fpscr) : "vfpcc", "memory");
    d3be:	2300      	movs	r3, #0
    d3c0:	eee1 3a10 	vmsr	fpscr, r3
	 * to set up access permissions for fixed memory sections, such
	 * as Application Memory or No-Cacheable SRAM area.
	 *
	 * This function is invoked once, upon system initialization.
	 */
	z_arm_configure_static_mpu_regions();
    d3c4:	f000 f9b0 	bl	d728 <z_arm_configure_static_mpu_regions>
	start_of_main_stack =
		Z_THREAD_STACK_BUFFER(main_stack) + main_stack_size;

	start_of_main_stack = (char *)STACK_ROUND_DOWN(start_of_main_stack);

	_current = main_thread;
    d3c8:	4b0b      	ldr	r3, [pc, #44]	; (d3f8 <z_arch_switch_to_main_thread+0x44>)
	start_of_main_stack =
    d3ca:	443c      	add	r4, r7
#ifdef CONFIG_ARM_MPU
	/*
	 * If stack protection is enabled, make sure to set it
	 * before jumping to thread entry function
	 */
	z_arm_configure_dynamic_mpu_regions(main_thread);
    d3cc:	4628      	mov	r0, r5
	_current = main_thread;
    d3ce:	609d      	str	r5, [r3, #8]
	start_of_main_stack = (char *)STACK_ROUND_DOWN(start_of_main_stack);
    d3d0:	f024 0407 	bic.w	r4, r4, #7
	z_arm_configure_dynamic_mpu_regions(main_thread);
    d3d4:	f002 fd13 	bl	fdfe <z_arm_configure_dynamic_mpu_regions>

	/*
	 * Set PSP to the highest address of the main stack
	 * before enabling interrupts and jumping to main.
	 */
	__asm__ volatile (
    d3d8:	4630      	mov	r0, r6
    d3da:	f384 8809 	msr	PSP, r4
    d3de:	b663      	cpsie	if
    d3e0:	f04f 0100 	mov.w	r1, #0
    d3e4:	f381 8811 	msr	BASEPRI, r1
    d3e8:	f3bf 8f6f 	isb	sy
    d3ec:	2100      	movs	r1, #0
    d3ee:	2200      	movs	r2, #0
    d3f0:	2300      	movs	r3, #0
    d3f2:	f002 fa21 	bl	f838 <z_thread_entry>
	"bl z_thread_entry\n\t"	/* z_thread_entry(_main, 0, 0, 0); */
	:
	: "r" (_main), "r" (start_of_main_stack)
	);

	CODE_UNREACHABLE;
    d3f6:	bf00      	nop
    d3f8:	20000630 	.word	0x20000630

0000d3fc <z_arm_cpu_idle_init>:
 * void z_arm_cpu_idle_init(void);
 */

SECTION_FUNC(TEXT, z_arm_cpu_idle_init)
#if defined(CONFIG_CPU_CORTEX_M)
	ldr r1, =_SCB_SCR
    d3fc:	4901      	ldr	r1, [pc, #4]	; (d404 <z_arm_cpu_idle_init+0x8>)
	movs.n r2, #_SCR_INIT_BITS
    d3fe:	2210      	movs	r2, #16
	str r2, [r1]
    d400:	600a      	str	r2, [r1, #0]
#endif
	bx lr
    d402:	4770      	bx	lr
	ldr r1, =_SCB_SCR
    d404:	e000ed10 	.word	0xe000ed10

0000d408 <z_arch_cpu_idle>:
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE) \
	|| defined(CONFIG_ARMV7_R)
	cpsie i
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	/* clear BASEPRI so wfi is awakened by incoming interrupts */
	eors.n r0, r0
    d408:	4040      	eors	r0, r0
	msr BASEPRI, r0
    d40a:	f380 8811 	msr	BASEPRI, r0
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

	wfi
    d40e:	bf30      	wfi

	bx lr
    d410:	4770      	bx	lr
    d412:	bf00      	nop

0000d414 <z_arm_bus_fault>:
	mrs r0, MSP
_stack_frame_endif:

#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	/* force unlock interrupts */
	eors.n r0, r0
    d414:	4040      	eors	r0, r0
	msr BASEPRI, r0
    d416:	f380 8811 	msr	BASEPRI, r0
	/* RETTOBASE flag is not banked between security states.
	 * Therefore, we cannot rely on this flag, to obtain the SP
	 * of the current security state.
	 * Instead, we use the EXC_RETURN.SPSEL flag.
	 */
 	ldr r0, =0x4
    d41a:	f04f 0004 	mov.w	r0, #4
	mov r1, lr
    d41e:	4671      	mov	r1, lr
	tst r1, r0
    d420:	4201      	tst	r1, r0
	beq _s_stack_frame_msp
    d422:	d002      	beq.n	d42a <_s_stack_frame_msp>
	mrs r0, PSP
    d424:	f3ef 8009 	mrs	r0, PSP
	bne _s_stack_frame_endif
    d428:	d101      	bne.n	d42e <_s_stack_frame_endif>

0000d42a <_s_stack_frame_msp>:
_s_stack_frame_msp:
	mrs r0, MSP
    d42a:	f3ef 8008 	mrs	r0, MSP

0000d42e <_s_stack_frame_endif>:
	 *
	 * To determine this we need to inspect the EXC_RETURN value
	 * located in the LR. Therefore, we supply the LR value as an
	 * argument to the fault handler.
	 */
	mov r1, lr
    d42e:	4671      	mov	r1, lr
#endif /* CONFIG_ARM_SECURE_FIRMWARE || CONFIG_ARM_NONSECURE_FIRMWARE */
	push {r0, lr}
    d430:	b501      	push	{r0, lr}
	bl z_arm_fault
    d432:	f000 f8d1 	bl	d5d8 <z_arm_fault>

#if defined(CONFIG_CPU_CORTEX_M)
	pop {r0, pc}
    d436:	bd01      	pop	{r0, pc}

0000d438 <z_SysNmiOnReset>:
_ASM_FILE_PROLOGUE

GTEXT(z_SysNmiOnReset)

SECTION_FUNC(TEXT, z_SysNmiOnReset)
    wfi
    d438:	bf30      	wfi
    b z_SysNmiOnReset
    d43a:	f7ff bffd 	b.w	d438 <z_SysNmiOnReset>
    d43e:	bf00      	nop

0000d440 <z_arm_prep_c>:
#else
#define VECTOR_ADDRESS CONFIG_SRAM_BASE_ADDRESS
#endif
static inline void relocate_vector_table(void)
{
	SCB->VTOR = VECTOR_ADDRESS & SCB_VTOR_TBLOFF_Msk;
    d440:	4a11      	ldr	r2, [pc, #68]	; (d488 <z_arm_prep_c+0x48>)
 * This routine prepares for the execution of and runs C code.
 *
 * @return N/A
 */
void z_arm_prep_c(void)
{
    d442:	b508      	push	{r3, lr}
	SCB->VTOR = VECTOR_ADDRESS & SCB_VTOR_TBLOFF_Msk;
    d444:	4b11      	ldr	r3, [pc, #68]	; (d48c <z_arm_prep_c+0x4c>)
    d446:	f022 027f 	bic.w	r2, r2, #127	; 0x7f
    d44a:	609a      	str	r2, [r3, #8]
  __ASM volatile ("dsb 0xF":::"memory");
    d44c:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    d450:	f3bf 8f6f 	isb	sy
	SCB->CPACR |= CPACR_CP10_PRIV_ACCESS | CPACR_CP11_PRIV_ACCESS;
    d454:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
    d458:	f442 02a0 	orr.w	r2, r2, #5242880	; 0x500000
    d45c:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
	FPU->FPCCR &= (~(FPU_FPCCR_ASPEN_Msk | FPU_FPCCR_LSPEN_Msk));
    d460:	4a0b      	ldr	r2, [pc, #44]	; (d490 <z_arm_prep_c+0x50>)
    d462:	6853      	ldr	r3, [r2, #4]
    d464:	f023 4340 	bic.w	r3, r3, #3221225472	; 0xc0000000
    d468:	6053      	str	r3, [r2, #4]
  __ASM volatile ("dsb 0xF":::"memory");
    d46a:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    d46e:	f3bf 8f6f 	isb	sy
  __ASM volatile ("VMSR fpscr, %0" : : "r" (fpscr) : "vfpcc", "memory");
    d472:	2300      	movs	r3, #0
    d474:	eee1 3a10 	vmsr	fpscr, r3
	relocate_vector_table();
	enable_floating_point();
	z_bss_zero();
    d478:	f000 fd12 	bl	dea0 <z_bss_zero>
	z_data_copy();
    d47c:	f000 fd1a 	bl	deb4 <z_data_copy>
#if defined(CONFIG_ARMV7_R) && defined(CONFIG_INIT_STACKS)
	z_arm_init_stacks();
#endif
	z_arm_int_lib_init();
    d480:	f000 f920 	bl	d6c4 <z_arm_int_lib_init>
	z_cstart();
    d484:	f000 fd48 	bl	df18 <z_cstart>
    d488:	0000c200 	.word	0x0000c200
    d48c:	e000ed00 	.word	0xe000ed00
    d490:	e000ef30 	.word	0xe000ef30

0000d494 <_isr_wrapper>:
 * @return N/A
 */
SECTION_FUNC(TEXT, _isr_wrapper)

#if defined(CONFIG_CPU_CORTEX_M)
	push {r0,lr}		/* r0, lr are now the first items on the stack */
    d494:	b501      	push	{r0, lr}
	 * device for the next timer deadline is not interrupted.  For
	 * non-tickless idle, this ensures that the clearing of the kernel idle
	 * state is not interrupted.  In each case, z_sys_power_save_idle_exit
	 * is called with interrupts disabled.
	 */
	cpsid i  /* PRIMASK = 1 */
    d496:	b672      	cpsid	i

	/* is this a wakeup from idle ? */
	ldr r2, =_kernel
    d498:	4a0b      	ldr	r2, [pc, #44]	; (d4c8 <_isr_wrapper+0x34>)
	/* requested idle duration, in ticks */
	ldr r0, [r2, #_kernel_offset_to_idle]
    d49a:	6a10      	ldr	r0, [r2, #32]
	cmp r0, #0
    d49c:	2800      	cmp	r0, #0
	str r1, [r2, #_kernel_offset_to_idle]
	bl z_sys_power_save_idle_exit
_idle_state_cleared:

#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	ittt ne
    d49e:	bf1e      	ittt	ne
	movne	r1, #0
    d4a0:	2100      	movne	r1, #0
		/* clear kernel idle state */
		strne	r1, [r2, #_kernel_offset_to_idle]
    d4a2:	6211      	strne	r1, [r2, #32]
		blne	z_sys_power_save_idle_exit
    d4a4:	f002 fdaa 	blne	fffc <z_sys_power_save_idle_exit>
_idle_state_cleared:
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

	cpsie i		/* re-enable interrupts (PRIMASK = 0) */
    d4a8:	b662      	cpsie	i
#endif

#if defined(CONFIG_CPU_CORTEX_M)
	mrs r0, IPSR	/* get exception number */
    d4aa:	f3ef 8005 	mrs	r0, IPSR
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
	ldr r1, =16
	subs r0, r1	/* get IRQ number */
	lsls r0, #3	/* table is 8-byte wide */
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	sub r0, r0, #16	/* get IRQ number */
    d4ae:	f1a0 0010 	sub.w	r0, r0, #16
	lsl r0, r0, #3	/* table is 8-byte wide */
    d4b2:	ea4f 00c0 	mov.w	r0, r0, lsl #3
	 */
	mov r0, #0
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
	ldr r1, =_sw_isr_table
    d4b6:	4905      	ldr	r1, [pc, #20]	; (d4cc <_isr_wrapper+0x38>)
	add r1, r1, r0	/* table entry: ISRs must have their MSB set to stay
    d4b8:	4401      	add	r1, r0
			 * in thumb mode */

	ldm r1!,{r0,r3}	/* arg in r0, ISR in r3 */
    d4ba:	c909      	ldmia	r1!, {r0, r3}
#else
	pop {r0, lr}
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
	ldm sp!,{r0-r3} /* Restore r0 to r3 regs */
#endif /* CONFIG_EXECUTION_BENCHMARKING */
	blx r3		/* call ISR */
    d4bc:	4798      	blx	r3

#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
	pop {r0, r3}
	mov lr, r3
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	pop {r0, lr}
    d4be:	e8bd 4001 	ldmia.w	sp!, {r0, lr}
#endif

	/* Use 'bx' instead of 'b' because 'bx' can jump further, and use
	 * 'bx' instead of 'blx' because exception return is done in
	 * z_arm_int_exit() */
	ldr r1, =z_arm_int_exit
    d4c2:	4903      	ldr	r1, [pc, #12]	; (d4d0 <_isr_wrapper+0x3c>)
	bx r1
    d4c4:	4708      	bx	r1
    d4c6:	0000      	.short	0x0000
	ldr r2, =_kernel
    d4c8:	20000630 	.word	0x20000630
	ldr r1, =_sw_isr_table
    d4cc:	00010278 	.word	0x00010278
	ldr r1, =z_arm_int_exit
    d4d0:	0000d24d 	.word	0x0000d24d

0000d4d4 <__start>:
 * search for a __start symbol instead, so create that alias here.
 */
SECTION_SUBSEC_FUNC(TEXT,_reset_section,__start)

#if defined(CONFIG_PLATFORM_SPECIFIC_INIT)
    bl z_platform_init
    d4d4:	f002 fb48 	bl	fb68 <z_platform_init>

    /* lock interrupts: will get unlocked when switch to main task */
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
    cpsid i
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    movs.n r0, #_EXC_IRQ_DEFAULT_PRIO
    d4d8:	2020      	movs	r0, #32
    msr BASEPRI, r0
    d4da:	f380 8811 	msr	BASEPRI, r0

    /*
     * Set PSP and use it to boot without using MSP, so that it
     * gets set to _interrupt_stack during initialization.
     */
    ldr r0, =_interrupt_stack
    d4de:	4808      	ldr	r0, [pc, #32]	; (d500 <__start+0x2c>)
    ldr r1, =CONFIG_ISR_STACK_SIZE
    d4e0:	f44f 6100 	mov.w	r1, #2048	; 0x800
    adds r0, r0, r1
    d4e4:	1840      	adds	r0, r0, r1
    msr PSP, r0
    d4e6:	f380 8809 	msr	PSP, r0
    mrs r0, CONTROL
    d4ea:	f3ef 8014 	mrs	r0, CONTROL
    movs r1, #2
    d4ee:	2102      	movs	r1, #2
    orrs r0, r1 /* CONTROL_SPSEL_Msk */
    d4f0:	4308      	orrs	r0, r1
    msr CONTROL, r0
    d4f2:	f380 8814 	msr	CONTROL, r0
    /*
     * When changing the stack pointer, software must use an ISB instruction
     * immediately after the MSR instruction. This ensures that instructions
     * after the ISB instruction execute using the new stack pointer.
     */
    isb
    d4f6:	f3bf 8f6f 	isb	sy
    /*
     * 'bl' jumps the furthest of the branch instructions that are
     * supported on all platforms. So it is used when jumping to z_arm_prep_c
     * (even though we do not intend to return).
     */
    bl z_arm_prep_c
    d4fa:	f7ff ffa1 	bl	d440 <z_arm_prep_c>
    d4fe:	0000      	.short	0x0000
    ldr r0, =_interrupt_stack
    d500:	20000bd0 	.word	0x20000bd0

0000d504 <mem_manage_fault.isra.2>:
	u32_t reason = K_ERR_CPU_EXCEPTION;
	u32_t mmfar = -EINVAL;

	PR_FAULT_INFO("***** MPU FAULT *****");

	if ((SCB->CFSR & SCB_CFSR_MSTKERR_Msk) != 0) {
    d504:	4b0c      	ldr	r3, [pc, #48]	; (d538 <mem_manage_fault.isra.2+0x34>)
    d506:	6a9a      	ldr	r2, [r3, #40]	; 0x28
		PR_FAULT_INFO("  Stacking error (context area might be"
			" not valid)");
	}
	if ((SCB->CFSR & SCB_CFSR_MUNSTKERR_Msk) != 0) {
    d508:	6a9a      	ldr	r2, [r3, #40]	; 0x28
		PR_FAULT_INFO("  Unstacking error");
	}
	if ((SCB->CFSR & SCB_CFSR_DACCVIOL_Msk) != 0) {
    d50a:	6a9a      	ldr	r2, [r3, #40]	; 0x28
    d50c:	0792      	lsls	r2, r2, #30
    d50e:	d508      	bpl.n	d522 <mem_manage_fault.isra.2+0x1e>
		 * The MMFAR address is valid only if this bit is 1.
		 *
		 * Software must follow this sequence because another higher
		 * priority exception might change the MMFAR value.
		 */
		mmfar = SCB->MMFAR;
    d510:	6b5a      	ldr	r2, [r3, #52]	; 0x34

		if ((SCB->CFSR & SCB_CFSR_MMARVALID_Msk) != 0) {
    d512:	6a9a      	ldr	r2, [r3, #40]	; 0x28
    d514:	0612      	lsls	r2, r2, #24
    d516:	d504      	bpl.n	d522 <mem_manage_fault.isra.2+0x1e>
			PR_EXC("  MMFAR Address: 0x%x", mmfar);
			if (from_hard_fault) {
    d518:	b118      	cbz	r0, d522 <mem_manage_fault.isra.2+0x1e>
				/* clear SCB_MMAR[VALID] to reset */
				SCB->CFSR &= ~SCB_CFSR_MMARVALID_Msk;
    d51a:	6a9a      	ldr	r2, [r3, #40]	; 0x28
    d51c:	f022 0280 	bic.w	r2, r2, #128	; 0x80
    d520:	629a      	str	r2, [r3, #40]	; 0x28

	/* clear MMFSR sticky bits */
	SCB->CFSR |= SCB_CFSR_MEMFAULTSR_Msk;

	/* Assess whether system shall ignore/recover from this MPU fault. */
	*recoverable = memory_fault_recoverable(esf);
    d522:	2000      	movs	r0, #0
	if ((SCB->CFSR & SCB_CFSR_IACCVIOL_Msk) != 0) {
    d524:	4b04      	ldr	r3, [pc, #16]	; (d538 <mem_manage_fault.isra.2+0x34>)
    d526:	6a9a      	ldr	r2, [r3, #40]	; 0x28
	if ((SCB->CFSR & SCB_CFSR_MLSPERR_Msk) != 0) {
    d528:	6a9a      	ldr	r2, [r3, #40]	; 0x28
	if (SCB->CFSR & SCB_CFSR_MSTKERR_Msk) {
    d52a:	6a9a      	ldr	r2, [r3, #40]	; 0x28
	SCB->CFSR |= SCB_CFSR_MEMFAULTSR_Msk;
    d52c:	6a9a      	ldr	r2, [r3, #40]	; 0x28
    d52e:	f042 02ff 	orr.w	r2, r2, #255	; 0xff
    d532:	629a      	str	r2, [r3, #40]	; 0x28
	*recoverable = memory_fault_recoverable(esf);
    d534:	7008      	strb	r0, [r1, #0]

	return reason;
}
    d536:	4770      	bx	lr
    d538:	e000ed00 	.word	0xe000ed00

0000d53c <bus_fault.isra.3>:
{
	u32_t reason = K_ERR_CPU_EXCEPTION;

	PR_FAULT_INFO("***** BUS FAULT *****");

	if (SCB->CFSR & SCB_CFSR_STKERR_Msk) {
    d53c:	4b0d      	ldr	r3, [pc, #52]	; (d574 <bus_fault.isra.3+0x38>)
    d53e:	6a9a      	ldr	r2, [r3, #40]	; 0x28
		PR_FAULT_INFO("  Stacking error");
	}
	if (SCB->CFSR & SCB_CFSR_UNSTKERR_Msk) {
    d540:	6a9a      	ldr	r2, [r3, #40]	; 0x28
		PR_FAULT_INFO("  Unstacking error");
	}
	if (SCB->CFSR & SCB_CFSR_PRECISERR_Msk) {
    d542:	6a9a      	ldr	r2, [r3, #40]	; 0x28
    d544:	0592      	lsls	r2, r2, #22
    d546:	d508      	bpl.n	d55a <bus_fault.isra.3+0x1e>
		 * The BFAR address is valid only if this bit is 1.
		 *
		 * Software must follow this sequence because another
		 * higher priority exception might change the BFAR value.
		 */
		STORE_xFAR(bfar, SCB->BFAR);
    d548:	6b9a      	ldr	r2, [r3, #56]	; 0x38

		if ((SCB->CFSR & SCB_CFSR_BFARVALID_Msk) != 0) {
    d54a:	6a9a      	ldr	r2, [r3, #40]	; 0x28
    d54c:	0412      	lsls	r2, r2, #16
    d54e:	d504      	bpl.n	d55a <bus_fault.isra.3+0x1e>
			PR_EXC("  BFAR Address: 0x%x", bfar);
			if (from_hard_fault) {
    d550:	b118      	cbz	r0, d55a <bus_fault.isra.3+0x1e>
				/* clear SCB_CFSR_BFAR[VALID] to reset */
				SCB->CFSR &= ~SCB_CFSR_BFARVALID_Msk;
    d552:	6a9a      	ldr	r2, [r3, #40]	; 0x28
    d554:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
    d558:	629a      	str	r2, [r3, #40]	; 0x28
#endif /* defined(CONFIG_ARM_MPU) && defined(CONFIG_CPU_HAS_NXP_MPU) */

	/* clear BFSR sticky bits */
	SCB->CFSR |= SCB_CFSR_BUSFAULTSR_Msk;

	*recoverable = memory_fault_recoverable(esf);
    d55a:	2000      	movs	r0, #0
	if (SCB->CFSR & SCB_CFSR_IMPRECISERR_Msk) {
    d55c:	4b05      	ldr	r3, [pc, #20]	; (d574 <bus_fault.isra.3+0x38>)
    d55e:	6a9a      	ldr	r2, [r3, #40]	; 0x28
	if ((SCB->CFSR & SCB_CFSR_IBUSERR_Msk) != 0) {
    d560:	6a9a      	ldr	r2, [r3, #40]	; 0x28
    d562:	05d2      	lsls	r2, r2, #23
	} else if (SCB->CFSR & SCB_CFSR_LSPERR_Msk) {
    d564:	bf58      	it	pl
    d566:	6a9a      	ldrpl	r2, [r3, #40]	; 0x28
	SCB->CFSR |= SCB_CFSR_BUSFAULTSR_Msk;
    d568:	6a9a      	ldr	r2, [r3, #40]	; 0x28
    d56a:	f442 427f 	orr.w	r2, r2, #65280	; 0xff00
    d56e:	629a      	str	r2, [r3, #40]	; 0x28
	*recoverable = memory_fault_recoverable(esf);
    d570:	7008      	strb	r0, [r1, #0]

	return reason;
}
    d572:	4770      	bx	lr
    d574:	e000ed00 	.word	0xe000ed00

0000d578 <usage_fault.isra.4>:
	u32_t reason = K_ERR_CPU_EXCEPTION;

	PR_FAULT_INFO("***** USAGE FAULT *****");

	/* bits are sticky: they stack and must be reset */
	if ((SCB->CFSR & SCB_CFSR_DIVBYZERO_Msk) != 0) {
    d578:	4b07      	ldr	r3, [pc, #28]	; (d598 <usage_fault.isra.4+0x20>)

	/* clear UFSR sticky bits */
	SCB->CFSR |= SCB_CFSR_USGFAULTSR_Msk;

	return reason;
}
    d57a:	2000      	movs	r0, #0
	if ((SCB->CFSR & SCB_CFSR_DIVBYZERO_Msk) != 0) {
    d57c:	6a9a      	ldr	r2, [r3, #40]	; 0x28
	if ((SCB->CFSR & SCB_CFSR_UNALIGNED_Msk) != 0) {
    d57e:	6a9a      	ldr	r2, [r3, #40]	; 0x28
	if ((SCB->CFSR & SCB_CFSR_STKOF_Msk) != 0) {
    d580:	6a9a      	ldr	r2, [r3, #40]	; 0x28
	if ((SCB->CFSR & SCB_CFSR_NOCP_Msk) != 0) {
    d582:	6a9a      	ldr	r2, [r3, #40]	; 0x28
	if ((SCB->CFSR & SCB_CFSR_INVPC_Msk) != 0) {
    d584:	6a9a      	ldr	r2, [r3, #40]	; 0x28
	if ((SCB->CFSR & SCB_CFSR_INVSTATE_Msk) != 0) {
    d586:	6a9a      	ldr	r2, [r3, #40]	; 0x28
	if ((SCB->CFSR & SCB_CFSR_UNDEFINSTR_Msk) != 0) {
    d588:	6a9a      	ldr	r2, [r3, #40]	; 0x28
	SCB->CFSR |= SCB_CFSR_USGFAULTSR_Msk;
    d58a:	6a9a      	ldr	r2, [r3, #40]	; 0x28
    d58c:	ea6f 4202 	mvn.w	r2, r2, lsl #16
    d590:	ea6f 4212 	mvn.w	r2, r2, lsr #16
    d594:	629a      	str	r2, [r3, #40]	; 0x28
}
    d596:	4770      	bx	lr
    d598:	e000ed00 	.word	0xe000ed00

0000d59c <secure_fault.isra.5>:
 */
static void secure_fault(const z_arch_esf_t *esf)
{
	PR_FAULT_INFO("***** SECURE FAULT *****");

	STORE_xFAR(sfar, SAU->SFAR);
    d59c:	4b0d      	ldr	r3, [pc, #52]	; (d5d4 <secure_fault.isra.5+0x38>)
    d59e:	699a      	ldr	r2, [r3, #24]
	if ((SAU->SFSR & SAU_SFSR_SFARVALID_Msk) != 0) {
    d5a0:	695a      	ldr	r2, [r3, #20]
		PR_EXC("  Address: 0x%x", sfar);
	}

	/* bits are sticky: they stack and must be reset */
	if ((SAU->SFSR & SAU_SFSR_INVEP_Msk) != 0) {
    d5a2:	695a      	ldr	r2, [r3, #20]
    d5a4:	07d0      	lsls	r0, r2, #31
    d5a6:	d40f      	bmi.n	d5c8 <secure_fault.isra.5+0x2c>
		PR_FAULT_INFO("  Invalid entry point");
	} else if ((SAU->SFSR & SAU_SFSR_INVIS_Msk) != 0) {
    d5a8:	695a      	ldr	r2, [r3, #20]
    d5aa:	0791      	lsls	r1, r2, #30
    d5ac:	d40c      	bmi.n	d5c8 <secure_fault.isra.5+0x2c>
		PR_FAULT_INFO("  Invalid integrity signature");
	} else if ((SAU->SFSR & SAU_SFSR_INVER_Msk) != 0) {
    d5ae:	695a      	ldr	r2, [r3, #20]
    d5b0:	0752      	lsls	r2, r2, #29
    d5b2:	d409      	bmi.n	d5c8 <secure_fault.isra.5+0x2c>
		PR_FAULT_INFO("  Invalid exception return");
	} else if ((SAU->SFSR & SAU_SFSR_AUVIOL_Msk) != 0) {
    d5b4:	695a      	ldr	r2, [r3, #20]
    d5b6:	0710      	lsls	r0, r2, #28
    d5b8:	d406      	bmi.n	d5c8 <secure_fault.isra.5+0x2c>
		PR_FAULT_INFO("  Attribution unit violation");
	} else if ((SAU->SFSR & SAU_SFSR_INVTRAN_Msk) != 0) {
    d5ba:	695a      	ldr	r2, [r3, #20]
    d5bc:	06d1      	lsls	r1, r2, #27
    d5be:	d403      	bmi.n	d5c8 <secure_fault.isra.5+0x2c>
		PR_FAULT_INFO("  Invalid transition");
	} else if ((SAU->SFSR & SAU_SFSR_LSPERR_Msk) != 0) {
    d5c0:	695a      	ldr	r2, [r3, #20]
    d5c2:	0692      	lsls	r2, r2, #26
		PR_FAULT_INFO("  Lazy state preservation");
	} else if ((SAU->SFSR & SAU_SFSR_LSERR_Msk) != 0) {
    d5c4:	bf58      	it	pl
    d5c6:	695a      	ldrpl	r2, [r3, #20]
		PR_FAULT_INFO("  Lazy state error");
	}

	/* clear SFSR sticky bits */
	SAU->SFSR |= 0xFF;
    d5c8:	695a      	ldr	r2, [r3, #20]
    d5ca:	f042 02ff 	orr.w	r2, r2, #255	; 0xff
    d5ce:	615a      	str	r2, [r3, #20]
}
    d5d0:	4770      	bx	lr
    d5d2:	bf00      	nop
    d5d4:	e000edd0 	.word	0xe000edd0

0000d5d8 <z_arm_fault>:
 *
 * Note: exc_return argument shall only be used by the Fault handler if we are
 * running a Secure Firmware.
 */
void z_arm_fault(z_arch_esf_t *esf, u32_t exc_return)
{
    d5d8:	b537      	push	{r0, r1, r2, r4, r5, lr}
    d5da:	4604      	mov	r4, r0
	u32_t reason = K_ERR_CPU_EXCEPTION;
	int fault = SCB->ICSR & SCB_ICSR_VECTACTIVE_Msk;
    d5dc:	4a31      	ldr	r2, [pc, #196]	; (d6a4 <z_arm_fault+0xcc>)
	bool recoverable;

#if defined(CONFIG_ARM_SECURE_FIRMWARE)
	if ((exc_return & EXC_RETURN_INDICATOR_PREFIX) !=
    d5de:	f001 407f 	and.w	r0, r1, #4278190080	; 0xff000000
    d5e2:	f1b0 4f7f 	cmp.w	r0, #4278190080	; 0xff000000
	int fault = SCB->ICSR & SCB_ICSR_VECTACTIVE_Msk;
    d5e6:	6853      	ldr	r3, [r2, #4]
	if ((exc_return & EXC_RETURN_INDICATOR_PREFIX) !=
    d5e8:	d159      	bne.n	d69e <z_arm_fault+0xc6>
			EXC_RETURN_INDICATOR_PREFIX) {
		/* Invalid EXC_RETURN value */
		goto _exit_fatal;
	}
	if ((exc_return & EXC_RETURN_EXCEPTION_SECURE_Secure) == 0U) {
    d5ea:	f011 0001 	ands.w	r0, r1, #1
    d5ee:	d00a      	beq.n	d606 <z_arm_fault+0x2e>
		 * This is a fatal error.
		 */
		goto _exit_fatal;
	}

	if (exc_return & EXC_RETURN_RETURN_STACK_Secure) {
    d5f0:	0648      	lsls	r0, r1, #25
    d5f2:	d411      	bmi.n	d618 <z_arm_fault+0x40>

		/* Handle the actual fault.
		 * Extract the correct stack frame from the Non-Secure state
		 * and supply it to the fault handing function.
		 */
		if (exc_return & EXC_RETURN_MODE_THREAD) {
    d5f4:	f011 0008 	ands.w	r0, r1, #8
    d5f8:	d009      	beq.n	d60e <z_arm_fault+0x36>
  __ASM volatile ("MRS %0, psp_ns"  : "=r" (result) );
    d5fa:	f3ef 8489 	mrs	r4, PSP_NS
			esf = (z_arch_esf_t *)__TZ_get_PSP_NS();
			if ((SCB->ICSR & SCB_ICSR_RETTOBASE_Msk) == 0) {
    d5fe:	6850      	ldr	r0, [r2, #4]
    d600:	f410 6000 	ands.w	r0, r0, #2048	; 0x800
    d604:	d108      	bne.n	d618 <z_arm_fault+0x40>

#if defined(CONFIG_ARM_SECURE_FIRMWARE) || \
	defined(CONFIG_ARM_NONSECURE_FIRMWARE)
_exit_fatal:
#endif
	z_arm_fatal_error(reason, esf);
    d606:	4621      	mov	r1, r4
    d608:	f002 fbec 	bl	fde4 <z_arm_fatal_error>
    d60c:	e025      	b.n	d65a <z_arm_fault+0x82>
  __ASM volatile ("MRS %0, msp_ns" : "=r" (result) );
    d60e:	f3ef 8488 	mrs	r4, MSP_NS
			if ((SCB->ICSR & SCB_ICSR_RETTOBASE_Msk) != 0) {
    d612:	6852      	ldr	r2, [r2, #4]
    d614:	0511      	lsls	r1, r2, #20
    d616:	d4f6      	bmi.n	d606 <z_arm_fault+0x2e>
	*recoverable = false;
    d618:	2200      	movs	r2, #0
	int fault = SCB->ICSR & SCB_ICSR_VECTACTIVE_Msk;
    d61a:	f3c3 0308 	ubfx	r3, r3, #0, #9
	switch (fault) {
    d61e:	3b03      	subs	r3, #3
	*recoverable = false;
    d620:	f88d 2007 	strb.w	r2, [sp, #7]
	switch (fault) {
    d624:	2b04      	cmp	r3, #4
    d626:	d830      	bhi.n	d68a <z_arm_fault+0xb2>
    d628:	e8df f003 	tbb	[pc, r3]
    d62c:	26353103 	.word	0x26353103
    d630:	2d          	.byte	0x2d
    d631:	00          	.byte	0x00
	if ((SCB->HFSR & SCB_HFSR_VECTTBL_Msk) != 0) {
    d632:	4b1c      	ldr	r3, [pc, #112]	; (d6a4 <z_arm_fault+0xcc>)
    d634:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    d636:	0792      	lsls	r2, r2, #30
    d638:	d427      	bmi.n	d68a <z_arm_fault+0xb2>
	} else if ((SCB->HFSR & SCB_HFSR_FORCED_Msk) != 0) {
    d63a:	6ad8      	ldr	r0, [r3, #44]	; 0x2c
    d63c:	f010 4080 	ands.w	r0, r0, #1073741824	; 0x40000000
    d640:	d007      	beq.n	d652 <z_arm_fault+0x7a>
		if (SCB_MMFSR != 0) {
    d642:	3328      	adds	r3, #40	; 0x28
    d644:	781b      	ldrb	r3, [r3, #0]
    d646:	b153      	cbz	r3, d65e <z_arm_fault+0x86>
			reason = mem_manage_fault(esf, 1, recoverable);
    d648:	2001      	movs	r0, #1
    d64a:	f10d 0107 	add.w	r1, sp, #7
		reason = mem_manage_fault(esf, 0, recoverable);
    d64e:	f7ff ff59 	bl	d504 <mem_manage_fault.isra.2>
	if (recoverable) {
    d652:	f89d 3007 	ldrb.w	r3, [sp, #7]
    d656:	2b00      	cmp	r3, #0
    d658:	d0d5      	beq.n	d606 <z_arm_fault+0x2e>
}
    d65a:	b003      	add	sp, #12
    d65c:	bd30      	pop	{r4, r5, pc}
		} else if (SCB_BFSR != 0) {
    d65e:	4b12      	ldr	r3, [pc, #72]	; (d6a8 <z_arm_fault+0xd0>)
    d660:	781b      	ldrb	r3, [r3, #0]
    d662:	b12b      	cbz	r3, d670 <z_arm_fault+0x98>
			reason = bus_fault(esf, 1, recoverable);
    d664:	2001      	movs	r0, #1
    d666:	f10d 0107 	add.w	r1, sp, #7
		reason = bus_fault(esf, 0, recoverable);
    d66a:	f7ff ff67 	bl	d53c <bus_fault.isra.3>
		break;
    d66e:	e7f0      	b.n	d652 <z_arm_fault+0x7a>
		} else if (SCB_UFSR != 0) {
    d670:	4b0e      	ldr	r3, [pc, #56]	; (d6ac <z_arm_fault+0xd4>)
    d672:	881d      	ldrh	r5, [r3, #0]
    d674:	b2ad      	uxth	r5, r5
    d676:	b115      	cbz	r5, d67e <z_arm_fault+0xa6>
		reason = usage_fault(esf);
    d678:	f7ff ff7e 	bl	d578 <usage_fault.isra.4>
		break;
    d67c:	e7e9      	b.n	d652 <z_arm_fault+0x7a>
		} else if (SAU->SFSR != 0) {
    d67e:	4b0c      	ldr	r3, [pc, #48]	; (d6b0 <z_arm_fault+0xd8>)
    d680:	6958      	ldr	r0, [r3, #20]
    d682:	2800      	cmp	r0, #0
    d684:	d0e5      	beq.n	d652 <z_arm_fault+0x7a>
		secure_fault(esf);
    d686:	f7ff ff89 	bl	d59c <secure_fault.isra.5>
	u32_t reason = K_ERR_CPU_EXCEPTION;
    d68a:	2000      	movs	r0, #0
    d68c:	e7e1      	b.n	d652 <z_arm_fault+0x7a>
		reason = mem_manage_fault(esf, 0, recoverable);
    d68e:	f10d 0107 	add.w	r1, sp, #7
    d692:	2000      	movs	r0, #0
    d694:	e7db      	b.n	d64e <z_arm_fault+0x76>
		reason = bus_fault(esf, 0, recoverable);
    d696:	f10d 0107 	add.w	r1, sp, #7
    d69a:	2000      	movs	r0, #0
    d69c:	e7e5      	b.n	d66a <z_arm_fault+0x92>
	u32_t reason = K_ERR_CPU_EXCEPTION;
    d69e:	2000      	movs	r0, #0
    d6a0:	e7b1      	b.n	d606 <z_arm_fault+0x2e>
    d6a2:	bf00      	nop
    d6a4:	e000ed00 	.word	0xe000ed00
    d6a8:	e000ed29 	.word	0xe000ed29
    d6ac:	e000ed2a 	.word	0xe000ed2a
    d6b0:	e000edd0 	.word	0xe000edd0

0000d6b4 <z_arm_fault_init>:
 */
void z_arm_fault_init(void)
{
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	SCB->CCR |= SCB_CCR_DIV_0_TRP_Msk;
    d6b4:	4a02      	ldr	r2, [pc, #8]	; (d6c0 <z_arm_fault_init+0xc>)
    d6b6:	6953      	ldr	r3, [r2, #20]
    d6b8:	f043 0310 	orr.w	r3, r3, #16
    d6bc:	6153      	str	r3, [r2, #20]
	 * Stack to attempt to descend into secure region, in which case a
	 * Secure Hard Fault will occur and we can track the fault from there.
	 */
	SCB->CCR |= SCB_CCR_STKOFHFNMIGN_Msk;
#endif /* CONFIG_BUILTIN_STACK_GUARD */
}
    d6be:	4770      	bx	lr
    d6c0:	e000ed00 	.word	0xe000ed00

0000d6c4 <z_arm_int_lib_init>:
 * @return N/A
 */

void z_arm_int_lib_init(void)
{
	int irq = 0;
    d6c4:	2300      	movs	r3, #0
    NVIC->IPR[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
    d6c6:	2120      	movs	r1, #32
    d6c8:	4803      	ldr	r0, [pc, #12]	; (d6d8 <z_arm_int_lib_init+0x14>)
    d6ca:	18c2      	adds	r2, r0, r3

	for (; irq < CONFIG_NUM_IRQS; irq++) {
    d6cc:	3301      	adds	r3, #1
    d6ce:	2b41      	cmp	r3, #65	; 0x41
    d6d0:	f882 1300 	strb.w	r1, [r2, #768]	; 0x300
    d6d4:	d1f9      	bne.n	d6ca <z_arm_int_lib_init+0x6>
		NVIC_SetPriority((IRQn_Type)irq, _IRQ_PRIO_OFFSET);
	}
}
    d6d6:	4770      	bx	lr
    d6d8:	e000e100 	.word	0xe000e100

0000d6dc <z_impl_k_thread_abort>:
#include <sys/__assert.h>

extern void z_thread_single_abort(struct k_thread *thread);

void z_impl_k_thread_abort(k_tid_t thread)
{
    d6dc:	b538      	push	{r3, r4, r5, lr}
    d6de:	4605      	mov	r5, r0
	__asm__ volatile(
    d6e0:	f04f 0320 	mov.w	r3, #32
    d6e4:	f3ef 8411 	mrs	r4, BASEPRI
    d6e8:	f383 8811 	msr	BASEPRI, r3
    d6ec:	f3bf 8f6f 	isb	sy
	key = irq_lock();

	__ASSERT(!(thread->base.user_options & K_ESSENTIAL),
		 "essential thread aborted");

	z_thread_single_abort(thread);
    d6f0:	f002 fd56 	bl	101a0 <z_thread_single_abort>
	z_thread_monitor_exit(thread);

	if (_current == thread) {
    d6f4:	4b0a      	ldr	r3, [pc, #40]	; (d720 <z_impl_k_thread_abort+0x44>)
    d6f6:	689b      	ldr	r3, [r3, #8]
    d6f8:	42ab      	cmp	r3, r5
    d6fa:	d10b      	bne.n	d714 <z_impl_k_thread_abort+0x38>
		if ((SCB->ICSR & SCB_ICSR_VECTACTIVE_Msk) == 0) {
    d6fc:	4b09      	ldr	r3, [pc, #36]	; (d724 <z_impl_k_thread_abort+0x48>)
    d6fe:	685a      	ldr	r2, [r3, #4]
    d700:	f3c2 0208 	ubfx	r2, r2, #0, #9
    d704:	b912      	cbnz	r2, d70c <z_impl_k_thread_abort+0x30>
	z_check_stack_sentinel();

#ifndef CONFIG_ARM
	sys_trace_thread_switched_out();
#endif
	ret = z_arch_swap(key);
    d706:	4620      	mov	r0, r4
    d708:	f7ff fdae 	bl	d268 <z_arch_swap>
			(void)z_swap_irqlock(key);
			CODE_UNREACHABLE;
		} else {
			SCB->ICSR |= SCB_ICSR_PENDSVSET_Msk;
    d70c:	685a      	ldr	r2, [r3, #4]
    d70e:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
    d712:	605a      	str	r2, [r3, #4]
		}
	}

	/* The abort handler might have altered the ready queue. */
	z_reschedule_irqlock(key);
    d714:	4620      	mov	r0, r4
}
    d716:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	z_reschedule_irqlock(key);
    d71a:	f002 bcba 	b.w	10092 <z_reschedule_irqlock>
    d71e:	bf00      	nop
    d720:	20000630 	.word	0x20000630
    d724:	e000ed00 	.word	0xe000ed00

0000d728 <z_arm_configure_static_mpu_regions>:
 *
 * For some MPU architectures, such as the unmodified ARMv8-M MPU,
 * the function must execute with MPU enabled.
 */
void z_arm_configure_static_mpu_regions(void)
{
    d728:	b510      	push	{r4, lr}
		.size = (u32_t)&_nocache_ram_size,
		.attr = K_MEM_PARTITION_P_RW_U_NA_NOCACHE,
		};
#endif /* CONFIG_NOCACHE_MEMORY */
#if defined(CONFIG_ARCH_HAS_RAMFUNC_SUPPORT)
		const struct k_mem_partition ramfunc_region =
    d72a:	4b0e      	ldr	r3, [pc, #56]	; (d764 <z_arm_configure_static_mpu_regions+0x3c>)
{
    d72c:	b088      	sub	sp, #32
		const struct k_mem_partition ramfunc_region =
    d72e:	9302      	str	r3, [sp, #8]
    d730:	4b0d      	ldr	r3, [pc, #52]	; (d768 <z_arm_configure_static_mpu_regions+0x40>)
	/* Configure the static MPU regions within firmware SRAM boundaries.
	 * Start address of the image is given by _image_ram_start. The end
	 * of the firmware SRAM area is marked by __kernel_ram_end, taking
	 * into account the unused SRAM area, as well.
	 */
	arm_core_mpu_configure_static_mpu_regions(static_regions,
    d732:	4c0e      	ldr	r4, [pc, #56]	; (d76c <z_arm_configure_static_mpu_regions+0x44>)
		const struct k_mem_partition ramfunc_region =
    d734:	9303      	str	r3, [sp, #12]
    d736:	4b0e      	ldr	r3, [pc, #56]	; (d770 <z_arm_configure_static_mpu_regions+0x48>)
	arm_core_mpu_configure_static_mpu_regions(static_regions,
    d738:	4a0e      	ldr	r2, [pc, #56]	; (d774 <z_arm_configure_static_mpu_regions+0x4c>)
		const struct k_mem_partition ramfunc_region =
    d73a:	9304      	str	r3, [sp, #16]
	const struct k_mem_partition *static_regions[] = {
    d73c:	ab02      	add	r3, sp, #8
    d73e:	9301      	str	r3, [sp, #4]
	arm_core_mpu_configure_static_mpu_regions(static_regions,
    d740:	a801      	add	r0, sp, #4
    d742:	4623      	mov	r3, r4
    d744:	2101      	movs	r1, #1
    d746:	f000 f903 	bl	d950 <arm_core_mpu_configure_static_mpu_regions>
	/* Define a constant array of k_mem_partition objects that holds the
	 * boundaries of the areas, inside which dynamic region programming
	 * is allowed. The information is passed to the underlying driver at
	 * initialization.
	 */
	const struct k_mem_partition dyn_region_areas[] = {
    d74a:	2300      	movs	r3, #0
    d74c:	9307      	str	r3, [sp, #28]
		{
		.start = _MPU_DYNAMIC_REGIONS_AREA_START,
    d74e:	4b0a      	ldr	r3, [pc, #40]	; (d778 <z_arm_configure_static_mpu_regions+0x50>)
		.size =  _MPU_DYNAMIC_REGIONS_AREA_SIZE,
		}
	};

	arm_core_mpu_mark_areas_for_dynamic_regions(dyn_region_areas,
    d750:	2101      	movs	r1, #1
		.size =  _MPU_DYNAMIC_REGIONS_AREA_SIZE,
    d752:	1ae4      	subs	r4, r4, r3
	arm_core_mpu_mark_areas_for_dynamic_regions(dyn_region_areas,
    d754:	a805      	add	r0, sp, #20
	const struct k_mem_partition dyn_region_areas[] = {
    d756:	9305      	str	r3, [sp, #20]
    d758:	9406      	str	r4, [sp, #24]
	arm_core_mpu_mark_areas_for_dynamic_regions(dyn_region_areas,
    d75a:	f000 f903 	bl	d964 <arm_core_mpu_mark_areas_for_dynamic_regions>
		ARRAY_SIZE(dyn_region_areas));
#endif /* CONFIG_MPU_REQUIRES_NON_OVERLAPPING_REGIONS */
}
    d75e:	b008      	add	sp, #32
    d760:	bd10      	pop	{r4, pc}
    d762:	bf00      	nop
    d764:	20000000 	.word	0x20000000
    d768:	00000000 	.word	0x00000000
    d76c:	20010000 	.word	0x20010000
    d770:	00010006 	.word	0x00010006
    d774:	20000000 	.word	0x20000000
    d778:	20000000 	.word	0x20000000

0000d77c <region_init>:
 * Note:
 *   The caller must provide a valid region index.
 */
static void region_init(const u32_t index,
	const struct arm_mpu_region *region_conf)
{
    d77c:	b510      	push	{r4, lr}
	ARM_MPU_SetRegion(
		/* RNR */
		index,
		/* RBAR */
		(region_conf->base & MPU_RBAR_BASE_Msk)
    d77e:	680b      	ldr	r3, [r1, #0]
		| (region_conf->attr.rbar &
    d780:	7a0c      	ldrb	r4, [r1, #8]
		(region_conf->base & MPU_RBAR_BASE_Msk)
    d782:	f023 021f 	bic.w	r2, r3, #31
		| (region_conf->attr.rbar &
    d786:	f004 031f 	and.w	r3, r4, #31
    d78a:	431a      	orrs	r2, r3
			(MPU_RBAR_XN_Msk | MPU_RBAR_AP_Msk | MPU_RBAR_SH_Msk)),
		/* RLAR */
		(region_conf->attr.r_limit & MPU_RLAR_LIMIT_Msk)
    d78c:	68cb      	ldr	r3, [r1, #12]
		| ((region_conf->attr.mair_idx << MPU_RLAR_AttrIndx_Pos)
    d78e:	0964      	lsrs	r4, r4, #5
		(region_conf->attr.r_limit & MPU_RLAR_LIMIT_Msk)
    d790:	f023 031f 	bic.w	r3, r3, #31
* \param rbar Value for RBAR register.
* \param rlar Value for RLAR register.
*/   
__STATIC_INLINE void ARM_MPU_SetRegionEx(MPU_Type* mpu, uint32_t rnr, uint32_t rbar, uint32_t rlar)
{
  mpu->RNR = rnr;
    d794:	4904      	ldr	r1, [pc, #16]	; (d7a8 <region_init+0x2c>)
		| ((region_conf->attr.mair_idx << MPU_RLAR_AttrIndx_Pos)
    d796:	ea43 0344 	orr.w	r3, r3, r4, lsl #1
			& MPU_RLAR_AttrIndx_Msk)
		| MPU_RLAR_EN_Msk
    d79a:	f043 0301 	orr.w	r3, r3, #1
    d79e:	6088      	str	r0, [r1, #8]
  mpu->RBAR = rbar;
    d7a0:	60ca      	str	r2, [r1, #12]
  mpu->RLAR = rlar;
    d7a2:	610b      	str	r3, [r1, #16]
	);

	LOG_DBG("[%d] 0x%08x 0x%08x 0x%08x 0x%08x",
			index, region_conf->base, region_conf->attr.rbar,
			region_conf->attr.mair_idx, region_conf->attr.r_limit);
}
    d7a4:	bd10      	pop	{r4, pc}
    d7a6:	bf00      	nop
    d7a8:	e000ed90 	.word	0xe000ed90

0000d7ac <mpu_configure_regions.constprop.1>:

/* This internal function programs a set of given MPU regions
 * over a background memory area, optionally performing a
 * sanity check of the memory regions to be programmed.
 */
static int mpu_configure_regions(const struct k_mem_partition
    d7ac:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    d7b0:	4680      	mov	r8, r0
    d7b2:	4689      	mov	r9, r1
    d7b4:	4614      	mov	r4, r2
	bool do_sanity_check)
{
	int i;
	int reg_index = start_reg_index;

	for (i = 0; i < regions_num; i++) {
    d7b6:	2700      	movs	r7, #0
	MPU->RNR = index;
    d7b8:	4d48      	ldr	r5, [pc, #288]	; (d8dc <mpu_configure_regions.constprop.1+0x130>)
static int mpu_configure_regions(const struct k_mem_partition
    d7ba:	b085      	sub	sp, #20
	for (i = 0; i < regions_num; i++) {
    d7bc:	454f      	cmp	r7, r9
    d7be:	da07      	bge.n	d7d0 <mpu_configure_regions.constprop.1+0x24>
		if (regions[i]->size == 0U) {
    d7c0:	f858 3027 	ldr.w	r3, [r8, r7, lsl #2]
    d7c4:	685e      	ldr	r6, [r3, #4]
    d7c6:	b3c6      	cbz	r6, d83a <mpu_configure_regions.constprop.1+0x8e>
		&&
    d7c8:	2e1f      	cmp	r6, #31
    d7ca:	d805      	bhi.n	d7d8 <mpu_configure_regions.constprop.1+0x2c>

			reg_index =
				mpu_configure_region(reg_index, regions[i]);

			if (reg_index == -EINVAL) {
				return reg_index;
    d7cc:	f06f 0415 	mvn.w	r4, #21
			reg_index++;
		}
	}

	return reg_index;
}
    d7d0:	4620      	mov	r0, r4
    d7d2:	b005      	add	sp, #20
    d7d4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		&&
    d7d8:	06f2      	lsls	r2, r6, #27
    d7da:	d1f7      	bne.n	d7cc <mpu_configure_regions.constprop.1+0x20>
		((part->start &
    d7dc:	f8d3 a000 	ldr.w	sl, [r3]
		&&
    d7e0:	f01a 0f1f 	tst.w	sl, #31
    d7e4:	d1f2      	bne.n	d7cc <mpu_configure_regions.constprop.1+0x20>
	u32_t region_start_addr = arm_cmse_mpu_region_get(start);
    d7e6:	4650      	mov	r0, sl
    d7e8:	f001 ffd7 	bl	f79a <arm_cmse_mpu_region_get>
    d7ec:	4683      	mov	fp, r0
	u32_t region_end_addr = arm_cmse_mpu_region_get(start + size - 1);
    d7ee:	eb06 000a 	add.w	r0, r6, sl
    d7f2:	3801      	subs	r0, #1
    d7f4:	f001 ffd1 	bl	f79a <arm_cmse_mpu_region_get>
	if (region_start_addr == region_end_addr) {
    d7f8:	4583      	cmp	fp, r0
    d7fa:	d1e7      	bne.n	d7cc <mpu_configure_regions.constprop.1+0x20>
		if ((u_reg_index == -EINVAL) ||
    d7fc:	f11b 0f16 	cmn.w	fp, #22
    d800:	d0e4      	beq.n	d7cc <mpu_configure_regions.constprop.1+0x20>
			(u_reg_index > (reg_index - 1))) {
    d802:	1e63      	subs	r3, r4, #1
		if ((u_reg_index == -EINVAL) ||
    d804:	455b      	cmp	r3, fp
    d806:	dbe1      	blt.n	d7cc <mpu_configure_regions.constprop.1+0x20>
	MPU->RNR = index;
    d808:	f8c5 b008 	str.w	fp, [r5, #8]
	return MPU->RBAR & MPU_RBAR_BASE_Msk;
    d80c:	68e8      	ldr	r0, [r5, #12]
		u32_t reg_last = regions[i]->start + regions[i]->size - 1;
    d80e:	f858 1027 	ldr.w	r1, [r8, r7, lsl #2]
	MPU->RNR = index;
    d812:	f8c5 b008 	str.w	fp, [r5, #8]
	return (MPU->RLAR & MPU_RLAR_LIMIT_Msk) | (~MPU_RLAR_LIMIT_Msk);
    d816:	692e      	ldr	r6, [r5, #16]
	return MPU->RBAR & MPU_RBAR_BASE_Msk;
    d818:	f020 001f 	bic.w	r0, r0, #31
		u32_t reg_last = regions[i]->start + regions[i]->size - 1;
    d81c:	e9d1 3200 	ldrd	r3, r2, [r1]
    d820:	441a      	add	r2, r3
		if ((regions[i]->start == u_reg_base) &&
    d822:	4298      	cmp	r0, r3
	return (MPU->RLAR & MPU_RLAR_LIMIT_Msk) | (~MPU_RLAR_LIMIT_Msk);
    d824:	f046 061f 	orr.w	r6, r6, #31
		u32_t reg_last = regions[i]->start + regions[i]->size - 1;
    d828:	f102 3aff 	add.w	sl, r2, #4294967295	; 0xffffffff
		if ((regions[i]->start == u_reg_base) &&
    d82c:	d118      	bne.n	d860 <mpu_configure_regions.constprop.1+0xb4>
    d82e:	4556      	cmp	r6, sl
    d830:	d105      	bne.n	d83e <mpu_configure_regions.constprop.1+0x92>
			mpu_configure_region(u_reg_index, regions[i]);
    d832:	fa5f f08b 	uxtb.w	r0, fp
    d836:	f002 faea 	bl	fe0e <mpu_configure_region>
	for (i = 0; i < regions_num; i++) {
    d83a:	3701      	adds	r7, #1
    d83c:	e7be      	b.n	d7bc <mpu_configure_regions.constprop.1+0x10>
	MPU->RNR = index;
    d83e:	f8c5 b008 	str.w	fp, [r5, #8]
	MPU->RBAR = (MPU->RBAR & (~MPU_RBAR_BASE_Msk))
    d842:	68eb      	ldr	r3, [r5, #12]
		| (base & MPU_RBAR_BASE_Msk);
    d844:	f022 021f 	bic.w	r2, r2, #31
	MPU->RBAR = (MPU->RBAR & (~MPU_RBAR_BASE_Msk))
    d848:	f003 031f 	and.w	r3, r3, #31
		| (base & MPU_RBAR_BASE_Msk);
    d84c:	431a      	orrs	r2, r3
	MPU->RBAR = (MPU->RBAR & (~MPU_RBAR_BASE_Msk))
    d84e:	60ea      	str	r2, [r5, #12]
				mpu_configure_region(reg_index, regions[i]);
    d850:	b2e0      	uxtb	r0, r4
				mpu_configure_region(reg_index, regions[i]);
    d852:	f002 fadc 	bl	fe0e <mpu_configure_region>
			if (reg_index == -EINVAL) {
    d856:	f110 0f16 	cmn.w	r0, #22
    d85a:	d0b7      	beq.n	d7cc <mpu_configure_regions.constprop.1+0x20>
			reg_index++;
    d85c:	1c44      	adds	r4, r0, #1
    d85e:	e7ec      	b.n	d83a <mpu_configure_regions.constprop.1+0x8e>
	MPU->RNR = index;
    d860:	f8c5 b008 	str.w	fp, [r5, #8]
	MPU->RLAR = (MPU->RLAR & (~MPU_RLAR_LIMIT_Msk))
    d864:	692a      	ldr	r2, [r5, #16]
    d866:	3b01      	subs	r3, #1
    d868:	f023 031f 	bic.w	r3, r3, #31
    d86c:	f002 021f 	and.w	r2, r2, #31
		| (limit & MPU_RLAR_LIMIT_Msk);
    d870:	4313      	orrs	r3, r2
		} else if (reg_last == u_reg_last) {
    d872:	4556      	cmp	r6, sl
    d874:	b2e0      	uxtb	r0, r4
	MPU->RLAR = (MPU->RLAR & (~MPU_RLAR_LIMIT_Msk))
    d876:	612b      	str	r3, [r5, #16]
		} else if (reg_last == u_reg_last) {
    d878:	d0eb      	beq.n	d852 <mpu_configure_regions.constprop.1+0xa6>
				mpu_configure_region(reg_index, regions[i]);
    d87a:	f002 fac8 	bl	fe0e <mpu_configure_region>
			if (reg_index == -EINVAL) {
    d87e:	f110 0f16 	cmn.w	r0, #22
    d882:	d0a3      	beq.n	d7cc <mpu_configure_regions.constprop.1+0x20>
	MPU->RNR = index;
    d884:	f8c5 b008 	str.w	fp, [r5, #8]
	attr->rbar = MPU->RBAR &
    d888:	68ea      	ldr	r2, [r5, #12]
    d88a:	f89d 3008 	ldrb.w	r3, [sp, #8]
			REGION_LIMIT_ADDR((regions[i]->start +
    d88e:	3e01      	subs	r6, #1
	attr->rbar = MPU->RBAR &
    d890:	f362 0304 	bfi	r3, r2, #0, #5
    d894:	f88d 3008 	strb.w	r3, [sp, #8]
	attr->mair_idx = (MPU->RLAR & MPU_RLAR_AttrIndx_Msk) >>
    d898:	692b      	ldr	r3, [r5, #16]
    d89a:	f89d 2008 	ldrb.w	r2, [sp, #8]
    d89e:	085b      	lsrs	r3, r3, #1
    d8a0:	f363 1247 	bfi	r2, r3, #5, #3
    d8a4:	f88d 2008 	strb.w	r2, [sp, #8]
			fill_region.base = regions[i]->start +
    d8a8:	f858 2027 	ldr.w	r2, [r8, r7, lsl #2]
			reg_index++;
    d8ac:	3001      	adds	r0, #1
			fill_region.base = regions[i]->start +
    d8ae:	e9d2 3200 	ldrd	r3, r2, [r2]
    d8b2:	4413      	add	r3, r2
    d8b4:	9300      	str	r3, [sp, #0]
			REGION_LIMIT_ADDR((regions[i]->start +
    d8b6:	f023 031f 	bic.w	r3, r3, #31
    d8ba:	441e      	add	r6, r3
    d8bc:	eba6 060a 	sub.w	r6, r6, sl
    d8c0:	b2c4      	uxtb	r4, r0
    d8c2:	f026 061f 	bic.w	r6, r6, #31

static int region_allocate_and_init(const u8_t index,
	const struct arm_mpu_region *region_conf)
{
	/* Attempt to allocate new region index. */
	if (index > (get_num_regions() - 1)) {
    d8c6:	2c0f      	cmp	r4, #15
			fill_region.attr.r_limit =
    d8c8:	9603      	str	r6, [sp, #12]
    d8ca:	f63f af7f 	bhi.w	d7cc <mpu_configure_regions.constprop.1+0x20>
	}

	LOG_DBG("Program MPU region at index 0x%x", index);

	/* Program region */
	region_init(index, region_conf);
    d8ce:	4620      	mov	r0, r4
    d8d0:	4669      	mov	r1, sp
    d8d2:	f7ff ff53 	bl	d77c <region_init>
			reg_index++;
    d8d6:	3401      	adds	r4, #1
    d8d8:	e7af      	b.n	d83a <mpu_configure_regions.constprop.1+0x8e>
    d8da:	bf00      	nop
    d8dc:	e000ed90 	.word	0xe000ed90

0000d8e0 <arm_core_mpu_enable>:
void arm_core_mpu_enable(void)
{
	/* Enable MPU and use the default memory map as a
	 * background region for privileged software access.
	 */
	MPU->CTRL = MPU_CTRL_ENABLE_Msk | MPU_CTRL_PRIVDEFENA_Msk;
    d8e0:	2205      	movs	r2, #5
    d8e2:	4b03      	ldr	r3, [pc, #12]	; (d8f0 <arm_core_mpu_enable+0x10>)
    d8e4:	605a      	str	r2, [r3, #4]
  __ASM volatile ("dsb 0xF":::"memory");
    d8e6:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    d8ea:	f3bf 8f6f 	isb	sy

	/* Make sure that all the registers are set before proceeding */
	__DSB();
	__ISB();
}
    d8ee:	4770      	bx	lr
    d8f0:	e000ed90 	.word	0xe000ed90

0000d8f4 <arm_core_mpu_disable>:
  \details Ensures the apparent order of the explicit memory operations before
           and after the instruction, without ensuring their completion.
 */
__STATIC_FORCEINLINE void __DMB(void)
{
  __ASM volatile ("dmb 0xF":::"memory");
    d8f4:	f3bf 8f5f 	dmb	sy
{
	/* Force any outstanding transfers to complete before disabling MPU */
	__DMB();

	/* Disable MPU */
	MPU->CTRL = 0;
    d8f8:	2200      	movs	r2, #0
    d8fa:	4b01      	ldr	r3, [pc, #4]	; (d900 <arm_core_mpu_disable+0xc>)
    d8fc:	605a      	str	r2, [r3, #4]
}
    d8fe:	4770      	bx	lr
    d900:	e000ed90 	.word	0xe000ed90

0000d904 <arm_mpu_init>:
 *
 * This function provides the default configuration mechanism for the Memory
 * Protection Unit (MPU).
 */
static int arm_mpu_init(struct device *arg)
{
    d904:	b570      	push	{r4, r5, r6, lr}
	u32_t r_index;

	if (mpu_config.num_regions > get_num_regions()) {
    d906:	4d0e      	ldr	r5, [pc, #56]	; (d940 <arm_mpu_init+0x3c>)
    d908:	682e      	ldr	r6, [r5, #0]
    d90a:	2e10      	cmp	r6, #16
    d90c:	d815      	bhi.n	d93a <arm_mpu_init+0x36>

	/* Architecture-specific configuration */
	mpu_init();

	/* Program fixed regions configured at SOC definition. */
	for (r_index = 0U; r_index < mpu_config.num_regions; r_index++) {
    d90e:	2400      	movs	r4, #0
	arm_core_mpu_disable();
    d910:	f7ff fff0 	bl	d8f4 <arm_core_mpu_disable>
	MPU->MAIR0 =
    d914:	4b0b      	ldr	r3, [pc, #44]	; (d944 <arm_mpu_init+0x40>)
    d916:	4a0c      	ldr	r2, [pc, #48]	; (d948 <arm_mpu_init+0x44>)
    d918:	631a      	str	r2, [r3, #48]	; 0x30
	for (r_index = 0U; r_index < mpu_config.num_regions; r_index++) {
    d91a:	42a6      	cmp	r6, r4
    d91c:	d105      	bne.n	d92a <arm_mpu_init+0x26>
		region_init(r_index, &mpu_config.mpu_regions[r_index]);
	}

	/* Update the number of programmed MPU regions. */
	static_regions_num = mpu_config.num_regions;
    d91e:	4b0b      	ldr	r3, [pc, #44]	; (d94c <arm_mpu_init+0x48>)
    d920:	701e      	strb	r6, [r3, #0]


	arm_core_mpu_enable();
    d922:	f7ff ffdd 	bl	d8e0 <arm_core_mpu_enable>
	__ASSERT(
		(MPU->TYPE & MPU_TYPE_DREGION_Msk) >> MPU_TYPE_DREGION_Pos ==
		DT_NUM_MPU_REGIONS,
		"Invalid number of MPU regions\n");
#endif /* CORTEX_M0PLUS || CPU_CORTEX_M3 || CPU_CORTEX_M4 */
	return 0;
    d926:	2000      	movs	r0, #0
}
    d928:	bd70      	pop	{r4, r5, r6, pc}
		region_init(r_index, &mpu_config.mpu_regions[r_index]);
    d92a:	6869      	ldr	r1, [r5, #4]
    d92c:	4620      	mov	r0, r4
    d92e:	eb01 1104 	add.w	r1, r1, r4, lsl #4
    d932:	f7ff ff23 	bl	d77c <region_init>
	for (r_index = 0U; r_index < mpu_config.num_regions; r_index++) {
    d936:	3401      	adds	r4, #1
    d938:	e7ef      	b.n	d91a <arm_mpu_init+0x16>
		return -1;
    d93a:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    d93e:	e7f3      	b.n	d928 <arm_mpu_init+0x24>
    d940:	00010510 	.word	0x00010510
    d944:	e000ed90 	.word	0xe000ed90
    d948:	0044ffaa 	.word	0x0044ffaa
    d94c:	2000068c 	.word	0x2000068c

0000d950 <arm_core_mpu_configure_static_mpu_regions>:
{
    d950:	b510      	push	{r4, lr}
static int mpu_configure_static_mpu_regions(const struct k_mem_partition
	*static_regions[], const u8_t regions_num,
	const u32_t background_area_base,
	const u32_t background_area_end)
{
	int mpu_reg_index = static_regions_num;
    d952:	4c03      	ldr	r4, [pc, #12]	; (d960 <arm_core_mpu_configure_static_mpu_regions+0x10>)
	 * given boundaries.
	 */
	ARG_UNUSED(background_area_base);
	ARG_UNUSED(background_area_end);

	mpu_reg_index = mpu_configure_regions(static_regions,
    d954:	7822      	ldrb	r2, [r4, #0]
    d956:	f7ff ff29 	bl	d7ac <mpu_configure_regions.constprop.1>
		regions_num, mpu_reg_index, true);

	static_regions_num = mpu_reg_index;
    d95a:	7020      	strb	r0, [r4, #0]
}
    d95c:	bd10      	pop	{r4, pc}
    d95e:	bf00      	nop
    d960:	2000068c 	.word	0x2000068c

0000d964 <arm_core_mpu_mark_areas_for_dynamic_regions>:
{
    d964:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    d968:	4c25      	ldr	r4, [pc, #148]	; (da00 <arm_core_mpu_mark_areas_for_dynamic_regions+0x9c>)
    d96a:	468a      	mov	sl, r1
{
	/* In ARMv8-M architecture we need to store the index values
	 * and the default configuration of the MPU regions, inside
	 * which dynamic memory regions may be programmed at run-time.
	 */
	for (int i = 0; i < dyn_region_areas_num; i++) {
    d96c:	4680      	mov	r8, r0
    d96e:	2700      	movs	r7, #0
    d970:	46a1      	mov	r9, r4
	attr->rbar = MPU->RBAR &
    d972:	f04f 0b14 	mov.w	fp, #20
	MPU->RNR = index;
    d976:	4d23      	ldr	r5, [pc, #140]	; (da04 <arm_core_mpu_mark_areas_for_dynamic_regions+0xa0>)
	for (int i = 0; i < dyn_region_areas_num; i++) {
    d978:	4557      	cmp	r7, sl
    d97a:	da1a      	bge.n	d9b2 <arm_core_mpu_mark_areas_for_dynamic_regions+0x4e>
		if (dyn_region_areas[i].size == 0U) {
    d97c:	f8d8 3004 	ldr.w	r3, [r8, #4]
    d980:	9301      	str	r3, [sp, #4]
    d982:	2b00      	cmp	r3, #0
    d984:	d036      	beq.n	d9f4 <arm_core_mpu_mark_areas_for_dynamic_regions+0x90>
		}
		/* Non-empty area */

		/* Retrieve HW MPU region index */
		dyn_reg_info[i].index =
			get_region_index(dyn_region_areas[i].start,
    d986:	f8d8 1000 	ldr.w	r1, [r8]
	u32_t region_start_addr = arm_cmse_mpu_region_get(start);
    d98a:	4608      	mov	r0, r1
    d98c:	9100      	str	r1, [sp, #0]
    d98e:	f001 ff04 	bl	f79a <arm_cmse_mpu_region_get>
	u32_t region_end_addr = arm_cmse_mpu_region_get(start + size - 1);
    d992:	e9dd 1300 	ldrd	r1, r3, [sp]
	u32_t region_start_addr = arm_cmse_mpu_region_get(start);
    d996:	4606      	mov	r6, r0
	u32_t region_end_addr = arm_cmse_mpu_region_get(start + size - 1);
    d998:	1858      	adds	r0, r3, r1
    d99a:	3801      	subs	r0, #1
    d99c:	f001 fefd 	bl	f79a <arm_cmse_mpu_region_get>
	if (region_start_addr == region_end_addr) {
    d9a0:	4286      	cmp	r6, r0
    d9a2:	4a19      	ldr	r2, [pc, #100]	; (da08 <arm_core_mpu_mark_areas_for_dynamic_regions+0xa4>)
    d9a4:	d008      	beq.n	d9b8 <arm_core_mpu_mark_areas_for_dynamic_regions+0x54>
		dyn_reg_info[i].index =
    d9a6:	2314      	movs	r3, #20
    d9a8:	435f      	muls	r7, r3
    d9aa:	f06f 0315 	mvn.w	r3, #21
    d9ae:	f849 3007 	str.w	r3, [r9, r7]
}
    d9b2:	b003      	add	sp, #12
    d9b4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
					dyn_region_areas[i].size);

		if (dyn_reg_info[i].index == -EINVAL) {
    d9b8:	f116 0f16 	cmn.w	r6, #22
		dyn_reg_info[i].index =
    d9bc:	6026      	str	r6, [r4, #0]
		if (dyn_reg_info[i].index == -EINVAL) {
    d9be:	d0f8      	beq.n	d9b2 <arm_core_mpu_mark_areas_for_dynamic_regions+0x4e>

			return -EINVAL;
		}

		if (dyn_reg_info[i].index >= static_regions_num) {
    d9c0:	7813      	ldrb	r3, [r2, #0]
    d9c2:	42b3      	cmp	r3, r6
    d9c4:	ddf5      	ble.n	d9b2 <arm_core_mpu_mark_areas_for_dynamic_regions+0x4e>
	attr->rbar = MPU->RBAR &
    d9c6:	fb0b 9307 	mla	r3, fp, r7, r9
	MPU->RNR = index;
    d9ca:	60ae      	str	r6, [r5, #8]
	MPU->RNR = index;
    d9cc:	60ae      	str	r6, [r5, #8]
	attr->rbar = MPU->RBAR &
    d9ce:	68e8      	ldr	r0, [r5, #12]
    d9d0:	7b19      	ldrb	r1, [r3, #12]
    d9d2:	f360 0104 	bfi	r1, r0, #0, #5
    d9d6:	7319      	strb	r1, [r3, #12]
	attr->mair_idx = (MPU->RLAR & MPU_RLAR_AttrIndx_Msk) >>
    d9d8:	6929      	ldr	r1, [r5, #16]
    d9da:	7b18      	ldrb	r0, [r3, #12]
    d9dc:	0849      	lsrs	r1, r1, #1
    d9de:	f361 1047 	bfi	r0, r1, #5, #3
    d9e2:	7318      	strb	r0, [r3, #12]
	region_conf->base = (MPU->RBAR & MPU_RBAR_BASE_Msk);
    d9e4:	68eb      	ldr	r3, [r5, #12]
    d9e6:	f023 031f 	bic.w	r3, r3, #31
    d9ea:	6063      	str	r3, [r4, #4]
	region_conf->attr.r_limit = MPU->RLAR & MPU_RLAR_LIMIT_Msk;
    d9ec:	692b      	ldr	r3, [r5, #16]
    d9ee:	f023 031f 	bic.w	r3, r3, #31
    d9f2:	6123      	str	r3, [r4, #16]
	for (int i = 0; i < dyn_region_areas_num; i++) {
    d9f4:	3701      	adds	r7, #1
    d9f6:	3414      	adds	r4, #20
    d9f8:	f108 080c 	add.w	r8, r8, #12
    d9fc:	e7bc      	b.n	d978 <arm_core_mpu_mark_areas_for_dynamic_regions+0x14>
    d9fe:	bf00      	nop
    da00:	20000544 	.word	0x20000544
    da04:	e000ed90 	.word	0xe000ed90
    da08:	2000068c 	.word	0x2000068c

0000da0c <arm_core_mpu_configure_dynamic_mpu_regions>:
{
    da0c:	b570      	push	{r4, r5, r6, lr}
 * performed, the error signal is propagated to the caller of the function.
 */
static int mpu_configure_dynamic_mpu_regions(const struct k_mem_partition
	*dynamic_regions[], u8_t regions_num)
{
	int mpu_reg_index = static_regions_num;
    da0e:	4b0c      	ldr	r3, [pc, #48]	; (da40 <arm_core_mpu_configure_dynamic_mpu_regions+0x34>)
    da10:	460e      	mov	r6, r1
    da12:	781c      	ldrb	r4, [r3, #0]
    da14:	4605      	mov	r5, r0
    da16:	4623      	mov	r3, r4
  mpu->RLAR = 0U;
    da18:	2100      	movs	r1, #0
  mpu->RNR = rnr;
    da1a:	4a0a      	ldr	r2, [pc, #40]	; (da44 <arm_core_mpu_configure_dynamic_mpu_regions+0x38>)

	/* Disable all MPU regions except for the static ones. */
	for (int i = mpu_reg_index; i < get_num_regions(); i++) {
    da1c:	2b0f      	cmp	r3, #15
    da1e:	dd0b      	ble.n	da38 <arm_core_mpu_configure_dynamic_mpu_regions+0x2c>

	/* Reset MPU regions inside which dynamic memory regions may
	 * be programmed.
	 */
	for (int i = 0; i < MPU_DYNAMIC_REGION_AREAS_NUM; i++) {
		region_init(dyn_reg_info[i].index,
    da20:	4909      	ldr	r1, [pc, #36]	; (da48 <arm_core_mpu_configure_dynamic_mpu_regions+0x3c>)
    da22:	f851 0b04 	ldr.w	r0, [r1], #4
    da26:	f7ff fea9 	bl	d77c <region_init>
	/* In ARMv8-M architecture the dynamic regions are programmed on SRAM,
	 * forming a full partition of the background area, specified by the
	 * given boundaries.
	 */

	mpu_reg_index = mpu_configure_regions(dynamic_regions,
    da2a:	4622      	mov	r2, r4
    da2c:	4631      	mov	r1, r6
    da2e:	4628      	mov	r0, r5
}
    da30:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    da34:	f7ff beba 	b.w	d7ac <mpu_configure_regions.constprop.1>
    da38:	6093      	str	r3, [r2, #8]
  mpu->RLAR = 0U;
    da3a:	6111      	str	r1, [r2, #16]
	for (int i = mpu_reg_index; i < get_num_regions(); i++) {
    da3c:	3301      	adds	r3, #1
    da3e:	e7ed      	b.n	da1c <arm_core_mpu_configure_dynamic_mpu_regions+0x10>
    da40:	2000068c 	.word	0x2000068c
    da44:	e000ed90 	.word	0xe000ed90
    da48:	20000544 	.word	0x20000544

0000da4c <__stdout_hook_install>:

static int (*_stdout_hook)(int) = _stdout_hook_default;

void __stdout_hook_install(int (*hook)(int))
{
	_stdout_hook = hook;
    da4c:	4b01      	ldr	r3, [pc, #4]	; (da54 <__stdout_hook_install+0x8>)
    da4e:	6018      	str	r0, [r3, #0]
}
    da50:	4770      	bx	lr
    da52:	bf00      	nop
    da54:	200013f8 	.word	0x200013f8

0000da58 <uarte_nrfx_configure>:
	return 0;
}

static int uarte_nrfx_configure(struct device *dev,
				const struct uart_config *cfg)
{
    da58:	b5f0      	push	{r4, r5, r6, r7, lr}
	nrf_uarte_hwfc_t hwfc;
#ifdef UARTE_CONFIG_STOP_Two
	bool two_stop_bits = false;
#endif

	switch (cfg->stop_bits) {
    da5a:	794b      	ldrb	r3, [r1, #5]
    da5c:	2b01      	cmp	r3, #1
    da5e:	d029      	beq.n	dab4 <uarte_nrfx_configure+0x5c>
    da60:	2b03      	cmp	r3, #3
    da62:	d124      	bne.n	daae <uarte_nrfx_configure+0x56>
	case UART_CFG_STOP_BITS_1:
		break;
#ifdef UARTE_CONFIG_STOP_Two
	case UART_CFG_STOP_BITS_2:
		two_stop_bits = true;
    da64:	2601      	movs	r6, #1
#endif
	default:
		return -ENOTSUP;
	}

	if (cfg->data_bits != UART_CFG_DATA_BITS_8) {
    da66:	798b      	ldrb	r3, [r1, #6]
    da68:	2b03      	cmp	r3, #3
    da6a:	d120      	bne.n	daae <uarte_nrfx_configure+0x56>
		return -ENOTSUP;
	}

	switch (cfg->flow_ctrl) {
    da6c:	79cd      	ldrb	r5, [r1, #7]
    da6e:	b12d      	cbz	r5, da7c <uarte_nrfx_configure+0x24>
    da70:	2d01      	cmp	r5, #1
    da72:	d11c      	bne.n	daae <uarte_nrfx_configure+0x56>
	return dev->config->config_info;
    da74:	6803      	ldr	r3, [r0, #0]
	case UART_CFG_FLOW_CTRL_NONE:
		hwfc = NRF_UARTE_HWFC_DISABLED;
		break;
	case UART_CFG_FLOW_CTRL_RTS_CTS:
		if (get_dev_config(dev)->rts_cts_pins_set) {
    da76:	689b      	ldr	r3, [r3, #8]
    da78:	791b      	ldrb	r3, [r3, #4]
    da7a:	b1c3      	cbz	r3, daae <uarte_nrfx_configure+0x56>
		break;
	default:
		return -ENOTSUP;
	}

	switch (cfg->parity) {
    da7c:	790a      	ldrb	r2, [r1, #4]
    da7e:	b112      	cbz	r2, da86 <uarte_nrfx_configure+0x2e>
    da80:	2a02      	cmp	r2, #2
    da82:	d114      	bne.n	daae <uarte_nrfx_configure+0x56>
	case UART_CFG_PARITY_NONE:
		parity = NRF_UARTE_PARITY_EXCLUDED;
		break;
	case UART_CFG_PARITY_EVEN:
		parity = NRF_UARTE_PARITY_INCLUDED;
    da84:	220e      	movs	r2, #14
	switch (baudrate) {
    da86:	f647 2712 	movw	r7, #31250	; 0x7a12
	return dev->config->config_info;
    da8a:	6804      	ldr	r4, [r0, #0]
		break;
	default:
		return -ENOTSUP;
	}

	if (baudrate_set(dev, cfg->baudrate) != 0) {
    da8c:	680b      	ldr	r3, [r1, #0]
	return config->uarte_regs;
    da8e:	68a4      	ldr	r4, [r4, #8]
	switch (baudrate) {
    da90:	42bb      	cmp	r3, r7
	return config->uarte_regs;
    da92:	6824      	ldr	r4, [r4, #0]
	switch (baudrate) {
    da94:	d068      	beq.n	db68 <uarte_nrfx_configure+0x110>
    da96:	d829      	bhi.n	daec <uarte_nrfx_configure+0x94>
    da98:	f5b3 5f96 	cmp.w	r3, #4800	; 0x12c0
    da9c:	d067      	beq.n	db6e <uarte_nrfx_configure+0x116>
    da9e:	d814      	bhi.n	daca <uarte_nrfx_configure+0x72>
    daa0:	f5b3 7f16 	cmp.w	r3, #600	; 0x258
    daa4:	d065      	beq.n	db72 <uarte_nrfx_configure+0x11a>
    daa6:	d807      	bhi.n	dab8 <uarte_nrfx_configure+0x60>
    daa8:	f5b3 7f96 	cmp.w	r3, #300	; 0x12c
    daac:	d064      	beq.n	db78 <uarte_nrfx_configure+0x120>
		return -ENOTSUP;
    daae:	f06f 0022 	mvn.w	r0, #34	; 0x22
    dab2:	e058      	b.n	db66 <uarte_nrfx_configure+0x10e>
	bool two_stop_bits = false;
    dab4:	2600      	movs	r6, #0
    dab6:	e7d6      	b.n	da66 <uarte_nrfx_configure+0xe>
	switch (baudrate) {
    dab8:	f5b3 6f96 	cmp.w	r3, #1200	; 0x4b0
    dabc:	d05f      	beq.n	db7e <uarte_nrfx_configure+0x126>
    dabe:	f5b3 6f16 	cmp.w	r3, #2400	; 0x960
    dac2:	d1f4      	bne.n	daae <uarte_nrfx_configure+0x56>
		nrf_baudrate = NRF_UARTE_BAUDRATE_2400;
    dac4:	f44f 231d 	mov.w	r3, #643072	; 0x9d000
    dac8:	e03c      	b.n	db44 <uarte_nrfx_configure+0xec>
	switch (baudrate) {
    daca:	f5b3 5f61 	cmp.w	r3, #14400	; 0x3840
    dace:	d059      	beq.n	db84 <uarte_nrfx_configure+0x12c>
    dad0:	d804      	bhi.n	dadc <uarte_nrfx_configure+0x84>
    dad2:	f5b3 5f16 	cmp.w	r3, #9600	; 0x2580
    dad6:	d1ea      	bne.n	daae <uarte_nrfx_configure+0x56>
		nrf_baudrate = NRF_UARTE_BAUDRATE_9600;
    dad8:	4b35      	ldr	r3, [pc, #212]	; (dbb0 <uarte_nrfx_configure+0x158>)
    dada:	e033      	b.n	db44 <uarte_nrfx_configure+0xec>
	switch (baudrate) {
    dadc:	f5b3 4f96 	cmp.w	r3, #19200	; 0x4b00
    dae0:	d052      	beq.n	db88 <uarte_nrfx_configure+0x130>
    dae2:	f5b3 4fe1 	cmp.w	r3, #28800	; 0x7080
    dae6:	d1e2      	bne.n	daae <uarte_nrfx_configure+0x56>
		nrf_baudrate = NRF_UARTE_BAUDRATE_28800;
    dae8:	4b32      	ldr	r3, [pc, #200]	; (dbb4 <uarte_nrfx_configure+0x15c>)
    daea:	e02b      	b.n	db44 <uarte_nrfx_configure+0xec>
	switch (baudrate) {
    daec:	f5b3 3fe1 	cmp.w	r3, #115200	; 0x1c200
    daf0:	d04c      	beq.n	db8c <uarte_nrfx_configure+0x134>
    daf2:	d812      	bhi.n	db1a <uarte_nrfx_configure+0xc2>
    daf4:	f64d 27c0 	movw	r7, #56000	; 0xdac0
    daf8:	42bb      	cmp	r3, r7
    dafa:	d04a      	beq.n	db92 <uarte_nrfx_configure+0x13a>
    dafc:	d805      	bhi.n	db0a <uarte_nrfx_configure+0xb2>
    dafe:	f5b3 4f16 	cmp.w	r3, #38400	; 0x9600
    db02:	d1d4      	bne.n	daae <uarte_nrfx_configure+0x56>
		nrf_baudrate = NRF_UARTE_BAUDRATE_38400;
    db04:	f44f 031d 	mov.w	r3, #10289152	; 0x9d0000
    db08:	e01c      	b.n	db44 <uarte_nrfx_configure+0xec>
	switch (baudrate) {
    db0a:	f5b3 4f61 	cmp.w	r3, #57600	; 0xe100
    db0e:	d043      	beq.n	db98 <uarte_nrfx_configure+0x140>
    db10:	f5b3 3f96 	cmp.w	r3, #76800	; 0x12c00
    db14:	d1cb      	bne.n	daae <uarte_nrfx_configure+0x56>
		nrf_baudrate = NRF_UARTE_BAUDRATE_76800;
    db16:	4b28      	ldr	r3, [pc, #160]	; (dbb8 <uarte_nrfx_configure+0x160>)
    db18:	e014      	b.n	db44 <uarte_nrfx_configure+0xec>
	switch (baudrate) {
    db1a:	f5b3 2fe1 	cmp.w	r3, #460800	; 0x70800
    db1e:	d03e      	beq.n	db9e <uarte_nrfx_configure+0x146>
    db20:	d808      	bhi.n	db34 <uarte_nrfx_configure+0xdc>
    db22:	f5b3 3f61 	cmp.w	r3, #230400	; 0x38400
    db26:	d03d      	beq.n	dba4 <uarte_nrfx_configure+0x14c>
    db28:	4f24      	ldr	r7, [pc, #144]	; (dbbc <uarte_nrfx_configure+0x164>)
    db2a:	42bb      	cmp	r3, r7
    db2c:	d1bf      	bne.n	daae <uarte_nrfx_configure+0x56>
		nrf_baudrate = NRF_UARTE_BAUDRATE_250000;
    db2e:	f04f 6380 	mov.w	r3, #67108864	; 0x4000000
    db32:	e007      	b.n	db44 <uarte_nrfx_configure+0xec>
	switch (baudrate) {
    db34:	f5b3 2f61 	cmp.w	r3, #921600	; 0xe1000
    db38:	d037      	beq.n	dbaa <uarte_nrfx_configure+0x152>
    db3a:	4f21      	ldr	r7, [pc, #132]	; (dbc0 <uarte_nrfx_configure+0x168>)
    db3c:	42bb      	cmp	r3, r7
    db3e:	d1b6      	bne.n	daae <uarte_nrfx_configure+0x56>
		nrf_baudrate = NRF_UARTE_BAUDRATE_1000000;
    db40:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000

__STATIC_INLINE void nrf_uarte_configure(NRF_UARTE_Type   * p_reg,
                                         nrf_uarte_parity_t parity,
                                         nrf_uarte_hwfc_t   hwfc)
{
    p_reg->CONFIG = (uint32_t)parity | (uint32_t)hwfc;
    db44:	432a      	orrs	r2, r5
}

__STATIC_INLINE void nrf_uarte_baudrate_set(NRF_UARTE_Type   * p_reg, nrf_uarte_baudrate_t baudrate)
{
    p_reg->BAUDRATE = baudrate;
    db46:	f8c4 3524 	str.w	r3, [r4, #1316]	; 0x524
    p_reg->CONFIG = (uint32_t)parity | (uint32_t)hwfc;
    db4a:	f8c4 256c 	str.w	r2, [r4, #1388]	; 0x56c
	}

	nrf_uarte_configure(get_uarte_instance(dev), parity, hwfc);

#ifdef UARTE_CONFIG_STOP_Two
	if (two_stop_bits) {
    db4e:	b12e      	cbz	r6, db5c <uarte_nrfx_configure+0x104>
		/* TODO Change this to nrfx HAL function when available */
		get_uarte_instance(dev)->CONFIG |=
    db50:	f8d4 356c 	ldr.w	r3, [r4, #1388]	; 0x56c
    db54:	f043 0310 	orr.w	r3, r3, #16
    db58:	f8c4 356c 	str.w	r3, [r4, #1388]	; 0x56c
			UARTE_CONFIG_STOP_Two << UARTE_CONFIG_STOP_Pos;
	}
#endif
	get_dev_data(dev)->uart_config = *cfg;
    db5c:	6883      	ldr	r3, [r0, #8]
    db5e:	c903      	ldmia	r1, {r0, r1}
    db60:	e883 0003 	stmia.w	r3, {r0, r1}

	return 0;
    db64:	2000      	movs	r0, #0
}
    db66:	bdf0      	pop	{r4, r5, r6, r7, pc}
		nrf_baudrate = NRF_UARTE_BAUDRATE_31250;
    db68:	f44f 0300 	mov.w	r3, #8388608	; 0x800000
    db6c:	e7ea      	b.n	db44 <uarte_nrfx_configure+0xec>
		nrf_baudrate = NRF_UARTE_BAUDRATE_4800;
    db6e:	4b15      	ldr	r3, [pc, #84]	; (dbc4 <uarte_nrfx_configure+0x16c>)
    db70:	e7e8      	b.n	db44 <uarte_nrfx_configure+0xec>
		nrf_baudrate = 0x00027000;
    db72:	f44f 331c 	mov.w	r3, #159744	; 0x27000
    db76:	e7e5      	b.n	db44 <uarte_nrfx_configure+0xec>
		nrf_baudrate = 0x00014000;
    db78:	f44f 33a0 	mov.w	r3, #81920	; 0x14000
    db7c:	e7e2      	b.n	db44 <uarte_nrfx_configure+0xec>
		nrf_baudrate = NRF_UARTE_BAUDRATE_1200;
    db7e:	f44f 239e 	mov.w	r3, #323584	; 0x4f000
    db82:	e7df      	b.n	db44 <uarte_nrfx_configure+0xec>
		nrf_baudrate = NRF_UARTE_BAUDRATE_14400;
    db84:	4b10      	ldr	r3, [pc, #64]	; (dbc8 <uarte_nrfx_configure+0x170>)
    db86:	e7dd      	b.n	db44 <uarte_nrfx_configure+0xec>
		nrf_baudrate = NRF_UARTE_BAUDRATE_19200;
    db88:	4b10      	ldr	r3, [pc, #64]	; (dbcc <uarte_nrfx_configure+0x174>)
    db8a:	e7db      	b.n	db44 <uarte_nrfx_configure+0xec>
		nrf_baudrate = NRF_UARTE_BAUDRATE_115200;
    db8c:	f04f 73eb 	mov.w	r3, #30801920	; 0x1d60000
    db90:	e7d8      	b.n	db44 <uarte_nrfx_configure+0xec>
		nrf_baudrate = NRF_UARTE_BAUDRATE_56000;
    db92:	f44f 0365 	mov.w	r3, #15007744	; 0xe50000
    db96:	e7d5      	b.n	db44 <uarte_nrfx_configure+0xec>
		nrf_baudrate = NRF_UARTE_BAUDRATE_57600;
    db98:	f44f 036b 	mov.w	r3, #15400960	; 0xeb0000
    db9c:	e7d2      	b.n	db44 <uarte_nrfx_configure+0xec>
		nrf_baudrate = NRF_UARTE_BAUDRATE_460800;
    db9e:	f04f 63e8 	mov.w	r3, #121634816	; 0x7400000
    dba2:	e7cf      	b.n	db44 <uarte_nrfx_configure+0xec>
		nrf_baudrate = NRF_UARTE_BAUDRATE_230400;
    dba4:	f04f 736c 	mov.w	r3, #61865984	; 0x3b00000
    dba8:	e7cc      	b.n	db44 <uarte_nrfx_configure+0xec>
		nrf_baudrate = NRF_UARTE_BAUDRATE_921600;
    dbaa:	f04f 6370 	mov.w	r3, #251658240	; 0xf000000
    dbae:	e7c9      	b.n	db44 <uarte_nrfx_configure+0xec>
    dbb0:	00275000 	.word	0x00275000
    dbb4:	0075c000 	.word	0x0075c000
    dbb8:	013a9000 	.word	0x013a9000
    dbbc:	0003d090 	.word	0x0003d090
    dbc0:	000f4240 	.word	0x000f4240
    dbc4:	0013b000 	.word	0x0013b000
    dbc8:	003af000 	.word	0x003af000
    dbcc:	004ea000 	.word	0x004ea000

0000dbd0 <uarte_0_init>:
	return dev->config->config_info;
    dbd0:	6802      	ldr	r2, [r0, #0]
	#if defined(DT_NORDIC_NRF_UARTE_UART_0_RTS_PIN) && \
	    defined(DT_NORDIC_NRF_UARTE_UART_0_CTS_PIN)
		#define UARTE_0_CONFIG_RTS_CTS 1
	#endif

	UART_NRF_UARTE_DEVICE(0);
    dbd2:	b570      	push	{r4, r5, r6, lr}
	return config->uarte_regs;
    dbd4:	6892      	ldr	r2, [r2, #8]
}


__STATIC_INLINE void nrf_gpio_port_out_set(NRF_GPIO_Type * p_reg, uint32_t set_mask)
{
    p_reg->OUTSET = set_mask;
    dbd6:	4b18      	ldr	r3, [pc, #96]	; (dc38 <uarte_0_init+0x68>)
    dbd8:	6814      	ldr	r4, [r2, #0]
    dbda:	f04f 5200 	mov.w	r2, #536870912	; 0x20000000
	struct uarte_nrfx_data *data = get_dev_data(dev);
    dbde:	6885      	ldr	r5, [r0, #8]
    reg->PIN_CNF[pin_number] = ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)
    dbe0:	2103      	movs	r1, #3
    p_reg->OUTSET = set_mask;
    dbe2:	609a      	str	r2, [r3, #8]
    p_reg->PSEL.TXD = pseltxd;
    dbe4:	261d      	movs	r6, #29
    reg->PIN_CNF[pin_number] = ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)
    dbe6:	2200      	movs	r2, #0
    dbe8:	f8c3 1274 	str.w	r1, [r3, #628]	; 0x274
    dbec:	f8c3 2270 	str.w	r2, [r3, #624]	; 0x270
    dbf0:	f8c4 650c 	str.w	r6, [r4, #1292]	; 0x50c
    p_reg->PSEL.RXD = pselrxd;
    dbf4:	261c      	movs	r6, #28
    dbf6:	f8c4 6514 	str.w	r6, [r4, #1300]	; 0x514
    p_reg->OUTSET = set_mask;
    dbfa:	f04f 6600 	mov.w	r6, #134217728	; 0x8000000
    dbfe:	609e      	str	r6, [r3, #8]
    reg->PIN_CNF[pin_number] = ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)
    dc00:	f8c3 126c 	str.w	r1, [r3, #620]	; 0x26c
    dc04:	f8c3 2268 	str.w	r2, [r3, #616]	; 0x268
    p_reg->PSEL.RTS = pselrts;
    dc08:	231b      	movs	r3, #27
    dc0a:	f8c4 3508 	str.w	r3, [r4, #1288]	; 0x508
    p_reg->PSEL.CTS = pselcts;
    dc0e:	231a      	movs	r3, #26
	err = uarte_nrfx_configure(dev, &get_dev_data(dev)->uart_config);
    dc10:	4629      	mov	r1, r5
    dc12:	f8c4 3510 	str.w	r3, [r4, #1296]	; 0x510
    dc16:	f7ff ff1f 	bl	da58 <uarte_nrfx_configure>
	if (err) {
    dc1a:	b958      	cbnz	r0, dc34 <uarte_0_init+0x64>
    p_reg->ENABLE = UARTE_ENABLE_ENABLE_Enabled;
    dc1c:	2308      	movs	r3, #8
    dc1e:	f8c4 3500 	str.w	r3, [r4, #1280]	; 0x500
	nrf_uarte_rx_buffer_set(uarte, &data->rx_data, 1);
    dc22:	441d      	add	r5, r3
__STATIC_INLINE void nrf_uarte_rx_buffer_set(NRF_UARTE_Type * p_reg,
                                             uint8_t *        p_buffer,
                                             size_t           length)
{
    p_reg->RXD.PTR    = (uint32_t)p_buffer;
    p_reg->RXD.MAXCNT = length;
    dc24:	2301      	movs	r3, #1
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    dc26:	f8c4 0110 	str.w	r0, [r4, #272]	; 0x110
    p_reg->RXD.PTR    = (uint32_t)p_buffer;
    dc2a:	f8c4 5534 	str.w	r5, [r4, #1332]	; 0x534
    p_reg->RXD.MAXCNT = length;
    dc2e:	f8c4 3538 	str.w	r3, [r4, #1336]	; 0x538
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    dc32:	6023      	str	r3, [r4, #0]
	UART_NRF_UARTE_DEVICE(0);
    dc34:	bd70      	pop	{r4, r5, r6, pc}
    dc36:	bf00      	nop
    dc38:	50842500 	.word	0x50842500

0000dc3c <abi_getter>:
extern const struct fw_info_abi * const _ext_abis_start[];
extern const u32_t _ext_abis_size;
__noinit fw_info_abi_getter abi_getter_in;

int abi_getter(u32_t id, u32_t index, const struct fw_info_abi **abi)
{
    dc3c:	b5f0      	push	{r4, r5, r6, r7, lr}
	if (!abi) {
    dc3e:	b1da      	cbz	r2, dc78 <abi_getter+0x3c>
		return -EFAULT;
	}

	bool id_found = false;

	for (u32_t i = 0; i < (u32_t)&_ext_abis_size; i++) {
    dc40:	2300      	movs	r3, #0
	bool id_found = false;
    dc42:	461c      	mov	r4, r3
    dc44:	4d0e      	ldr	r5, [pc, #56]	; (dc80 <abi_getter+0x44>)
	for (u32_t i = 0; i < (u32_t)&_ext_abis_size; i++) {
    dc46:	4f0f      	ldr	r7, [pc, #60]	; (dc84 <abi_getter+0x48>)
    dc48:	42bb      	cmp	r3, r7
    dc4a:	d306      	bcc.n	dc5a <abi_getter+0x1e>
				*abi = ext_abi;
				return 0;
			}
		}
	}
	return id_found ? -EBADF : -ENOENT;
    dc4c:	2c00      	cmp	r4, #0
    dc4e:	bf14      	ite	ne
    dc50:	f06f 0008 	mvnne.w	r0, #8
    dc54:	f06f 0001 	mvneq.w	r0, #1
    dc58:	e009      	b.n	dc6e <abi_getter+0x32>
		const struct fw_info_abi *ext_abi = _ext_abis_start[i];
    dc5a:	f855 6b04 	ldr.w	r6, [r5], #4
		if (ext_abi->abi_id == id) {
    dc5e:	f8d6 c00c 	ldr.w	ip, [r6, #12]
    dc62:	4560      	cmp	r0, ip
    dc64:	d106      	bne.n	dc74 <abi_getter+0x38>
			if (index-- == 0) {
    dc66:	1e4c      	subs	r4, r1, #1
    dc68:	b911      	cbnz	r1, dc70 <abi_getter+0x34>
				return 0;
    dc6a:	4608      	mov	r0, r1
				*abi = ext_abi;
    dc6c:	6016      	str	r6, [r2, #0]
}
    dc6e:	bdf0      	pop	{r4, r5, r6, r7, pc}
			if (index-- == 0) {
    dc70:	4621      	mov	r1, r4
			id_found = true;
    dc72:	2401      	movs	r4, #1
	for (u32_t i = 0; i < (u32_t)&_ext_abis_size; i++) {
    dc74:	3301      	adds	r3, #1
    dc76:	e7e7      	b.n	dc48 <abi_getter+0xc>
		return -EFAULT;
    dc78:	f06f 000d 	mvn.w	r0, #13
    dc7c:	e7f7      	b.n	dc6e <abi_getter+0x32>
    dc7e:	bf00      	nop
    dc80:	00010c18 	.word	0x00010c18
    dc84:	00000000 	.word	0x00000000

0000dc88 <SystemInit>:
        /* Perform Secure-mode initialization routines. */

        /* Set all ARM SAU regions to NonSecure if TrustZone extensions are enabled.
        * Nordic SPU should handle Secure Attribution tasks */
        #if defined (__ARM_FEATURE_CMSE) && (__ARM_FEATURE_CMSE == 3U)
          SAU->CTRL |= (1 << SAU_CTRL_ALLNS_Pos);
    dc88:	4a4f      	ldr	r2, [pc, #316]	; (ddc8 <SystemInit+0x140>)
    dc8a:	6813      	ldr	r3, [r2, #0]
    dc8c:	f043 0302 	orr.w	r3, r3, #2
    dc90:	6013      	str	r3, [r2, #0]
        #endif

        /* Trimming of the device. Copy all the trimming values from FICR into the target addresses. Trim 
         until one ADDR is not initialized. */
        uint32_t index = 0;
        for (index = 0; index < 256ul && NRF_FICR_S->TRIMCNF[index].ADDR != 0xFFFFFFFFul; index++){
    dc92:	2200      	movs	r2, #0
    dc94:	00d3      	lsls	r3, r2, #3
    dc96:	f503 037f 	add.w	r3, r3, #16711680	; 0xff0000
    dc9a:	f8d3 1300 	ldr.w	r1, [r3, #768]	; 0x300
    dc9e:	3101      	adds	r1, #1
    dca0:	d008      	beq.n	dcb4 <SystemInit+0x2c>
          #if defined ( __ICCARM__ )
              #pragma diag_suppress=Pa082
          #endif
          *(volatile uint32_t *)NRF_FICR_S->TRIMCNF[index].ADDR = NRF_FICR_S->TRIMCNF[index].DATA;
    dca2:	f8d3 1300 	ldr.w	r1, [r3, #768]	; 0x300
        for (index = 0; index < 256ul && NRF_FICR_S->TRIMCNF[index].ADDR != 0xFFFFFFFFul; index++){
    dca6:	3201      	adds	r2, #1
          *(volatile uint32_t *)NRF_FICR_S->TRIMCNF[index].ADDR = NRF_FICR_S->TRIMCNF[index].DATA;
    dca8:	f8d3 3304 	ldr.w	r3, [r3, #772]	; 0x304
        for (index = 0; index < 256ul && NRF_FICR_S->TRIMCNF[index].ADDR != 0xFFFFFFFFul; index++){
    dcac:	f5b2 7f80 	cmp.w	r2, #256	; 0x100
          *(volatile uint32_t *)NRF_FICR_S->TRIMCNF[index].ADDR = NRF_FICR_S->TRIMCNF[index].DATA;
    dcb0:	600b      	str	r3, [r1, #0]
        for (index = 0; index < 256ul && NRF_FICR_S->TRIMCNF[index].ADDR != 0xFFFFFFFFul; index++){
    dcb2:	d1ef      	bne.n	dc94 <SystemInit+0xc>
    }
    
    
    bool uicr_HFXOSRC_erased()
    {
        if ((NRF_UICR_S->HFXOSRC & UICR_HFXOSRC_HFXOSRC_Msk) != UICR_HFXOSRC_HFXOSRC_TCXO) {
    dcb4:	4a45      	ldr	r2, [pc, #276]	; (ddcc <SystemInit+0x144>)
    dcb6:	69d3      	ldr	r3, [r2, #28]
    dcb8:	f013 0301 	ands.w	r3, r3, #1
    dcbc:	d03b      	beq.n	dd36 <SystemInit+0xae>
          while (NRF_NVMC_S->READY != NVMC_READY_READY_Ready);
    dcbe:	4b44      	ldr	r3, [pc, #272]	; (ddd0 <SystemInit+0x148>)
    dcc0:	4619      	mov	r1, r3
    dcc2:	f8d3 2400 	ldr.w	r2, [r3, #1024]	; 0x400
    dcc6:	2a01      	cmp	r2, #1
    dcc8:	d1fb      	bne.n	dcc2 <SystemInit+0x3a>
          NRF_NVMC_S->CONFIG = NVMC_CONFIG_WEN_Wen;
    dcca:	f8c3 2504 	str.w	r2, [r3, #1284]	; 0x504
          while (NRF_NVMC_S->READY != NVMC_READY_READY_Ready);
    dcce:	f8d1 3400 	ldr.w	r3, [r1, #1024]	; 0x400
    dcd2:	2b01      	cmp	r3, #1
    dcd4:	d1fb      	bne.n	dcce <SystemInit+0x46>
        if ((NRF_UICR_S->HFXOSRC & UICR_HFXOSRC_HFXOSRC_Msk) != UICR_HFXOSRC_HFXOSRC_TCXO) {
    dcd6:	4b3d      	ldr	r3, [pc, #244]	; (ddcc <SystemInit+0x144>)
    dcd8:	69da      	ldr	r2, [r3, #28]
    dcda:	07d2      	lsls	r2, r2, #31
    dcdc:	d508      	bpl.n	dcf0 <SystemInit+0x68>
            NRF_UICR_S->HFXOSRC = (NRF_UICR_S->HFXOSRC & ~UICR_HFXOSRC_HFXOSRC_Msk) | UICR_HFXOSRC_HFXOSRC_TCXO;
    dcde:	69da      	ldr	r2, [r3, #28]
            while (NRF_NVMC_S->READY != NVMC_READY_READY_Ready);
    dce0:	493b      	ldr	r1, [pc, #236]	; (ddd0 <SystemInit+0x148>)
            NRF_UICR_S->HFXOSRC = (NRF_UICR_S->HFXOSRC & ~UICR_HFXOSRC_HFXOSRC_Msk) | UICR_HFXOSRC_HFXOSRC_TCXO;
    dce2:	f022 0201 	bic.w	r2, r2, #1
    dce6:	61da      	str	r2, [r3, #28]
            while (NRF_NVMC_S->READY != NVMC_READY_READY_Ready);
    dce8:	f8d1 2400 	ldr.w	r2, [r1, #1024]	; 0x400
    dcec:	2a01      	cmp	r2, #1
    dcee:	d1fb      	bne.n	dce8 <SystemInit+0x60>
        if (NRF_UICR_S->HFXOCNT == 0xFFFFFFFFul) {
    dcf0:	6a1a      	ldr	r2, [r3, #32]
    dcf2:	3201      	adds	r2, #1
    dcf4:	d10a      	bne.n	dd0c <SystemInit+0x84>
            NRF_UICR_S->HFXOCNT = (NRF_UICR_S->HFXOCNT & ~UICR_HFXOCNT_HFXOCNT_Msk) | 0x20;
    dcf6:	6a1a      	ldr	r2, [r3, #32]
    dcf8:	f022 02ff 	bic.w	r2, r2, #255	; 0xff
    dcfc:	f042 0220 	orr.w	r2, r2, #32
    dd00:	621a      	str	r2, [r3, #32]
            while (NRF_NVMC_S->READY != NVMC_READY_READY_Ready);
    dd02:	4a33      	ldr	r2, [pc, #204]	; (ddd0 <SystemInit+0x148>)
    dd04:	f8d2 3400 	ldr.w	r3, [r2, #1024]	; 0x400
    dd08:	2b01      	cmp	r3, #1
    dd0a:	d1fb      	bne.n	dd04 <SystemInit+0x7c>
          NRF_NVMC_S->CONFIG = NVMC_CONFIG_WEN_Ren;
    dd0c:	2200      	movs	r2, #0
    dd0e:	4b30      	ldr	r3, [pc, #192]	; (ddd0 <SystemInit+0x148>)
    dd10:	f8c3 2504 	str.w	r2, [r3, #1284]	; 0x504
          while (NRF_NVMC_S->READY != NVMC_READY_READY_Ready);
    dd14:	f8d3 2400 	ldr.w	r2, [r3, #1024]	; 0x400
    dd18:	2a01      	cmp	r2, #1
    dd1a:	d1fb      	bne.n	dd14 <SystemInit+0x8c>
  __ASM volatile ("dsb 0xF":::"memory");
    dd1c:	f3bf 8f4f 	dsb	sy
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
    dd20:	492c      	ldr	r1, [pc, #176]	; (ddd4 <SystemInit+0x14c>)
    dd22:	4b2d      	ldr	r3, [pc, #180]	; (ddd8 <SystemInit+0x150>)
    dd24:	68ca      	ldr	r2, [r1, #12]
    dd26:	f402 62e0 	and.w	r2, r2, #1792	; 0x700
    dd2a:	4313      	orrs	r3, r2
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
    dd2c:	60cb      	str	r3, [r1, #12]
    dd2e:	f3bf 8f4f 	dsb	sy
    __NOP();
    dd32:	bf00      	nop
    dd34:	e7fd      	b.n	dd32 <SystemInit+0xaa>
        if (NRF_UICR_S->HFXOCNT == 0xFFFFFFFFul) {
    dd36:	6a12      	ldr	r2, [r2, #32]
    dd38:	3201      	adds	r2, #1
    dd3a:	d0c0      	beq.n	dcbe <SystemInit+0x36>
    }
    

    bool errata_6()
    {
        if (*(uint32_t *)0x00FF0130 == 0x9ul){
    dd3c:	4a27      	ldr	r2, [pc, #156]	; (dddc <SystemInit+0x154>)
    dd3e:	6812      	ldr	r2, [r2, #0]
    dd40:	2a09      	cmp	r2, #9
    dd42:	d111      	bne.n	dd68 <SystemInit+0xe0>
            if (*(uint32_t *)0x00FF0134 == 0x01ul){
    dd44:	4a26      	ldr	r2, [pc, #152]	; (dde0 <SystemInit+0x158>)
    dd46:	6811      	ldr	r1, [r2, #0]
    dd48:	3901      	subs	r1, #1
    dd4a:	2901      	cmp	r1, #1
    dd4c:	d921      	bls.n	dd92 <SystemInit+0x10a>

    
    bool errata_14()
    {
        if (*(uint32_t *)0x00FF0130 == 0x9ul){
            if (*(uint32_t *)0x00FF0134 == 0x01ul){
    dd4e:	6813      	ldr	r3, [r2, #0]
    dd50:	2b01      	cmp	r3, #1
    dd52:	d125      	bne.n	dda0 <SystemInit+0x118>
            *((volatile uint32_t *)0x50004A38) = 0x01ul;
    dd54:	4a23      	ldr	r2, [pc, #140]	; (dde4 <SystemInit+0x15c>)
    dd56:	6013      	str	r3, [r2, #0]
            NRF_REGULATORS_S->DCDCEN = REGULATORS_DCDCEN_DCDCEN_Enabled << REGULATORS_DCDCEN_DCDCEN_Pos;
    dd58:	f6a2 2238 	subw	r2, r2, #2616	; 0xa38
    dd5c:	f8c2 3578 	str.w	r3, [r2, #1400]	; 0x578
    }


    bool errata_15()
    {
        if (*(uint32_t *)0x00FF0130 == 0x9ul){
    dd60:	4b1e      	ldr	r3, [pc, #120]	; (dddc <SystemInit+0x154>)
    dd62:	681b      	ldr	r3, [r3, #0]
    dd64:	2b09      	cmp	r3, #9
    dd66:	d01b      	beq.n	dda0 <SystemInit+0x118>
        SCB->NSACR |= (3UL << 10);
    dd68:	4b1a      	ldr	r3, [pc, #104]	; (ddd4 <SystemInit+0x14c>)
    dd6a:	f8d3 208c 	ldr.w	r2, [r3, #140]	; 0x8c
    dd6e:	f442 6240 	orr.w	r2, r2, #3072	; 0xc00
    dd72:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
      SCB->CPACR |= (3UL << 20) | (3UL << 22);
    dd76:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
    dd7a:	f442 0270 	orr.w	r2, r2, #15728640	; 0xf00000
    dd7e:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
    dd82:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    dd86:	f3bf 8f6f 	isb	sy
    SystemCoreClock = __SYSTEM_CLOCK;
    dd8a:	4b17      	ldr	r3, [pc, #92]	; (dde8 <SystemInit+0x160>)
    dd8c:	4a17      	ldr	r2, [pc, #92]	; (ddec <SystemInit+0x164>)
    dd8e:	601a      	str	r2, [r3, #0]
}
    dd90:	4770      	bx	lr
            NRF_POWER_S->EVENTS_SLEEPENTER = (POWER_EVENTS_SLEEPENTER_EVENTS_SLEEPENTER_NotGenerated << POWER_EVENTS_SLEEPENTER_EVENTS_SLEEPENTER_Pos);
    dd92:	f04f 2150 	mov.w	r1, #1342197760	; 0x50005000
    dd96:	f8c1 3114 	str.w	r3, [r1, #276]	; 0x114
            NRF_POWER_S->EVENTS_SLEEPEXIT = (POWER_EVENTS_SLEEPEXIT_EVENTS_SLEEPEXIT_NotGenerated << POWER_EVENTS_SLEEPEXIT_EVENTS_SLEEPEXIT_Pos);
    dd9a:	f8c1 3118 	str.w	r3, [r1, #280]	; 0x118
        if (*(uint32_t *)0x00FF0130 == 0x9ul){
    dd9e:	e7d6      	b.n	dd4e <SystemInit+0xc6>
            if (*(uint32_t *)0x00FF0134 == 0x02ul){
    dda0:	4b0f      	ldr	r3, [pc, #60]	; (dde0 <SystemInit+0x158>)
    dda2:	681b      	ldr	r3, [r3, #0]
    dda4:	2b02      	cmp	r3, #2
    dda6:	d1df      	bne.n	dd68 <SystemInit+0xe0>
            *((volatile uint32_t *)0x50004A38) = 0x00ul;
    dda8:	2200      	movs	r2, #0
    ddaa:	4b0e      	ldr	r3, [pc, #56]	; (dde4 <SystemInit+0x15c>)
    ddac:	601a      	str	r2, [r3, #0]
            NRF_REGULATORS_S->DCDCEN = REGULATORS_DCDCEN_DCDCEN_Enabled << REGULATORS_DCDCEN_DCDCEN_Pos;
    ddae:	2201      	movs	r2, #1
    ddb0:	f6a3 2338 	subw	r3, r3, #2616	; 0xa38
    ddb4:	f8c3 2578 	str.w	r2, [r3, #1400]	; 0x578
        if (*(uint32_t *)0x00FF0130 == 0x9ul){
    ddb8:	4b08      	ldr	r3, [pc, #32]	; (dddc <SystemInit+0x154>)
    ddba:	681b      	ldr	r3, [r3, #0]
    ddbc:	2b09      	cmp	r3, #9
    ddbe:	d1d3      	bne.n	dd68 <SystemInit+0xe0>
            *((volatile uint32_t *)0x5003AEE4) = 0xC;
    ddc0:	220c      	movs	r2, #12
    ddc2:	4b0b      	ldr	r3, [pc, #44]	; (ddf0 <SystemInit+0x168>)
    ddc4:	601a      	str	r2, [r3, #0]
    ddc6:	e7cf      	b.n	dd68 <SystemInit+0xe0>
    ddc8:	e000edd0 	.word	0xe000edd0
    ddcc:	00ff8000 	.word	0x00ff8000
    ddd0:	50039000 	.word	0x50039000
    ddd4:	e000ed00 	.word	0xe000ed00
    ddd8:	05fa0004 	.word	0x05fa0004
    dddc:	00ff0130 	.word	0x00ff0130
    dde0:	00ff0134 	.word	0x00ff0134
    dde4:	50004a38 	.word	0x50004a38
    dde8:	20001408 	.word	0x20001408
    ddec:	03d09000 	.word	0x03d09000
    ddf0:	5003aee4 	.word	0x5003aee4

0000ddf4 <z_sys_device_do_config_level>:
 * off and the next one begins.
 *
 * @param level init level to run.
 */
void z_sys_device_do_config_level(s32_t level)
{
    ddf4:	b570      	push	{r4, r5, r6, lr}
		retval = device_conf->init(info);
		if (retval != 0) {
			/* Initialization failed. Clear the API struct so that
			 * device_get_binding() will not succeed for it.
			 */
			info->driver_api = NULL;
    ddf6:	2600      	movs	r6, #0
	for (info = config_levels[level]; info < config_levels[level+1];
    ddf8:	4b08      	ldr	r3, [pc, #32]	; (de1c <z_sys_device_do_config_level+0x28>)
    ddfa:	f853 4020 	ldr.w	r4, [r3, r0, lsl #2]
    ddfe:	3001      	adds	r0, #1
    de00:	f853 5020 	ldr.w	r5, [r3, r0, lsl #2]
    de04:	42a5      	cmp	r5, r4
    de06:	d800      	bhi.n	de0a <z_sys_device_do_config_level+0x16>
		} else {
			z_object_init(info);
		}
	}
}
    de08:	bd70      	pop	{r4, r5, r6, pc}
		retval = device_conf->init(info);
    de0a:	6823      	ldr	r3, [r4, #0]
    de0c:	4620      	mov	r0, r4
    de0e:	685b      	ldr	r3, [r3, #4]
    de10:	4798      	blx	r3
		if (retval != 0) {
    de12:	b100      	cbz	r0, de16 <z_sys_device_do_config_level+0x22>
			info->driver_api = NULL;
    de14:	6066      	str	r6, [r4, #4]
								info++) {
    de16:	340c      	adds	r4, #12
    de18:	e7f4      	b.n	de04 <z_sys_device_do_config_level+0x10>
    de1a:	bf00      	nop
    de1c:	00010780 	.word	0x00010780

0000de20 <z_impl_device_get_binding>:
	/* Split the search into two loops: in the common scenario, where
	 * device names are stored in ROM (and are referenced by the user
	 * with CONFIG_* macros), only cheap pointer comparisons will be
	 * performed.  Reserve string comparisons for a fallback.
	 */
	for (info = __device_init_start; info != __device_init_end; info++) {
    de20:	4b10      	ldr	r3, [pc, #64]	; (de64 <z_impl_device_get_binding+0x44>)
{
    de22:	b570      	push	{r4, r5, r6, lr}
    de24:	4605      	mov	r5, r0
    de26:	461e      	mov	r6, r3
	for (info = __device_init_start; info != __device_init_end; info++) {
    de28:	4c0f      	ldr	r4, [pc, #60]	; (de68 <z_impl_device_get_binding+0x48>)
    de2a:	429c      	cmp	r4, r3
    de2c:	d104      	bne.n	de38 <z_impl_device_get_binding+0x18>
		    (info->config->name == name)) {
			return info;
		}
	}

	for (info = __device_init_start; info != __device_init_end; info++) {
    de2e:	4c0e      	ldr	r4, [pc, #56]	; (de68 <z_impl_device_get_binding+0x48>)
    de30:	42b4      	cmp	r4, r6
    de32:	d109      	bne.n	de48 <z_impl_device_get_binding+0x28>
		if (strcmp(name, info->config->name) == 0) {
			return info;
		}
	}

	return NULL;
    de34:	2400      	movs	r4, #0
    de36:	e012      	b.n	de5e <z_impl_device_get_binding+0x3e>
		if ((info->driver_api != NULL) &&
    de38:	6862      	ldr	r2, [r4, #4]
    de3a:	b11a      	cbz	r2, de44 <z_impl_device_get_binding+0x24>
		    (info->config->name == name)) {
    de3c:	6822      	ldr	r2, [r4, #0]
		if ((info->driver_api != NULL) &&
    de3e:	6812      	ldr	r2, [r2, #0]
    de40:	42aa      	cmp	r2, r5
    de42:	d00c      	beq.n	de5e <z_impl_device_get_binding+0x3e>
	for (info = __device_init_start; info != __device_init_end; info++) {
    de44:	340c      	adds	r4, #12
    de46:	e7f0      	b.n	de2a <z_impl_device_get_binding+0xa>
		if (info->driver_api == NULL) {
    de48:	6863      	ldr	r3, [r4, #4]
    de4a:	b90b      	cbnz	r3, de50 <z_impl_device_get_binding+0x30>
	for (info = __device_init_start; info != __device_init_end; info++) {
    de4c:	340c      	adds	r4, #12
    de4e:	e7ef      	b.n	de30 <z_impl_device_get_binding+0x10>
		if (strcmp(name, info->config->name) == 0) {
    de50:	6823      	ldr	r3, [r4, #0]
    de52:	4628      	mov	r0, r5
    de54:	6819      	ldr	r1, [r3, #0]
    de56:	f001 fffc 	bl	fe52 <strcmp>
    de5a:	2800      	cmp	r0, #0
    de5c:	d1f6      	bne.n	de4c <z_impl_device_get_binding+0x2c>
}
    de5e:	4620      	mov	r0, r4
    de60:	bd70      	pop	{r4, r5, r6, pc}
    de62:	bf00      	nop
    de64:	200014d8 	.word	0x200014d8
    de68:	20001454 	.word	0x20001454

0000de6c <idle>:
#else
#define IDLE_YIELD_IF_COOP() do { } while (false)
#endif

void idle(void *unused1, void *unused2, void *unused3)
{
    de6c:	b508      	push	{r3, lr}
	_kernel.idle = ticks;
    de6e:	4d0b      	ldr	r5, [pc, #44]	; (de9c <idle+0x30>)
    de70:	f04f 0220 	mov.w	r2, #32
    de74:	f3ef 8311 	mrs	r3, BASEPRI
    de78:	f382 8811 	msr	BASEPRI, r2
    de7c:	f3bf 8f6f 	isb	sy
	s32_t ticks = z_get_next_timeout_expiry();
    de80:	f002 f9cb 	bl	1021a <z_get_next_timeout_expiry>
	z_set_timeout_expiry((ticks < IDLE_THRESH) ? 1 : ticks, true);
    de84:	2101      	movs	r1, #1
	s32_t ticks = z_get_next_timeout_expiry();
    de86:	4604      	mov	r4, r0
	z_set_timeout_expiry((ticks < IDLE_THRESH) ? 1 : ticks, true);
    de88:	2802      	cmp	r0, #2
    de8a:	bfd8      	it	le
    de8c:	4608      	movle	r0, r1
    de8e:	f002 f9d4 	bl	1023a <z_set_timeout_expiry>
	_kernel.idle = ticks;
    de92:	622c      	str	r4, [r5, #32]
 * @return N/A
 * @req K-CPU-IDLE-001
 */
static inline void k_cpu_idle(void)
{
	z_arch_cpu_idle();
    de94:	f7ff fab8 	bl	d408 <z_arch_cpu_idle>
    de98:	e7ea      	b.n	de70 <idle+0x4>
    de9a:	bf00      	nop
    de9c:	20000630 	.word	0x20000630

0000dea0 <z_bss_zero>:
 *
 * @return N/A
 */
void z_bss_zero(void)
{
	(void)memset(__bss_start, 0, __bss_end - __bss_start);
    dea0:	4802      	ldr	r0, [pc, #8]	; (deac <z_bss_zero+0xc>)
    dea2:	4a03      	ldr	r2, [pc, #12]	; (deb0 <z_bss_zero+0x10>)
    dea4:	2100      	movs	r1, #0
    dea6:	1a12      	subs	r2, r2, r0
    dea8:	f002 b820 	b.w	feec <memset>
    deac:	20000000 	.word	0x20000000
    deb0:	20000690 	.word	0x20000690

0000deb4 <z_data_copy>:
 * This routine copies the data section from ROM to RAM.
 *
 * @return N/A
 */
void z_data_copy(void)
{
    deb4:	b508      	push	{r3, lr}
	(void)memcpy(&__data_ram_start, &__data_rom_start,
		 __data_ram_end - __data_ram_start);
    deb6:	4806      	ldr	r0, [pc, #24]	; (ded0 <z_data_copy+0x1c>)
	(void)memcpy(&__data_ram_start, &__data_rom_start,
    deb8:	4a06      	ldr	r2, [pc, #24]	; (ded4 <z_data_copy+0x20>)
    deba:	4907      	ldr	r1, [pc, #28]	; (ded8 <z_data_copy+0x24>)
    debc:	1a12      	subs	r2, r2, r0
    debe:	f001 ffeb 	bl	fe98 <memcpy>
#else
	(void)memcpy(&_app_smem_start, &_app_smem_rom_start,
		 _app_smem_end - _app_smem_start);
#endif /* CONFIG_STACK_CANARIES */
#endif /* CONFIG_USERSPACE */
}
    dec2:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	(void)memcpy(&_ramfunc_ram_start, &_ramfunc_rom_start,
    dec6:	4a05      	ldr	r2, [pc, #20]	; (dedc <z_data_copy+0x28>)
    dec8:	4905      	ldr	r1, [pc, #20]	; (dee0 <z_data_copy+0x2c>)
    deca:	4806      	ldr	r0, [pc, #24]	; (dee4 <z_data_copy+0x30>)
    decc:	f001 bfe4 	b.w	fe98 <memcpy>
    ded0:	200013d4 	.word	0x200013d4
    ded4:	2000153c 	.word	0x2000153c
    ded8:	00010c18 	.word	0x00010c18
    dedc:	00000000 	.word	0x00000000
    dee0:	00010c18 	.word	0x00010c18
    dee4:	20000000 	.word	0x20000000

0000dee8 <bg_thread_main>:
 * init functions, then invokes application's main() routine.
 *
 * @return N/A
 */
static void bg_thread_main(void *unused1, void *unused2, void *unused3)
{
    dee8:	b508      	push	{r3, lr}
	static const unsigned int boot_delay = CONFIG_BOOT_DELAY;
#else
	static const unsigned int boot_delay;
#endif

	z_sys_device_do_config_level(_SYS_INIT_LEVEL_POST_KERNEL);
    deea:	2002      	movs	r0, #2
    deec:	f7ff ff82 	bl	ddf4 <z_sys_device_do_config_level>
	if (boot_delay > 0 && IS_ENABLED(CONFIG_MULTITHREADING)) {
		printk("***** delaying boot " STRINGIFY(CONFIG_BOOT_DELAY)
		       "ms (per build configuration) *****\n");
		k_busy_wait(CONFIG_BOOT_DELAY * USEC_PER_MSEC);
	}
	PRINT_BOOT_BANNER();
    def0:	4807      	ldr	r0, [pc, #28]	; (df10 <bg_thread_main+0x28>)
    def2:	f001 fe2b 	bl	fb4c <printk>

	/* Final init level before app starts */
	z_sys_device_do_config_level(_SYS_INIT_LEVEL_APPLICATION);
    def6:	2003      	movs	r0, #3
    def8:	f7ff ff7c 	bl	ddf4 <z_sys_device_do_config_level>
	extern void __do_init_array_aux(void);
	__do_global_ctors_aux();
	__do_init_array_aux();
#endif

	z_init_static_threads();
    defc:	f000 fc2e 	bl	e75c <z_init_static_threads>
	z_timestamp_main = k_cycle_get_32();
#endif

	extern void main(void);

	main();
    df00:	f001 fc44 	bl	f78c <main>

	/* Mark nonessenrial since main() has no more work to do */
	z_main_thread.base.user_options &= ~K_ESSENTIAL;
    df04:	4a03      	ldr	r2, [pc, #12]	; (df14 <bg_thread_main+0x2c>)
    df06:	7b13      	ldrb	r3, [r2, #12]
    df08:	f023 0301 	bic.w	r3, r3, #1
    df0c:	7313      	strb	r3, [r2, #12]

	/* Dump coverage data once the main() has exited. */
	gcov_coverage_dump();
} /* LCOV_EXCL_LINE ... because we just dumped final coverage data */
    df0e:	bd08      	pop	{r3, pc}
    df10:	00010bc6 	.word	0x00010bc6
    df14:	200005c4 	.word	0x200005c4

0000df18 <z_cstart>:
 * cleared/zeroed.
 *
 * @return Does not return
 */
FUNC_NORETURN void z_cstart(void)
{
    df18:	b580      	push	{r7, lr}
 *
 * @return N/A
 */
static ALWAYS_INLINE void z_arm_interrupt_stack_setup(void)
{
	u32_t msp = (u32_t)(Z_THREAD_STACK_BUFFER(_interrupt_stack)) +
    df1a:	4b37      	ldr	r3, [pc, #220]	; (dff8 <z_cstart+0xe0>)
    df1c:	b0a2      	sub	sp, #136	; 0x88
  __ASM volatile ("MSR msp, %0" : : "r" (topOfMainStack) : );
    df1e:	f383 8808 	msr	MSP, r3
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
    df22:	2500      	movs	r5, #0
    df24:	23e0      	movs	r3, #224	; 0xe0
    df26:	4c35      	ldr	r4, [pc, #212]	; (dffc <z_cstart+0xe4>)

	/* perform any architecture-specific initialization */
	z_arch_kernel_init();

#ifdef CONFIG_MULTITHREADING
	struct k_thread dummy_thread = {
    df28:	2701      	movs	r7, #1
    df2a:	f884 3022 	strb.w	r3, [r4, #34]	; 0x22
    df2e:	77e5      	strb	r5, [r4, #31]
    df30:	7625      	strb	r5, [r4, #24]
    df32:	7665      	strb	r5, [r4, #25]
    df34:	76a5      	strb	r5, [r4, #26]
    df36:	76e5      	strb	r5, [r4, #27]
#if defined(CONFIG_ARM_SECURE_FIRMWARE)
	NVIC_SetPriority(SecureFault_IRQn, _EXC_FAULT_PRIO);
#endif /* CONFIG_ARM_SECURE_FIRMWARE */

	/* Enable Usage, Mem, & Bus Faults */
	SCB->SHCSR |= SCB_SHCSR_USGFAULTENA_Msk | SCB_SHCSR_MEMFAULTENA_Msk |
    df38:	6a63      	ldr	r3, [r4, #36]	; 0x24
	_kernel.ready_q.cache = &z_main_thread;
    df3a:	4e31      	ldr	r6, [pc, #196]	; (e000 <z_cstart+0xe8>)
    df3c:	f443 23e0 	orr.w	r3, r3, #458752	; 0x70000
    df40:	6263      	str	r3, [r4, #36]	; 0x24
		      SCB_SHCSR_BUSFAULTENA_Msk;
#if defined(CONFIG_ARM_SECURE_FIRMWARE)
	/* Enable Secure Fault */
	SCB->SHCSR |= SCB_SHCSR_SECUREFAULTENA_Msk;
    df42:	6a63      	ldr	r3, [r4, #36]	; 0x24
    df44:	f443 2300 	orr.w	r3, r3, #524288	; 0x80000
    df48:	6263      	str	r3, [r4, #36]	; 0x24
	/* Clear BFAR before setting BusFaults to target Non-Secure state. */
	SCB->BFAR = 0;
    df4a:	63a5      	str	r5, [r4, #56]	; 0x38

static ALWAYS_INLINE void z_arch_kernel_init(void)
{
	z_arm_interrupt_stack_setup();
	z_arm_exc_setup();
	z_arm_fault_init();
    df4c:	f7ff fbb2 	bl	d6b4 <z_arm_fault_init>
	z_arm_cpu_idle_init();
    df50:	f7ff fa54 	bl	d3fc <z_arm_cpu_idle_init>
static ALWAYS_INLINE void z_arm_clear_faults(void)
{
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	/* Reset all faults */
	SCB->CFSR = SCB_CFSR_USGFAULTSR_Msk |
    df54:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    df58:	62a3      	str	r3, [r4, #40]	; 0x28
		    SCB_CFSR_MEMFAULTSR_Msk |
		    SCB_CFSR_BUSFAULTSR_Msk;

	/* Clear all Hard Faults - HFSR is write-one-to-clear */
	SCB->HFSR = 0xffffffff;
    df5a:	62e3      	str	r3, [r4, #44]	; 0x2c
	struct k_thread dummy_thread = {
    df5c:	ab07      	add	r3, sp, #28
    df5e:	226c      	movs	r2, #108	; 0x6c
    df60:	4629      	mov	r1, r5
    df62:	4618      	mov	r0, r3
    df64:	f001 ffc2 	bl	feec <memset>
# ifdef CONFIG_SCHED_CPU_MASK
		 .base.cpu_mask = -1,
# endif
	};

	_current = &dummy_thread;
    df68:	4c26      	ldr	r4, [pc, #152]	; (e004 <z_cstart+0xec>)
	struct k_thread dummy_thread = {
    df6a:	f88d 7029 	strb.w	r7, [sp, #41]	; 0x29
	_current = &dummy_thread;
    df6e:	60a0      	str	r0, [r4, #8]
#ifdef CONFIG_USERSPACE
	z_app_shmem_bss_zero();
#endif

	/* perform basic hardware initialization */
	z_sys_device_do_config_level(_SYS_INIT_LEVEL_PRE_KERNEL_1);
    df70:	4628      	mov	r0, r5
    df72:	f7ff ff3f 	bl	ddf4 <z_sys_device_do_config_level>
	z_sys_device_do_config_level(_SYS_INIT_LEVEL_PRE_KERNEL_2);
    df76:	4638      	mov	r0, r7
    df78:	f7ff ff3c 	bl	ddf4 <z_sys_device_do_config_level>
	z_sched_init();
    df7c:	f000 fba0 	bl	e6c0 <z_sched_init>
	z_setup_new_thread(&z_main_thread, z_main_stack,
    df80:	4b21      	ldr	r3, [pc, #132]	; (e008 <z_cstart+0xf0>)
	_kernel.ready_q.cache = &z_main_thread;
    df82:	6266      	str	r6, [r4, #36]	; 0x24
	z_setup_new_thread(&z_main_thread, z_main_stack,
    df84:	f44f 6280 	mov.w	r2, #1024	; 0x400
    df88:	e9cd 7304 	strd	r7, r3, [sp, #16]
    df8c:	e9cd 5502 	strd	r5, r5, [sp, #8]
    df90:	4b1e      	ldr	r3, [pc, #120]	; (e00c <z_cstart+0xf4>)
    df92:	e9cd 5500 	strd	r5, r5, [sp]
    df96:	491e      	ldr	r1, [pc, #120]	; (e010 <z_cstart+0xf8>)
    df98:	4630      	mov	r0, r6
    df9a:	f000 fbc7 	bl	e72c <z_setup_new_thread>
	thread->base.thread_state &= ~_THREAD_SUSPENDED;
}

static inline void z_mark_thread_as_started(struct k_thread *thread)
{
	thread->base.thread_state &= ~_THREAD_PRESTART;
    df9e:	7b73      	ldrb	r3, [r6, #13]
    dfa0:	f023 0204 	bic.w	r2, r3, #4
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
    dfa4:	f013 0f1b 	tst.w	r3, #27
	thread->base.thread_state &= ~_THREAD_PRESTART;
    dfa8:	7372      	strb	r2, [r6, #13]
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
    dfaa:	d104      	bne.n	dfb6 <z_cstart+0x9e>
	return true;
}

static ALWAYS_INLINE void z_ready_thread(struct k_thread *thread)
{
	if (z_is_thread_ready(thread)) {
    dfac:	69b3      	ldr	r3, [r6, #24]
    dfae:	b913      	cbnz	r3, dfb6 <z_cstart+0x9e>
		z_add_thread_to_ready_q(thread);
    dfb0:	4630      	mov	r0, r6
    dfb2:	f000 fa19 	bl	e3e8 <z_add_thread_to_ready_q>
	z_setup_new_thread(thr, stack,
    dfb6:	4b17      	ldr	r3, [pc, #92]	; (e014 <z_cstart+0xfc>)
    dfb8:	2201      	movs	r2, #1
    dfba:	9305      	str	r3, [sp, #20]
    dfbc:	230f      	movs	r3, #15
    dfbe:	e9cd 3203 	strd	r3, r2, [sp, #12]
    dfc2:	2300      	movs	r3, #0
    dfc4:	4d14      	ldr	r5, [pc, #80]	; (e018 <z_cstart+0x100>)
    dfc6:	e9cd 3301 	strd	r3, r3, [sp, #4]
    dfca:	9300      	str	r3, [sp, #0]
    dfcc:	f44f 72a0 	mov.w	r2, #320	; 0x140
    dfd0:	4b12      	ldr	r3, [pc, #72]	; (e01c <z_cstart+0x104>)
    dfd2:	4913      	ldr	r1, [pc, #76]	; (e020 <z_cstart+0x108>)
    dfd4:	4628      	mov	r0, r5
    dfd6:	f000 fba9 	bl	e72c <z_setup_new_thread>
	thread->base.thread_state &= ~_THREAD_PRESTART;
    dfda:	7b6b      	ldrb	r3, [r5, #13]
	_kernel.cpus[0].idle_thread = &z_idle_thread;
    dfdc:	60e5      	str	r5, [r4, #12]
    dfde:	f023 0304 	bic.w	r3, r3, #4
    dfe2:	736b      	strb	r3, [r5, #13]
 * @return N/A
 */

static inline void sys_dlist_init(sys_dlist_t *list)
{
	list->head = (sys_dnode_t *)list;
    dfe4:	4b0f      	ldr	r3, [pc, #60]	; (e024 <z_cstart+0x10c>)
	z_arch_switch_to_main_thread(&z_main_thread, z_main_stack,
    dfe6:	f44f 6280 	mov.w	r2, #1024	; 0x400
	list->tail = (sys_dnode_t *)list;
    dfea:	e9c4 3306 	strd	r3, r3, [r4, #24]
    dfee:	4908      	ldr	r1, [pc, #32]	; (e010 <z_cstart+0xf8>)
    dff0:	4b06      	ldr	r3, [pc, #24]	; (e00c <z_cstart+0xf4>)
    dff2:	4803      	ldr	r0, [pc, #12]	; (e000 <z_cstart+0xe8>)
    dff4:	f7ff f9de 	bl	d3b4 <z_arch_switch_to_main_thread>
	CODE_UNREACHABLE; /* LCOV_EXCL_LINE */
    dff8:	200013d0 	.word	0x200013d0
    dffc:	e000ed00 	.word	0xe000ed00
    e000:	200005c4 	.word	0x200005c4
    e004:	20000630 	.word	0x20000630
    e008:	00010c0c 	.word	0x00010c0c
    e00c:	0000dee9 	.word	0x0000dee9
    e010:	20000690 	.word	0x20000690
    e014:	00010c11 	.word	0x00010c11
    e018:	20000558 	.word	0x20000558
    e01c:	0000de6d 	.word	0x0000de6d
    e020:	20000a90 	.word	0x20000a90
    e024:	20000648 	.word	0x20000648

0000e028 <init_mem_slab_module>:
 * Perform any initialization that wasn't done at build time.
 *
 * @return N/A
 */
static int init_mem_slab_module(struct device *dev)
{
    e028:	b570      	push	{r4, r5, r6, lr}
	slab->free_list = NULL;
    e02a:	2400      	movs	r4, #0
	ARG_UNUSED(dev);

	Z_STRUCT_SECTION_FOREACH(k_mem_slab, slab) {
    e02c:	4b0a      	ldr	r3, [pc, #40]	; (e058 <init_mem_slab_module+0x30>)
    e02e:	480b      	ldr	r0, [pc, #44]	; (e05c <init_mem_slab_module+0x34>)
    e030:	4283      	cmp	r3, r0
    e032:	d301      	bcc.n	e038 <init_mem_slab_module+0x10>
		create_free_list(slab);
		SYS_TRACING_OBJ_INIT(k_mem_slab, slab);
		z_object_init(slab);
	}
	return 0;
}
    e034:	2000      	movs	r0, #0
    e036:	bd70      	pop	{r4, r5, r6, pc}
	for (j = 0U; j < slab->num_blocks; j++) {
    e038:	2100      	movs	r1, #0
	p = slab->buffer;
    e03a:	691a      	ldr	r2, [r3, #16]
	for (j = 0U; j < slab->num_blocks; j++) {
    e03c:	689d      	ldr	r5, [r3, #8]
	slab->free_list = NULL;
    e03e:	615c      	str	r4, [r3, #20]
	for (j = 0U; j < slab->num_blocks; j++) {
    e040:	42a9      	cmp	r1, r5
    e042:	d101      	bne.n	e048 <init_mem_slab_module+0x20>
	Z_STRUCT_SECTION_FOREACH(k_mem_slab, slab) {
    e044:	331c      	adds	r3, #28
    e046:	e7f3      	b.n	e030 <init_mem_slab_module+0x8>
		*(char **)p = slab->free_list;
    e048:	695e      	ldr	r6, [r3, #20]
	for (j = 0U; j < slab->num_blocks; j++) {
    e04a:	3101      	adds	r1, #1
		*(char **)p = slab->free_list;
    e04c:	6016      	str	r6, [r2, #0]
		p += slab->block_size;
    e04e:	68de      	ldr	r6, [r3, #12]
		slab->free_list = p;
    e050:	615a      	str	r2, [r3, #20]
		p += slab->block_size;
    e052:	4432      	add	r2, r6
    e054:	e7f4      	b.n	e040 <init_mem_slab_module+0x18>
    e056:	bf00      	nop
    e058:	200014d8 	.word	0x200014d8
    e05c:	200014d8 	.word	0x200014d8

0000e060 <k_mem_slab_alloc>:

	z_object_init(slab);
}

int k_mem_slab_alloc(struct k_mem_slab *slab, void **mem, s32_t timeout)
{
    e060:	b510      	push	{r4, lr}
    e062:	4613      	mov	r3, r2
    e064:	460c      	mov	r4, r1
    e066:	f04f 0220 	mov.w	r2, #32
    e06a:	f3ef 8111 	mrs	r1, BASEPRI
    e06e:	f382 8811 	msr	BASEPRI, r2
    e072:	f3bf 8f6f 	isb	sy
	k_spinlock_key_t key = k_spin_lock(&lock);
	int result;

	if (slab->free_list != NULL) {
    e076:	6942      	ldr	r2, [r0, #20]
    e078:	b15a      	cbz	r2, e092 <k_mem_slab_alloc+0x32>
		/* take a free block */
		*mem = slab->free_list;
    e07a:	6022      	str	r2, [r4, #0]
		slab->free_list = *(char **)(slab->free_list);
    e07c:	6813      	ldr	r3, [r2, #0]
    e07e:	6143      	str	r3, [r0, #20]
		slab->num_used++;
    e080:	6983      	ldr	r3, [r0, #24]
    e082:	3301      	adds	r3, #1
    e084:	6183      	str	r3, [r0, #24]
		result = 0;
    e086:	2000      	movs	r0, #0
	__asm__ volatile(
    e088:	f381 8811 	msr	BASEPRI, r1
    e08c:	f3bf 8f6f 	isb	sy
		return result;
	}

	k_spin_unlock(&lock, key);

	return result;
    e090:	e00d      	b.n	e0ae <k_mem_slab_alloc+0x4e>
	} else if (timeout == K_NO_WAIT) {
    e092:	b91b      	cbnz	r3, e09c <k_mem_slab_alloc+0x3c>
		*mem = NULL;
    e094:	6023      	str	r3, [r4, #0]
		result = -ENOMEM;
    e096:	f06f 000b 	mvn.w	r0, #11
    e09a:	e7f5      	b.n	e088 <k_mem_slab_alloc+0x28>
		result = z_pend_curr(&lock, key, &slab->wait_q, timeout);
    e09c:	4602      	mov	r2, r0
    e09e:	4804      	ldr	r0, [pc, #16]	; (e0b0 <k_mem_slab_alloc+0x50>)
    e0a0:	f000 fab8 	bl	e614 <z_pend_curr>
		if (result == 0) {
    e0a4:	b918      	cbnz	r0, e0ae <k_mem_slab_alloc+0x4e>
			*mem = _current->base.swap_data;
    e0a6:	4b03      	ldr	r3, [pc, #12]	; (e0b4 <k_mem_slab_alloc+0x54>)
    e0a8:	689b      	ldr	r3, [r3, #8]
    e0aa:	695b      	ldr	r3, [r3, #20]
    e0ac:	6023      	str	r3, [r4, #0]
}
    e0ae:	bd10      	pop	{r4, pc}
    e0b0:	2000068d 	.word	0x2000068d
    e0b4:	20000630 	.word	0x20000630

0000e0b8 <k_mem_slab_free>:

void k_mem_slab_free(struct k_mem_slab *slab, void **mem)
{
    e0b8:	b570      	push	{r4, r5, r6, lr}
    e0ba:	4604      	mov	r4, r0
    e0bc:	460d      	mov	r5, r1
	__asm__ volatile(
    e0be:	f04f 0320 	mov.w	r3, #32
    e0c2:	f3ef 8611 	mrs	r6, BASEPRI
    e0c6:	f383 8811 	msr	BASEPRI, r3
    e0ca:	f3bf 8f6f 	isb	sy
	k_spinlock_key_t key = k_spin_lock(&lock);
	struct k_thread *pending_thread = z_unpend_first_thread(&slab->wait_q);
    e0ce:	f002 f831 	bl	10134 <z_unpend_first_thread>

	if (pending_thread != NULL) {
    e0d2:	b180      	cbz	r0, e0f6 <k_mem_slab_free+0x3e>
}

static ALWAYS_INLINE void
z_arch_thread_return_value_set(struct k_thread *thread, unsigned int value)
{
	thread->arch.swap_return_value = value;
    e0d4:	2100      	movs	r1, #0
		z_thread_return_value_set_with_data(pending_thread, 0, *mem);
    e0d6:	682a      	ldr	r2, [r5, #0]
    e0d8:	6681      	str	r1, [r0, #104]	; 0x68
	thread->base.swap_data = data;
    e0da:	6142      	str	r2, [r0, #20]
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
    e0dc:	7b42      	ldrb	r2, [r0, #13]
    e0de:	06d2      	lsls	r2, r2, #27
    e0e0:	d103      	bne.n	e0ea <k_mem_slab_free+0x32>
	if (z_is_thread_ready(thread)) {
    e0e2:	6983      	ldr	r3, [r0, #24]
    e0e4:	b90b      	cbnz	r3, e0ea <k_mem_slab_free+0x32>
		z_add_thread_to_ready_q(thread);
    e0e6:	f000 f97f 	bl	e3e8 <z_add_thread_to_ready_q>
		z_ready_thread(pending_thread);
		z_reschedule(&lock, key);
    e0ea:	4631      	mov	r1, r6
		**(char ***)mem = slab->free_list;
		slab->free_list = *(char **)mem;
		slab->num_used--;
		k_spin_unlock(&lock, key);
	}
}
    e0ec:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		z_reschedule(&lock, key);
    e0f0:	4807      	ldr	r0, [pc, #28]	; (e110 <k_mem_slab_free+0x58>)
    e0f2:	f001 bfbf 	b.w	10074 <z_reschedule>
		**(char ***)mem = slab->free_list;
    e0f6:	682b      	ldr	r3, [r5, #0]
    e0f8:	6962      	ldr	r2, [r4, #20]
    e0fa:	601a      	str	r2, [r3, #0]
		slab->free_list = *(char **)mem;
    e0fc:	682b      	ldr	r3, [r5, #0]
    e0fe:	6163      	str	r3, [r4, #20]
		slab->num_used--;
    e100:	69a3      	ldr	r3, [r4, #24]
    e102:	3b01      	subs	r3, #1
    e104:	61a3      	str	r3, [r4, #24]
	__asm__ volatile(
    e106:	f386 8811 	msr	BASEPRI, r6
    e10a:	f3bf 8f6f 	isb	sy
}
    e10e:	bd70      	pop	{r4, r5, r6, pc}
    e110:	2000068d 	.word	0x2000068d

0000e114 <z_impl_k_mutex_lock>:
	}
	return false;
}

int z_impl_k_mutex_lock(struct k_mutex *mutex, s32_t timeout)
{
    e114:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    e116:	4604      	mov	r4, r0
    e118:	460f      	mov	r7, r1
	__asm__ volatile(
    e11a:	f04f 0320 	mov.w	r3, #32
    e11e:	f3ef 8511 	mrs	r5, BASEPRI
    e122:	f383 8811 	msr	BASEPRI, r3
    e126:	f3bf 8f6f 	isb	sy
	bool resched = false;

	sys_trace_void(SYS_TRACE_ID_MUTEX_LOCK);
	key = k_spin_lock(&lock);

	if (likely((mutex->lock_count == 0U) || (mutex->owner == _current))) {
    e12a:	68c2      	ldr	r2, [r0, #12]
    e12c:	4930      	ldr	r1, [pc, #192]	; (e1f0 <z_impl_k_mutex_lock+0xdc>)
    e12e:	b15a      	cbz	r2, e148 <z_impl_k_mutex_lock+0x34>
    e130:	6880      	ldr	r0, [r0, #8]
    e132:	688e      	ldr	r6, [r1, #8]
    e134:	42b0      	cmp	r0, r6
    e136:	d015      	beq.n	e164 <z_impl_k_mutex_lock+0x50>
		sys_trace_end_call(SYS_TRACE_ID_MUTEX_LOCK);

		return 0;
	}

	if (unlikely(timeout == (s32_t)K_NO_WAIT)) {
    e138:	b9b7      	cbnz	r7, e168 <z_impl_k_mutex_lock+0x54>
	__asm__ volatile(
    e13a:	f385 8811 	msr	BASEPRI, r5
    e13e:	f3bf 8f6f 	isb	sy
		k_spin_unlock(&lock, key);
		sys_trace_end_call(SYS_TRACE_ID_MUTEX_LOCK);
		return -EBUSY;
    e142:	f06f 000f 	mvn.w	r0, #15
    e146:	e00c      	b.n	e162 <z_impl_k_mutex_lock+0x4e>
					_current->base.prio :
    e148:	688b      	ldr	r3, [r1, #8]
    e14a:	f993 300e 	ldrsb.w	r3, [r3, #14]
		mutex->owner_orig_prio = (mutex->lock_count == 0U) ?
    e14e:	6123      	str	r3, [r4, #16]
		mutex->owner = _current;
    e150:	688b      	ldr	r3, [r1, #8]
		mutex->lock_count++;
    e152:	3201      	adds	r2, #1
    e154:	60e2      	str	r2, [r4, #12]
		mutex->owner = _current;
    e156:	60a3      	str	r3, [r4, #8]
    e158:	f385 8811 	msr	BASEPRI, r5
    e15c:	f3bf 8f6f 	isb	sy
		return 0;
    e160:	2000      	movs	r0, #0
		k_spin_unlock(&lock, key);
	}

	sys_trace_end_call(SYS_TRACE_ID_MUTEX_LOCK);
	return -EAGAIN;
}
    e162:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
					_current->base.prio :
    e164:	6923      	ldr	r3, [r4, #16]
    e166:	e7f2      	b.n	e14e <z_impl_k_mutex_lock+0x3a>
	new_prio = new_prio_for_inheritance(_current->base.prio,
    e168:	f990 300e 	ldrsb.w	r3, [r0, #14]
    e16c:	f996 100e 	ldrsb.w	r1, [r6, #14]
    e170:	4299      	cmp	r1, r3
    e172:	bfa8      	it	ge
    e174:	4619      	movge	r1, r3
    e176:	ea21 71e1 	bic.w	r1, r1, r1, asr #31
	if (z_is_prio_higher(new_prio, mutex->owner->base.prio)) {
    e17a:	4299      	cmp	r1, r3
    e17c:	da2b      	bge.n	e1d6 <z_impl_k_mutex_lock+0xc2>
		return z_set_prio(mutex->owner, new_prio);
    e17e:	f000 fa5d 	bl	e63c <z_set_prio>
    e182:	4606      	mov	r6, r0
	int got_mutex = z_pend_curr(&lock, key, &mutex->wait_q, timeout);
    e184:	463b      	mov	r3, r7
    e186:	4622      	mov	r2, r4
    e188:	4629      	mov	r1, r5
    e18a:	481a      	ldr	r0, [pc, #104]	; (e1f4 <z_impl_k_mutex_lock+0xe0>)
    e18c:	f000 fa42 	bl	e614 <z_pend_curr>
	if (got_mutex == 0) {
    e190:	2800      	cmp	r0, #0
    e192:	d0e6      	beq.n	e162 <z_impl_k_mutex_lock+0x4e>
	__asm__ volatile(
    e194:	f04f 0320 	mov.w	r3, #32
    e198:	f3ef 8511 	mrs	r5, BASEPRI
    e19c:	f383 8811 	msr	BASEPRI, r3
    e1a0:	f3bf 8f6f 	isb	sy
 * @return true if empty, false otherwise
 */

static inline bool sys_dlist_is_empty(sys_dlist_t *list)
{
	return list->head == list;
    e1a4:	6823      	ldr	r3, [r4, #0]
    e1a6:	6921      	ldr	r1, [r4, #16]
 * @return a pointer to the head element, NULL if list is empty
 */

static inline sys_dnode_t *sys_dlist_peek_head(sys_dlist_t *list)
{
	return sys_dlist_is_empty(list) ? NULL : list->head;
    e1a8:	429c      	cmp	r4, r3
    e1aa:	d007      	beq.n	e1bc <z_impl_k_mutex_lock+0xa8>
		new_prio_for_inheritance(waiter->base.prio, new_prio) :
    e1ac:	b133      	cbz	r3, e1bc <z_impl_k_mutex_lock+0xa8>
    e1ae:	f993 300e 	ldrsb.w	r3, [r3, #14]
    e1b2:	4299      	cmp	r1, r3
    e1b4:	bfa8      	it	ge
    e1b6:	4619      	movge	r1, r3
    e1b8:	ea21 71e1 	bic.w	r1, r1, r1, asr #31
	resched = adjust_owner_prio(mutex, new_prio) || resched;
    e1bc:	68a0      	ldr	r0, [r4, #8]
	if (mutex->owner->base.prio != new_prio) {
    e1be:	f990 300e 	ldrsb.w	r3, [r0, #14]
    e1c2:	4299      	cmp	r1, r3
    e1c4:	d109      	bne.n	e1da <z_impl_k_mutex_lock+0xc6>
	if (resched) {
    e1c6:	b16e      	cbz	r6, e1e4 <z_impl_k_mutex_lock+0xd0>
		z_reschedule(&lock, key);
    e1c8:	4629      	mov	r1, r5
    e1ca:	480a      	ldr	r0, [pc, #40]	; (e1f4 <z_impl_k_mutex_lock+0xe0>)
    e1cc:	f001 ff52 	bl	10074 <z_reschedule>
	return -EAGAIN;
    e1d0:	f06f 000a 	mvn.w	r0, #10
    e1d4:	e7c5      	b.n	e162 <z_impl_k_mutex_lock+0x4e>
	bool resched = false;
    e1d6:	2600      	movs	r6, #0
    e1d8:	e7d4      	b.n	e184 <z_impl_k_mutex_lock+0x70>
		return z_set_prio(mutex->owner, new_prio);
    e1da:	f000 fa2f 	bl	e63c <z_set_prio>
	resched = adjust_owner_prio(mutex, new_prio) || resched;
    e1de:	2800      	cmp	r0, #0
    e1e0:	d1f2      	bne.n	e1c8 <z_impl_k_mutex_lock+0xb4>
    e1e2:	e7f0      	b.n	e1c6 <z_impl_k_mutex_lock+0xb2>
	__asm__ volatile(
    e1e4:	f385 8811 	msr	BASEPRI, r5
    e1e8:	f3bf 8f6f 	isb	sy
    e1ec:	e7f0      	b.n	e1d0 <z_impl_k_mutex_lock+0xbc>
    e1ee:	bf00      	nop
    e1f0:	20000630 	.word	0x20000630
    e1f4:	2000068d 	.word	0x2000068d

0000e1f8 <z_impl_k_mutex_unlock>:
{
#ifdef CONFIG_PREEMPT_ENABLED
	__ASSERT(!z_arch_is_in_isr(), "");
	__ASSERT(_current->base.sched_locked != 1, "");

	--_current->base.sched_locked;
    e1f8:	4b1e      	ldr	r3, [pc, #120]	; (e274 <z_impl_k_mutex_unlock+0x7c>)
}
#include <syscalls/k_mutex_lock_mrsh.c>
#endif

void z_impl_k_mutex_unlock(struct k_mutex *mutex)
{
    e1fa:	b570      	push	{r4, r5, r6, lr}
    e1fc:	689a      	ldr	r2, [r3, #8]
    e1fe:	4604      	mov	r4, r0
    e200:	7bd3      	ldrb	r3, [r2, #15]
    e202:	3b01      	subs	r3, #1
    e204:	73d3      	strb	r3, [r2, #15]
	sys_trace_void(SYS_TRACE_ID_MUTEX_UNLOCK);
	z_sched_lock();

	K_DEBUG("mutex %p lock_count: %d\n", mutex, mutex->lock_count);

	if (mutex->lock_count - 1U != 0U) {
    e206:	68c3      	ldr	r3, [r0, #12]
    e208:	2b01      	cmp	r3, #1
    e20a:	d005      	beq.n	e218 <z_impl_k_mutex_unlock+0x20>
		mutex->lock_count--;
    e20c:	3b01      	subs	r3, #1
    e20e:	60c3      	str	r3, [r0, #12]


k_mutex_unlock_return:
	k_sched_unlock();
	sys_trace_end_call(SYS_TRACE_ID_MUTEX_UNLOCK);
}
    e210:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	k_sched_unlock();
    e214:	f000 b8cc 	b.w	e3b0 <k_sched_unlock>
	__asm__ volatile(
    e218:	f04f 0320 	mov.w	r3, #32
    e21c:	f3ef 8611 	mrs	r6, BASEPRI
    e220:	f383 8811 	msr	BASEPRI, r3
    e224:	f3bf 8f6f 	isb	sy
	adjust_owner_prio(mutex, mutex->owner_orig_prio);
    e228:	6901      	ldr	r1, [r0, #16]
    e22a:	6880      	ldr	r0, [r0, #8]
	if (mutex->owner->base.prio != new_prio) {
    e22c:	f990 300e 	ldrsb.w	r3, [r0, #14]
    e230:	4299      	cmp	r1, r3
    e232:	d001      	beq.n	e238 <z_impl_k_mutex_unlock+0x40>
		return z_set_prio(mutex->owner, new_prio);
    e234:	f000 fa02 	bl	e63c <z_set_prio>
	new_owner = z_unpend_first_thread(&mutex->wait_q);
    e238:	4620      	mov	r0, r4
    e23a:	f001 ff7b 	bl	10134 <z_unpend_first_thread>
    e23e:	4605      	mov	r5, r0
	mutex->owner = new_owner;
    e240:	60a0      	str	r0, [r4, #8]
	if (new_owner != NULL) {
    e242:	b180      	cbz	r0, e266 <z_impl_k_mutex_unlock+0x6e>
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
    e244:	7b43      	ldrb	r3, [r0, #13]
    e246:	06db      	lsls	r3, r3, #27
    e248:	d103      	bne.n	e252 <z_impl_k_mutex_unlock+0x5a>
	if (z_is_thread_ready(thread)) {
    e24a:	6983      	ldr	r3, [r0, #24]
    e24c:	b90b      	cbnz	r3, e252 <z_impl_k_mutex_unlock+0x5a>
		z_add_thread_to_ready_q(thread);
    e24e:	f000 f8cb 	bl	e3e8 <z_add_thread_to_ready_q>
	__asm__ volatile(
    e252:	f386 8811 	msr	BASEPRI, r6
    e256:	f3bf 8f6f 	isb	sy
    e25a:	2300      	movs	r3, #0
    e25c:	66ab      	str	r3, [r5, #104]	; 0x68
		mutex->owner_orig_prio = new_owner->base.prio;
    e25e:	f995 300e 	ldrsb.w	r3, [r5, #14]
    e262:	6123      	str	r3, [r4, #16]
    e264:	e7d4      	b.n	e210 <z_impl_k_mutex_unlock+0x18>
		mutex->lock_count = 0U;
    e266:	60e0      	str	r0, [r4, #12]
    e268:	f386 8811 	msr	BASEPRI, r6
    e26c:	f3bf 8f6f 	isb	sy
    e270:	e7ce      	b.n	e210 <z_impl_k_mutex_unlock+0x18>
    e272:	bf00      	nop
    e274:	20000630 	.word	0x20000630

0000e278 <resched.part.15>:
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
    e278:	f3ef 8005 	mrs	r0, IPSR
		|| (vector && !(SCB->ICSR & SCB_ICSR_RETTOBASE_Msk))
    e27c:	280d      	cmp	r0, #13
    e27e:	d809      	bhi.n	e294 <resched.part.15+0x1c>
    e280:	b128      	cbz	r0, e28e <resched.part.15+0x16>
    e282:	4b05      	ldr	r3, [pc, #20]	; (e298 <resched.part.15+0x20>)
    e284:	6858      	ldr	r0, [r3, #4]
    e286:	f480 6000 	eor.w	r0, r0, #2048	; 0x800
    e28a:	f3c0 20c0 	ubfx	r0, r0, #11, #1
#ifdef CONFIG_SMP
	_current_cpu->swap_ok = 0;
#endif

	return z_arch_irq_unlocked(key) && !z_arch_is_in_isr();
}
    e28e:	f080 0001 	eor.w	r0, r0, #1
    e292:	4770      	bx	lr
    e294:	2001      	movs	r0, #1
    e296:	e7fa      	b.n	e28e <resched.part.15+0x16>
    e298:	e000ed00 	.word	0xe000ed00

0000e29c <z_reset_time_slice>:
{
    e29c:	b510      	push	{r4, lr}
	if (slice_time != 0) {
    e29e:	4c08      	ldr	r4, [pc, #32]	; (e2c0 <z_reset_time_slice+0x24>)
    e2a0:	6823      	ldr	r3, [r4, #0]
    e2a2:	b15b      	cbz	r3, e2bc <z_reset_time_slice+0x20>
		_current_cpu->slice_ticks = slice_time + z_clock_elapsed();
    e2a4:	f7fe fc96 	bl	cbd4 <z_clock_elapsed>
    e2a8:	6823      	ldr	r3, [r4, #0]
    e2aa:	4a06      	ldr	r2, [pc, #24]	; (e2c4 <z_reset_time_slice+0x28>)
    e2ac:	4418      	add	r0, r3
    e2ae:	6110      	str	r0, [r2, #16]
		z_set_timeout_expiry(slice_time, false);
    e2b0:	2100      	movs	r1, #0
}
    e2b2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		z_set_timeout_expiry(slice_time, false);
    e2b6:	4618      	mov	r0, r3
    e2b8:	f001 bfbf 	b.w	1023a <z_set_timeout_expiry>
}
    e2bc:	bd10      	pop	{r4, pc}
    e2be:	bf00      	nop
    e2c0:	20000668 	.word	0x20000668
    e2c4:	20000630 	.word	0x20000630

0000e2c8 <k_sched_time_slice_set>:
{
    e2c8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    e2ca:	460d      	mov	r5, r1
	__asm__ volatile(
    e2cc:	f04f 0320 	mov.w	r3, #32
    e2d0:	f3ef 8411 	mrs	r4, BASEPRI
    e2d4:	f383 8811 	msr	BASEPRI, r3
    e2d8:	f3bf 8f6f 	isb	sy

#ifdef _NEED_PRECISE_TICK_MS_CONVERSION
	int cyc = sys_clock_hw_cycles_per_sec();

	/* use 64-bit math to keep precision */
	return (s32_t)ceiling_fraction((s64_t)ms * cyc,
    e2dc:	f44f 4100 	mov.w	r1, #32768	; 0x8000
    e2e0:	f240 36e7 	movw	r6, #999	; 0x3e7
    e2e4:	2700      	movs	r7, #0
		_current_cpu->slice_ticks = 0;
    e2e6:	2200      	movs	r2, #0
    e2e8:	fbc1 6700 	smlal	r6, r7, r1, r0
    e2ec:	4b09      	ldr	r3, [pc, #36]	; (e314 <k_sched_time_slice_set+0x4c>)
    e2ee:	4630      	mov	r0, r6
    e2f0:	611a      	str	r2, [r3, #16]
    e2f2:	4639      	mov	r1, r7
    e2f4:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
    e2f8:	2300      	movs	r3, #0
    e2fa:	f7fe f891 	bl	c420 <__aeabi_ldivmod>
    e2fe:	4b06      	ldr	r3, [pc, #24]	; (e318 <k_sched_time_slice_set+0x50>)
    e300:	6018      	str	r0, [r3, #0]
		slice_max_prio = prio;
    e302:	4b06      	ldr	r3, [pc, #24]	; (e31c <k_sched_time_slice_set+0x54>)
    e304:	601d      	str	r5, [r3, #0]
		z_reset_time_slice();
    e306:	f7ff ffc9 	bl	e29c <z_reset_time_slice>
	__asm__ volatile(
    e30a:	f384 8811 	msr	BASEPRI, r4
    e30e:	f3bf 8f6f 	isb	sy
}
    e312:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    e314:	20000630 	.word	0x20000630
    e318:	20000668 	.word	0x20000668
    e31c:	20000664 	.word	0x20000664

0000e320 <k_sched_lock>:
	__asm__ volatile(
    e320:	f04f 0320 	mov.w	r3, #32
    e324:	f3ef 8111 	mrs	r1, BASEPRI
    e328:	f383 8811 	msr	BASEPRI, r3
    e32c:	f3bf 8f6f 	isb	sy
	--_current->base.sched_locked;
    e330:	4b04      	ldr	r3, [pc, #16]	; (e344 <k_sched_lock+0x24>)
    e332:	689a      	ldr	r2, [r3, #8]
    e334:	7bd3      	ldrb	r3, [r2, #15]
    e336:	3b01      	subs	r3, #1
    e338:	73d3      	strb	r3, [r2, #15]
	__asm__ volatile(
    e33a:	f381 8811 	msr	BASEPRI, r1
    e33e:	f3bf 8f6f 	isb	sy
void k_sched_lock(void)
{
	LOCKED(&sched_spinlock) {
		z_sched_lock();
	}
}
    e342:	4770      	bx	lr
    e344:	20000630 	.word	0x20000630

0000e348 <z_priq_dumb_remove>:
}

void z_priq_dumb_remove(sys_dlist_t *pq, struct k_thread *thread)
{
#if defined(CONFIG_SWAP_NONATOMIC) && defined(CONFIG_SCHED_DUMB)
	if (pq == &_kernel.ready_q.runq && thread == _current &&
    e348:	4b09      	ldr	r3, [pc, #36]	; (e370 <z_priq_dumb_remove+0x28>)
    e34a:	f103 0228 	add.w	r2, r3, #40	; 0x28
    e34e:	4282      	cmp	r2, r0
    e350:	d105      	bne.n	e35e <z_priq_dumb_remove+0x16>
    e352:	689b      	ldr	r3, [r3, #8]
    e354:	428b      	cmp	r3, r1
    e356:	d102      	bne.n	e35e <z_priq_dumb_remove+0x16>
    e358:	7b4b      	ldrb	r3, [r1, #13]
    e35a:	06db      	lsls	r3, r3, #27
    e35c:	d106      	bne.n	e36c <z_priq_dumb_remove+0x24>
 * @return N/A
 */

static inline void sys_dlist_remove(sys_dnode_t *node)
{
	node->prev->next = node->next;
    e35e:	e9d1 3200 	ldrd	r3, r2, [r1]
    e362:	6013      	str	r3, [r2, #0]
	node->next->prev = node->prev;
    e364:	605a      	str	r2, [r3, #4]
	node->next = NULL;
    e366:	2300      	movs	r3, #0
	node->prev = NULL;
    e368:	e9c1 3300 	strd	r3, r3, [r1]
#endif

	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));

	sys_dlist_remove(&thread->base.qnode_dlist);
}
    e36c:	4770      	bx	lr
    e36e:	bf00      	nop
    e370:	20000630 	.word	0x20000630

0000e374 <update_cache>:
{
    e374:	b538      	push	{r3, r4, r5, lr}
	struct k_thread *th = _priq_run_best(&_kernel.ready_q.runq);
    e376:	4c0d      	ldr	r4, [pc, #52]	; (e3ac <update_cache+0x38>)
{
    e378:	4602      	mov	r2, r0
	struct k_thread *th = _priq_run_best(&_kernel.ready_q.runq);
    e37a:	f104 0028 	add.w	r0, r4, #40	; 0x28
    e37e:	f001 fea2 	bl	100c6 <z_priq_dumb_best>
	return th ? th : _current_cpu->idle_thread;
    e382:	4605      	mov	r5, r0
    e384:	b900      	cbnz	r0, e388 <update_cache+0x14>
    e386:	68e5      	ldr	r5, [r4, #12]
	if (preempt_ok != 0) {
    e388:	68a3      	ldr	r3, [r4, #8]
    e38a:	b94a      	cbnz	r2, e3a0 <update_cache+0x2c>
	if (z_is_thread_prevented_from_running(_current)) {
    e38c:	7b5a      	ldrb	r2, [r3, #13]
    e38e:	06d2      	lsls	r2, r2, #27
    e390:	d106      	bne.n	e3a0 <update_cache+0x2c>
	if (IS_ENABLED(CONFIG_SWAP_NONATOMIC)
    e392:	69aa      	ldr	r2, [r5, #24]
    e394:	b922      	cbnz	r2, e3a0 <update_cache+0x2c>
	if (is_preempt(_current) || is_metairq(th)) {
    e396:	89da      	ldrh	r2, [r3, #14]
    e398:	2a7f      	cmp	r2, #127	; 0x7f
    e39a:	d901      	bls.n	e3a0 <update_cache+0x2c>
		_kernel.ready_q.cache = _current;
    e39c:	6263      	str	r3, [r4, #36]	; 0x24
}
    e39e:	bd38      	pop	{r3, r4, r5, pc}
		if (th != _current) {
    e3a0:	429d      	cmp	r5, r3
    e3a2:	d001      	beq.n	e3a8 <update_cache+0x34>
			z_reset_time_slice();
    e3a4:	f7ff ff7a 	bl	e29c <z_reset_time_slice>
		_kernel.ready_q.cache = th;
    e3a8:	6265      	str	r5, [r4, #36]	; 0x24
}
    e3aa:	e7f8      	b.n	e39e <update_cache+0x2a>
    e3ac:	20000630 	.word	0x20000630

0000e3b0 <k_sched_unlock>:
{
    e3b0:	b510      	push	{r4, lr}
	__asm__ volatile(
    e3b2:	f04f 0320 	mov.w	r3, #32
    e3b6:	f3ef 8411 	mrs	r4, BASEPRI
    e3ba:	f383 8811 	msr	BASEPRI, r3
    e3be:	f3bf 8f6f 	isb	sy
		++_current->base.sched_locked;
    e3c2:	4b08      	ldr	r3, [pc, #32]	; (e3e4 <k_sched_unlock+0x34>)
		update_cache(0);
    e3c4:	2000      	movs	r0, #0
		++_current->base.sched_locked;
    e3c6:	689a      	ldr	r2, [r3, #8]
    e3c8:	7bd3      	ldrb	r3, [r2, #15]
    e3ca:	3301      	adds	r3, #1
    e3cc:	73d3      	strb	r3, [r2, #15]
		update_cache(0);
    e3ce:	f7ff ffd1 	bl	e374 <update_cache>
	__asm__ volatile(
    e3d2:	f384 8811 	msr	BASEPRI, r4
    e3d6:	f3bf 8f6f 	isb	sy
}
    e3da:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	z_reschedule_unlocked();
    e3de:	f001 be68 	b.w	100b2 <z_reschedule_unlocked>
    e3e2:	bf00      	nop
    e3e4:	20000630 	.word	0x20000630

0000e3e8 <z_add_thread_to_ready_q>:
{
    e3e8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	__asm__ volatile(
    e3ea:	f04f 0320 	mov.w	r3, #32
    e3ee:	f3ef 8411 	mrs	r4, BASEPRI
    e3f2:	f383 8811 	msr	BASEPRI, r3
    e3f6:	f3bf 8f6f 	isb	sy
	return list->head == list;
    e3fa:	4a15      	ldr	r2, [pc, #84]	; (e450 <z_add_thread_to_ready_q+0x68>)
    e3fc:	4611      	mov	r1, r2
    e3fe:	f851 3f28 	ldr.w	r3, [r1, #40]!
	return sys_dlist_is_empty(list) ? NULL : list->head;
    e402:	428b      	cmp	r3, r1
    e404:	d01d      	beq.n	e442 <z_add_thread_to_ready_q+0x5a>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    e406:	b1e3      	cbz	r3, e442 <z_add_thread_to_ready_q+0x5a>
    e408:	6ad6      	ldr	r6, [r2, #44]	; 0x2c
	if (t1->base.prio < t2->base.prio) {
    e40a:	f990 500e 	ldrsb.w	r5, [r0, #14]
    e40e:	f993 700e 	ldrsb.w	r7, [r3, #14]
    e412:	42af      	cmp	r7, r5
    e414:	dd10      	ble.n	e438 <z_add_thread_to_ready_q+0x50>
	node->prev = successor->prev;
    e416:	685a      	ldr	r2, [r3, #4]
	node->next = successor;
    e418:	e9c0 3200 	strd	r3, r2, [r0]
	successor->prev->next = node;
    e41c:	6010      	str	r0, [r2, #0]
	successor->prev = node;
    e41e:	6058      	str	r0, [r3, #4]
	thread->base.thread_state |= states;
    e420:	7b43      	ldrb	r3, [r0, #13]
    e422:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    e426:	7343      	strb	r3, [r0, #13]
		update_cache(0);
    e428:	2000      	movs	r0, #0
    e42a:	f7ff ffa3 	bl	e374 <update_cache>
	__asm__ volatile(
    e42e:	f384 8811 	msr	BASEPRI, r4
    e432:	f3bf 8f6f 	isb	sy
}
    e436:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	return (node == list->tail) ? NULL : node->next;
    e438:	42b3      	cmp	r3, r6
    e43a:	d002      	beq.n	e442 <z_add_thread_to_ready_q+0x5a>
    e43c:	681b      	ldr	r3, [r3, #0]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    e43e:	2b00      	cmp	r3, #0
    e440:	d1e5      	bne.n	e40e <z_add_thread_to_ready_q+0x26>
	node->prev = list->tail;
    e442:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
	node->next = list;
    e444:	6001      	str	r1, [r0, #0]
	node->prev = list->tail;
    e446:	6043      	str	r3, [r0, #4]
	list->tail->next = node;
    e448:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
    e44a:	6018      	str	r0, [r3, #0]
	list->tail = node;
    e44c:	62d0      	str	r0, [r2, #44]	; 0x2c
    e44e:	e7e7      	b.n	e420 <z_add_thread_to_ready_q+0x38>
    e450:	20000630 	.word	0x20000630

0000e454 <z_move_thread_to_end_of_prio_q>:
{
    e454:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    e456:	4604      	mov	r4, r0
	__asm__ volatile(
    e458:	f04f 0320 	mov.w	r3, #32
    e45c:	f3ef 8511 	mrs	r5, BASEPRI
    e460:	f383 8811 	msr	BASEPRI, r3
    e464:	f3bf 8f6f 	isb	sy
		if (z_is_thread_queued(thread)) {
    e468:	7b43      	ldrb	r3, [r0, #13]
    e46a:	065a      	lsls	r2, r3, #25
    e46c:	d503      	bpl.n	e476 <z_move_thread_to_end_of_prio_q+0x22>
			_priq_run_remove(&_kernel.ready_q.runq, thread);
    e46e:	4601      	mov	r1, r0
    e470:	4817      	ldr	r0, [pc, #92]	; (e4d0 <z_move_thread_to_end_of_prio_q+0x7c>)
    e472:	f7ff ff69 	bl	e348 <z_priq_dumb_remove>
	return list->head == list;
    e476:	4a17      	ldr	r2, [pc, #92]	; (e4d4 <z_move_thread_to_end_of_prio_q+0x80>)
	return sys_dlist_is_empty(list) ? NULL : list->head;
    e478:	f102 0128 	add.w	r1, r2, #40	; 0x28
    e47c:	e9d2 300a 	ldrd	r3, r0, [r2, #40]	; 0x28
    e480:	428b      	cmp	r3, r1
    e482:	d01f      	beq.n	e4c4 <z_move_thread_to_end_of_prio_q+0x70>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    e484:	b1f3      	cbz	r3, e4c4 <z_move_thread_to_end_of_prio_q+0x70>
	if (t1->base.prio < t2->base.prio) {
    e486:	f994 600e 	ldrsb.w	r6, [r4, #14]
    e48a:	f993 700e 	ldrsb.w	r7, [r3, #14]
    e48e:	42b7      	cmp	r7, r6
    e490:	dd13      	ble.n	e4ba <z_move_thread_to_end_of_prio_q+0x66>
	node->prev = successor->prev;
    e492:	6859      	ldr	r1, [r3, #4]
	node->next = successor;
    e494:	e9c4 3100 	strd	r3, r1, [r4]
	successor->prev->next = node;
    e498:	600c      	str	r4, [r1, #0]
	successor->prev = node;
    e49a:	605c      	str	r4, [r3, #4]
    e49c:	7b63      	ldrb	r3, [r4, #13]
		update_cache(thread == _current);
    e49e:	6890      	ldr	r0, [r2, #8]
    e4a0:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    e4a4:	7363      	strb	r3, [r4, #13]
    e4a6:	1b03      	subs	r3, r0, r4
    e4a8:	4258      	negs	r0, r3
    e4aa:	4158      	adcs	r0, r3
    e4ac:	f7ff ff62 	bl	e374 <update_cache>
	__asm__ volatile(
    e4b0:	f385 8811 	msr	BASEPRI, r5
    e4b4:	f3bf 8f6f 	isb	sy
}
    e4b8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	return (node == list->tail) ? NULL : node->next;
    e4ba:	4298      	cmp	r0, r3
    e4bc:	d002      	beq.n	e4c4 <z_move_thread_to_end_of_prio_q+0x70>
    e4be:	681b      	ldr	r3, [r3, #0]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    e4c0:	2b00      	cmp	r3, #0
    e4c2:	d1e2      	bne.n	e48a <z_move_thread_to_end_of_prio_q+0x36>
	node->prev = list->tail;
    e4c4:	e9c4 1000 	strd	r1, r0, [r4]
	list->tail->next = node;
    e4c8:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
    e4ca:	601c      	str	r4, [r3, #0]
	list->tail = node;
    e4cc:	62d4      	str	r4, [r2, #44]	; 0x2c
    e4ce:	e7e5      	b.n	e49c <z_move_thread_to_end_of_prio_q+0x48>
    e4d0:	20000658 	.word	0x20000658
    e4d4:	20000630 	.word	0x20000630

0000e4d8 <z_time_slice>:
	if (pending_current == _current) {
    e4d8:	4a15      	ldr	r2, [pc, #84]	; (e530 <z_time_slice+0x58>)
    e4da:	4916      	ldr	r1, [pc, #88]	; (e534 <z_time_slice+0x5c>)
{
    e4dc:	b538      	push	{r3, r4, r5, lr}
	if (pending_current == _current) {
    e4de:	680c      	ldr	r4, [r1, #0]
    e4e0:	6893      	ldr	r3, [r2, #8]
    e4e2:	42a3      	cmp	r3, r4
    e4e4:	4614      	mov	r4, r2
    e4e6:	d103      	bne.n	e4f0 <z_time_slice+0x18>
}
    e4e8:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
			z_reset_time_slice();
    e4ec:	f7ff bed6 	b.w	e29c <z_reset_time_slice>
	pending_current = NULL;
    e4f0:	2500      	movs	r5, #0
    e4f2:	600d      	str	r5, [r1, #0]
	if (slice_time && sliceable(_current)) {
    e4f4:	4910      	ldr	r1, [pc, #64]	; (e538 <z_time_slice+0x60>)
    e4f6:	6809      	ldr	r1, [r1, #0]
    e4f8:	b1b9      	cbz	r1, e52a <z_time_slice+0x52>
		&& !z_is_thread_timeout_active(t);
    e4fa:	89d9      	ldrh	r1, [r3, #14]
    e4fc:	297f      	cmp	r1, #127	; 0x7f
    e4fe:	d814      	bhi.n	e52a <z_time_slice+0x52>
		&& !z_is_prio_higher(t->base.prio, slice_max_prio)
    e500:	490e      	ldr	r1, [pc, #56]	; (e53c <z_time_slice+0x64>)
    e502:	f993 500e 	ldrsb.w	r5, [r3, #14]
    e506:	6809      	ldr	r1, [r1, #0]
    e508:	428d      	cmp	r5, r1
    e50a:	db0e      	blt.n	e52a <z_time_slice+0x52>
		&& !z_is_idle_thread_object(t)
    e50c:	490c      	ldr	r1, [pc, #48]	; (e540 <z_time_slice+0x68>)
    e50e:	428b      	cmp	r3, r1
    e510:	d00b      	beq.n	e52a <z_time_slice+0x52>
		&& !z_is_thread_timeout_active(t);
    e512:	6999      	ldr	r1, [r3, #24]
    e514:	b949      	cbnz	r1, e52a <z_time_slice+0x52>
		if (ticks >= _current_cpu->slice_ticks) {
    e516:	6911      	ldr	r1, [r2, #16]
    e518:	4281      	cmp	r1, r0
    e51a:	dc03      	bgt.n	e524 <z_time_slice+0x4c>
			z_move_thread_to_end_of_prio_q(_current);
    e51c:	4618      	mov	r0, r3
    e51e:	f7ff ff99 	bl	e454 <z_move_thread_to_end_of_prio_q>
    e522:	e7e1      	b.n	e4e8 <z_time_slice+0x10>
			_current_cpu->slice_ticks -= ticks;
    e524:	1a09      	subs	r1, r1, r0
    e526:	6111      	str	r1, [r2, #16]
}
    e528:	bd38      	pop	{r3, r4, r5, pc}
		_current_cpu->slice_ticks = 0;
    e52a:	2300      	movs	r3, #0
    e52c:	6123      	str	r3, [r4, #16]
    e52e:	e7fb      	b.n	e528 <z_time_slice+0x50>
    e530:	20000630 	.word	0x20000630
    e534:	20000660 	.word	0x20000660
    e538:	20000668 	.word	0x20000668
    e53c:	20000664 	.word	0x20000664
    e540:	20000558 	.word	0x20000558

0000e544 <z_remove_thread_from_ready_q>:
{
    e544:	b538      	push	{r3, r4, r5, lr}
    e546:	4604      	mov	r4, r0
	__asm__ volatile(
    e548:	f04f 0320 	mov.w	r3, #32
    e54c:	f3ef 8511 	mrs	r5, BASEPRI
    e550:	f383 8811 	msr	BASEPRI, r3
    e554:	f3bf 8f6f 	isb	sy
		if (z_is_thread_queued(thread)) {
    e558:	7b43      	ldrb	r3, [r0, #13]
    e55a:	065a      	lsls	r2, r3, #25
    e55c:	d507      	bpl.n	e56e <z_remove_thread_from_ready_q+0x2a>
			_priq_run_remove(&_kernel.ready_q.runq, thread);
    e55e:	4601      	mov	r1, r0
    e560:	4809      	ldr	r0, [pc, #36]	; (e588 <z_remove_thread_from_ready_q+0x44>)
    e562:	f7ff fef1 	bl	e348 <z_priq_dumb_remove>
	thread->base.thread_state &= ~states;
    e566:	7b63      	ldrb	r3, [r4, #13]
    e568:	f023 0340 	bic.w	r3, r3, #64	; 0x40
    e56c:	7363      	strb	r3, [r4, #13]
		update_cache(thread == _current);
    e56e:	4b07      	ldr	r3, [pc, #28]	; (e58c <z_remove_thread_from_ready_q+0x48>)
    e570:	6898      	ldr	r0, [r3, #8]
    e572:	1b03      	subs	r3, r0, r4
    e574:	4258      	negs	r0, r3
    e576:	4158      	adcs	r0, r3
    e578:	f7ff fefc 	bl	e374 <update_cache>
	__asm__ volatile(
    e57c:	f385 8811 	msr	BASEPRI, r5
    e580:	f3bf 8f6f 	isb	sy
}
    e584:	bd38      	pop	{r3, r4, r5, pc}
    e586:	bf00      	nop
    e588:	20000658 	.word	0x20000658
    e58c:	20000630 	.word	0x20000630

0000e590 <pend>:
{
    e590:	b570      	push	{r4, r5, r6, lr}
    e592:	4604      	mov	r4, r0
    e594:	460d      	mov	r5, r1
    e596:	4616      	mov	r6, r2
	z_remove_thread_from_ready_q(thread);
    e598:	f7ff ffd4 	bl	e544 <z_remove_thread_from_ready_q>
	thread->base.thread_state |= _THREAD_PENDING;
    e59c:	7b63      	ldrb	r3, [r4, #13]
    e59e:	f043 0302 	orr.w	r3, r3, #2
    e5a2:	7363      	strb	r3, [r4, #13]
	if (wait_q != NULL) {
    e5a4:	b17d      	cbz	r5, e5c6 <pend+0x36>
	return list->head == list;
    e5a6:	682b      	ldr	r3, [r5, #0]
		thread->base.pended_on = wait_q;
    e5a8:	60a5      	str	r5, [r4, #8]
	return sys_dlist_is_empty(list) ? NULL : list->head;
    e5aa:	429d      	cmp	r5, r3
    e5ac:	d027      	beq.n	e5fe <pend+0x6e>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    e5ae:	b333      	cbz	r3, e5fe <pend+0x6e>
	if (t1->base.prio < t2->base.prio) {
    e5b0:	f994 200e 	ldrsb.w	r2, [r4, #14]
    e5b4:	f993 100e 	ldrsb.w	r1, [r3, #14]
    e5b8:	4291      	cmp	r1, r2
    e5ba:	dd1a      	ble.n	e5f2 <pend+0x62>
	node->prev = successor->prev;
    e5bc:	685a      	ldr	r2, [r3, #4]
	node->next = successor;
    e5be:	e9c4 3200 	strd	r3, r2, [r4]
	successor->prev->next = node;
    e5c2:	6014      	str	r4, [r2, #0]
	successor->prev = node;
    e5c4:	605c      	str	r4, [r3, #4]
	if (timeout != K_FOREVER) {
    e5c6:	1c73      	adds	r3, r6, #1
    e5c8:	d020      	beq.n	e60c <pend+0x7c>
    e5ca:	f44f 4500 	mov.w	r5, #32768	; 0x8000
    e5ce:	f240 30e7 	movw	r0, #999	; 0x3e7
    e5d2:	2100      	movs	r1, #0
    e5d4:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
    e5d8:	fbc5 0106 	smlal	r0, r1, r5, r6
    e5dc:	2300      	movs	r3, #0
    e5de:	f7fd ff1f 	bl	c420 <__aeabi_ldivmod>

extern void z_thread_timeout(struct _timeout *to);

static inline void z_add_thread_timeout(struct k_thread *th, s32_t ticks)
{
	z_add_timeout(&th->base.timeout, z_thread_timeout, ticks);
    e5e2:	490b      	ldr	r1, [pc, #44]	; (e610 <pend+0x80>)
    e5e4:	1c42      	adds	r2, r0, #1
    e5e6:	f104 0018 	add.w	r0, r4, #24
}
    e5ea:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    e5ee:	f000 b949 	b.w	e884 <z_add_timeout>
	return (node == list->tail) ? NULL : node->next;
    e5f2:	6869      	ldr	r1, [r5, #4]
    e5f4:	428b      	cmp	r3, r1
    e5f6:	d002      	beq.n	e5fe <pend+0x6e>
    e5f8:	681b      	ldr	r3, [r3, #0]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    e5fa:	2b00      	cmp	r3, #0
    e5fc:	d1da      	bne.n	e5b4 <pend+0x24>
	node->prev = list->tail;
    e5fe:	686b      	ldr	r3, [r5, #4]
	node->next = list;
    e600:	6025      	str	r5, [r4, #0]
	node->prev = list->tail;
    e602:	6063      	str	r3, [r4, #4]
	list->tail->next = node;
    e604:	686b      	ldr	r3, [r5, #4]
    e606:	601c      	str	r4, [r3, #0]
	list->tail = node;
    e608:	606c      	str	r4, [r5, #4]
    e60a:	e7dc      	b.n	e5c6 <pend+0x36>
}
    e60c:	bd70      	pop	{r4, r5, r6, pc}
    e60e:	bf00      	nop
    e610:	000100d3 	.word	0x000100d3

0000e614 <z_pend_curr>:
{
    e614:	b510      	push	{r4, lr}
    e616:	460c      	mov	r4, r1
    e618:	4611      	mov	r1, r2
	pending_current = _current;
    e61a:	4a06      	ldr	r2, [pc, #24]	; (e634 <z_pend_curr+0x20>)
    e61c:	6890      	ldr	r0, [r2, #8]
    e61e:	4a06      	ldr	r2, [pc, #24]	; (e638 <z_pend_curr+0x24>)
    e620:	6010      	str	r0, [r2, #0]
	pend(_current, wait_q, timeout);
    e622:	461a      	mov	r2, r3
    e624:	f7ff ffb4 	bl	e590 <pend>
    e628:	4620      	mov	r0, r4
}
    e62a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    e62e:	f7fe be1b 	b.w	d268 <z_arch_swap>
    e632:	bf00      	nop
    e634:	20000630 	.word	0x20000630
    e638:	20000660 	.word	0x20000660

0000e63c <z_set_prio>:
{
    e63c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    e640:	4604      	mov	r4, r0
	__asm__ volatile(
    e642:	f04f 0320 	mov.w	r3, #32
    e646:	f3ef 8911 	mrs	r9, BASEPRI
    e64a:	f383 8811 	msr	BASEPRI, r3
    e64e:	f3bf 8f6f 	isb	sy
		need_sched = z_is_thread_ready(thread);
    e652:	f001 fced 	bl	10030 <z_is_thread_ready>
		if (need_sched) {
    e656:	b24e      	sxtb	r6, r1
    e658:	4680      	mov	r8, r0
    e65a:	b360      	cbz	r0, e6b6 <z_set_prio+0x7a>
				_priq_run_remove(&_kernel.ready_q.runq, thread);
    e65c:	4d17      	ldr	r5, [pc, #92]	; (e6bc <z_set_prio+0x80>)
    e65e:	4621      	mov	r1, r4
    e660:	f105 0728 	add.w	r7, r5, #40	; 0x28
    e664:	4638      	mov	r0, r7
    e666:	f7ff fe6f 	bl	e348 <z_priq_dumb_remove>
	return list->head == list;
    e66a:	6aab      	ldr	r3, [r5, #40]	; 0x28
				thread->base.prio = prio;
    e66c:	73a6      	strb	r6, [r4, #14]
	return sys_dlist_is_empty(list) ? NULL : list->head;
    e66e:	42bb      	cmp	r3, r7
    e670:	462a      	mov	r2, r5
    e672:	d019      	beq.n	e6a8 <z_set_prio+0x6c>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    e674:	b1c3      	cbz	r3, e6a8 <z_set_prio+0x6c>
    e676:	6ae9      	ldr	r1, [r5, #44]	; 0x2c
	if (t1->base.prio < t2->base.prio) {
    e678:	f993 000e 	ldrsb.w	r0, [r3, #14]
    e67c:	42b0      	cmp	r0, r6
    e67e:	dd0e      	ble.n	e69e <z_set_prio+0x62>
	node->prev = successor->prev;
    e680:	685a      	ldr	r2, [r3, #4]
	node->next = successor;
    e682:	e9c4 3200 	strd	r3, r2, [r4]
	successor->prev->next = node;
    e686:	6014      	str	r4, [r2, #0]
	successor->prev = node;
    e688:	605c      	str	r4, [r3, #4]
			update_cache(1);
    e68a:	2001      	movs	r0, #1
    e68c:	f7ff fe72 	bl	e374 <update_cache>
	__asm__ volatile(
    e690:	f389 8811 	msr	BASEPRI, r9
    e694:	f3bf 8f6f 	isb	sy
}
    e698:	4640      	mov	r0, r8
    e69a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	return (node == list->tail) ? NULL : node->next;
    e69e:	4299      	cmp	r1, r3
    e6a0:	d002      	beq.n	e6a8 <z_set_prio+0x6c>
    e6a2:	681b      	ldr	r3, [r3, #0]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    e6a4:	2b00      	cmp	r3, #0
    e6a6:	d1e7      	bne.n	e678 <z_set_prio+0x3c>
	node->prev = list->tail;
    e6a8:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
	node->next = list;
    e6aa:	6027      	str	r7, [r4, #0]
	node->prev = list->tail;
    e6ac:	6063      	str	r3, [r4, #4]
	list->tail->next = node;
    e6ae:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
    e6b0:	601c      	str	r4, [r3, #0]
	list->tail = node;
    e6b2:	62d4      	str	r4, [r2, #44]	; 0x2c
    e6b4:	e7e9      	b.n	e68a <z_set_prio+0x4e>
			thread->base.prio = prio;
    e6b6:	73a6      	strb	r6, [r4, #14]
    e6b8:	e7ea      	b.n	e690 <z_set_prio+0x54>
    e6ba:	bf00      	nop
    e6bc:	20000630 	.word	0x20000630

0000e6c0 <z_sched_init>:
		sys_dlist_init(&_kernel.ready_q.runq.queues[i]);
	}
#endif

#ifdef CONFIG_TIMESLICING
	k_sched_time_slice_set(CONFIG_TIMESLICE_SIZE,
    e6c0:	2100      	movs	r1, #0
	list->head = (sys_dnode_t *)list;
    e6c2:	4b04      	ldr	r3, [pc, #16]	; (e6d4 <z_sched_init+0x14>)
    e6c4:	4608      	mov	r0, r1
    e6c6:	f103 0228 	add.w	r2, r3, #40	; 0x28
	list->tail = (sys_dnode_t *)list;
    e6ca:	e9c3 220a 	strd	r2, r2, [r3, #40]	; 0x28
    e6ce:	f7ff bdfb 	b.w	e2c8 <k_sched_time_slice_set>
    e6d2:	bf00      	nop
    e6d4:	20000630 	.word	0x20000630

0000e6d8 <z_impl_k_current_get>:
#endif

k_tid_t z_impl_k_current_get(void)
{
	return _current;
}
    e6d8:	4b01      	ldr	r3, [pc, #4]	; (e6e0 <z_impl_k_current_get+0x8>)
    e6da:	6898      	ldr	r0, [r3, #8]
    e6dc:	4770      	bx	lr
    e6de:	bf00      	nop
    e6e0:	20000630 	.word	0x20000630

0000e6e4 <z_impl_k_thread_start>:
}
#endif

#ifdef CONFIG_MULTITHREADING
void z_impl_k_thread_start(struct k_thread *thread)
{
    e6e4:	b510      	push	{r4, lr}
    e6e6:	4602      	mov	r2, r0
	__asm__ volatile(
    e6e8:	f04f 0320 	mov.w	r3, #32
    e6ec:	f3ef 8411 	mrs	r4, BASEPRI
    e6f0:	f383 8811 	msr	BASEPRI, r3
    e6f4:	f3bf 8f6f 	isb	sy
	k_spinlock_key_t key = k_spin_lock(&lock); /* protect kernel queues */

	if (z_has_thread_started(thread)) {
    e6f8:	7b43      	ldrb	r3, [r0, #13]
    e6fa:	0759      	lsls	r1, r3, #29
    e6fc:	d404      	bmi.n	e708 <z_impl_k_thread_start+0x24>
	__asm__ volatile(
    e6fe:	f384 8811 	msr	BASEPRI, r4
    e702:	f3bf 8f6f 	isb	sy
	}

	z_mark_thread_as_started(thread);
	z_ready_thread(thread);
	z_reschedule(&lock, key);
}
    e706:	bd10      	pop	{r4, pc}
	thread->base.thread_state &= ~_THREAD_PRESTART;
    e708:	f023 0304 	bic.w	r3, r3, #4
    e70c:	7343      	strb	r3, [r0, #13]
	if (z_is_thread_ready(thread)) {
    e70e:	f001 fd3e 	bl	1018e <z_is_thread_ready>
    e712:	b110      	cbz	r0, e71a <z_impl_k_thread_start+0x36>
		z_add_thread_to_ready_q(thread);
    e714:	4610      	mov	r0, r2
    e716:	f7ff fe67 	bl	e3e8 <z_add_thread_to_ready_q>
	z_reschedule(&lock, key);
    e71a:	4621      	mov	r1, r4
}
    e71c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	z_reschedule(&lock, key);
    e720:	4801      	ldr	r0, [pc, #4]	; (e728 <z_impl_k_thread_start+0x44>)
    e722:	f001 bca7 	b.w	10074 <z_reschedule>
    e726:	bf00      	nop
    e728:	2000068d 	.word	0x2000068d

0000e72c <z_setup_new_thread>:
void z_setup_new_thread(struct k_thread *new_thread,
		       k_thread_stack_t *stack, size_t stack_size,
		       k_thread_entry_t entry,
		       void *p1, void *p2, void *p3,
		       int prio, u32_t options, const char *name)
{
    e72c:	b530      	push	{r4, r5, lr}
    e72e:	b087      	sub	sp, #28
	stack_size = STACK_ROUND_DOWN(stack_size
			- sizeof(*new_thread->userspace_local_data));
#endif
#endif

	z_arch_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
    e730:	9d0e      	ldr	r5, [sp, #56]	; 0x38
{
    e732:	4604      	mov	r4, r0
	z_arch_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
    e734:	9504      	str	r5, [sp, #16]
    e736:	9d0d      	ldr	r5, [sp, #52]	; 0x34
    e738:	9503      	str	r5, [sp, #12]
    e73a:	9d0c      	ldr	r5, [sp, #48]	; 0x30
    e73c:	9502      	str	r5, [sp, #8]
    e73e:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
    e740:	9501      	str	r5, [sp, #4]
    e742:	9d0a      	ldr	r5, [sp, #40]	; 0x28
    e744:	9500      	str	r5, [sp, #0]
    e746:	f7fe fe0b 	bl	d360 <z_arch_new_thread>
#ifdef CONFIG_SCHED_CPU_MASK
	new_thread->base.cpu_mask = -1;
#endif
#ifdef CONFIG_ARCH_HAS_CUSTOM_SWAP_TO_MAIN
	/* _current may be null if the dummy thread is not used */
	if (!_current) {
    e74a:	4b03      	ldr	r3, [pc, #12]	; (e758 <z_setup_new_thread+0x2c>)
    e74c:	689b      	ldr	r3, [r3, #8]
    e74e:	b103      	cbz	r3, e752 <z_setup_new_thread+0x26>
	}
#endif
#ifdef CONFIG_SCHED_DEADLINE
	new_thread->base.prio_deadline = 0;
#endif
	new_thread->resource_pool = _current->resource_pool;
    e750:	6e1b      	ldr	r3, [r3, #96]	; 0x60
    e752:	6623      	str	r3, [r4, #96]	; 0x60
	sys_trace_thread_create(new_thread);
}
    e754:	b007      	add	sp, #28
    e756:	bd30      	pop	{r4, r5, pc}
    e758:	20000630 	.word	0x20000630

0000e75c <z_init_static_threads>:
	}
}
#endif /* CONFIG_USERSPACE */

void z_init_static_threads(void)
{
    e75c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	_FOREACH_STATIC_THREAD(thread_data) {
    e760:	4e28      	ldr	r6, [pc, #160]	; (e804 <z_init_static_threads+0xa8>)
    e762:	4d29      	ldr	r5, [pc, #164]	; (e808 <z_init_static_threads+0xac>)
    e764:	46b0      	mov	r8, r6
{
    e766:	b087      	sub	sp, #28
	_FOREACH_STATIC_THREAD(thread_data) {
    e768:	42b5      	cmp	r5, r6
    e76a:	f105 0430 	add.w	r4, r5, #48	; 0x30
    e76e:	d310      	bcc.n	e792 <z_init_static_threads+0x36>
	 * until they are all started.
	 *
	 * Note that static threads defined using the legacy API have a
	 * delay of K_FOREVER.
	 */
	k_sched_lock();
    e770:	f7ff fdd6 	bl	e320 <k_sched_lock>
    e774:	f44f 4900 	mov.w	r9, #32768	; 0x8000
    e778:	f240 36e7 	movw	r6, #999	; 0x3e7
    e77c:	2700      	movs	r7, #0
	_FOREACH_STATIC_THREAD(thread_data) {
    e77e:	4c22      	ldr	r4, [pc, #136]	; (e808 <z_init_static_threads+0xac>)
    e780:	f8df a088 	ldr.w	sl, [pc, #136]	; e80c <z_init_static_threads+0xb0>
    e784:	4544      	cmp	r4, r8
    e786:	d321      	bcc.n	e7cc <z_init_static_threads+0x70>
			schedule_new_thread(thread_data->init_thread,
					    thread_data->init_delay);
		}
	}
	k_sched_unlock();
}
    e788:	b007      	add	sp, #28
    e78a:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	k_sched_unlock();
    e78e:	f7ff be0f 	b.w	e3b0 <k_sched_unlock>
		z_setup_new_thread(
    e792:	f854 3c04 	ldr.w	r3, [r4, #-4]
    e796:	9305      	str	r3, [sp, #20]
    e798:	f854 3c10 	ldr.w	r3, [r4, #-16]
    e79c:	9304      	str	r3, [sp, #16]
    e79e:	f854 3c14 	ldr.w	r3, [r4, #-20]
    e7a2:	9303      	str	r3, [sp, #12]
    e7a4:	f854 3c18 	ldr.w	r3, [r4, #-24]
    e7a8:	9302      	str	r3, [sp, #8]
    e7aa:	f854 3c1c 	ldr.w	r3, [r4, #-28]
    e7ae:	9301      	str	r3, [sp, #4]
    e7b0:	f854 3c20 	ldr.w	r3, [r4, #-32]
    e7b4:	9300      	str	r3, [sp, #0]
    e7b6:	e954 230a 	ldrd	r2, r3, [r4, #-40]	; 0x28
    e7ba:	e954 010c 	ldrd	r0, r1, [r4, #-48]	; 0x30
    e7be:	f7ff ffb5 	bl	e72c <z_setup_new_thread>
		thread_data->init_thread->init_data = thread_data;
    e7c2:	f854 3c30 	ldr.w	r3, [r4, #-48]
    e7c6:	64dd      	str	r5, [r3, #76]	; 0x4c
    e7c8:	4625      	mov	r5, r4
    e7ca:	e7cd      	b.n	e768 <z_init_static_threads+0xc>
		if (thread_data->init_delay != K_FOREVER) {
    e7cc:	6a61      	ldr	r1, [r4, #36]	; 0x24
    e7ce:	1c4b      	adds	r3, r1, #1
    e7d0:	d004      	beq.n	e7dc <z_init_static_threads+0x80>
			schedule_new_thread(thread_data->init_thread,
    e7d2:	6825      	ldr	r5, [r4, #0]
	if (delay == 0) {
    e7d4:	b921      	cbnz	r1, e7e0 <z_init_static_threads+0x84>
	z_impl_k_thread_start(thread);
    e7d6:	4628      	mov	r0, r5
    e7d8:	f7ff ff84 	bl	e6e4 <z_impl_k_thread_start>
	_FOREACH_STATIC_THREAD(thread_data) {
    e7dc:	3430      	adds	r4, #48	; 0x30
    e7de:	e7d1      	b.n	e784 <z_init_static_threads+0x28>
    e7e0:	46b3      	mov	fp, r6
    e7e2:	46bc      	mov	ip, r7
    e7e4:	fbc9 bc01 	smlal	fp, ip, r9, r1
    e7e8:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
    e7ec:	2300      	movs	r3, #0
    e7ee:	4658      	mov	r0, fp
    e7f0:	4661      	mov	r1, ip
    e7f2:	f7fd fe15 	bl	c420 <__aeabi_ldivmod>
    e7f6:	4651      	mov	r1, sl
    e7f8:	1c42      	adds	r2, r0, #1
    e7fa:	f105 0018 	add.w	r0, r5, #24
    e7fe:	f000 f841 	bl	e884 <z_add_timeout>
    e802:	e7eb      	b.n	e7dc <z_init_static_threads+0x80>
    e804:	200014d8 	.word	0x200014d8
    e808:	200014d8 	.word	0x200014d8
    e80c:	000100d3 	.word	0x000100d3

0000e810 <elapsed>:
	sys_dlist_remove(&t->node);
}

static s32_t elapsed(void)
{
	return announce_remaining == 0 ? z_clock_elapsed() : 0;
    e810:	4b03      	ldr	r3, [pc, #12]	; (e820 <elapsed+0x10>)
    e812:	681b      	ldr	r3, [r3, #0]
    e814:	b90b      	cbnz	r3, e81a <elapsed+0xa>
    e816:	f7fe b9dd 	b.w	cbd4 <z_clock_elapsed>
}
    e81a:	2000      	movs	r0, #0
    e81c:	4770      	bx	lr
    e81e:	bf00      	nop
    e820:	2000066c 	.word	0x2000066c

0000e824 <remove_timeout>:
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
    e824:	6803      	ldr	r3, [r0, #0]
    e826:	b140      	cbz	r0, e83a <remove_timeout+0x16>
    e828:	4a07      	ldr	r2, [pc, #28]	; (e848 <remove_timeout+0x24>)
	return (node == list->tail) ? NULL : node->next;
    e82a:	6852      	ldr	r2, [r2, #4]
    e82c:	4290      	cmp	r0, r2
    e82e:	d004      	beq.n	e83a <remove_timeout+0x16>
	if (next(t) != NULL) {
    e830:	b11b      	cbz	r3, e83a <remove_timeout+0x16>
		next(t)->dticks += t->dticks;
    e832:	689a      	ldr	r2, [r3, #8]
    e834:	6881      	ldr	r1, [r0, #8]
    e836:	440a      	add	r2, r1
    e838:	609a      	str	r2, [r3, #8]
	node->prev->next = node->next;
    e83a:	6842      	ldr	r2, [r0, #4]
    e83c:	6013      	str	r3, [r2, #0]
	node->next->prev = node->prev;
    e83e:	605a      	str	r2, [r3, #4]
	node->next = NULL;
    e840:	2300      	movs	r3, #0
	node->prev = NULL;
    e842:	e9c0 3300 	strd	r3, r3, [r0]
}
    e846:	4770      	bx	lr
    e848:	2000140c 	.word	0x2000140c

0000e84c <next_timeout>:
	return list->head == list;
    e84c:	4b0b      	ldr	r3, [pc, #44]	; (e87c <next_timeout+0x30>)

static s32_t next_timeout(void)
{
    e84e:	b510      	push	{r4, lr}
    e850:	681c      	ldr	r4, [r3, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
    e852:	429c      	cmp	r4, r3
    e854:	bf08      	it	eq
    e856:	2400      	moveq	r4, #0
	struct _timeout *to = first();
	s32_t ticks_elapsed = elapsed();
    e858:	f7ff ffda 	bl	e810 <elapsed>
	s32_t ret = to == NULL ? MAX_WAIT : MAX(0, to->dticks - ticks_elapsed);
    e85c:	b154      	cbz	r4, e874 <next_timeout+0x28>
    e85e:	68a3      	ldr	r3, [r4, #8]
    e860:	1a18      	subs	r0, r3, r0
    e862:	ea20 70e0 	bic.w	r0, r0, r0, asr #31

#ifdef CONFIG_TIMESLICING
	if (_current_cpu->slice_ticks && _current_cpu->slice_ticks < ret) {
    e866:	4b06      	ldr	r3, [pc, #24]	; (e880 <next_timeout+0x34>)
    e868:	691b      	ldr	r3, [r3, #16]
    e86a:	b113      	cbz	r3, e872 <next_timeout+0x26>
    e86c:	4298      	cmp	r0, r3
    e86e:	bfa8      	it	ge
    e870:	4618      	movge	r0, r3
		ret = _current_cpu->slice_ticks;
	}
#endif
	return ret;
}
    e872:	bd10      	pop	{r4, pc}
	s32_t ret = to == NULL ? MAX_WAIT : MAX(0, to->dticks - ticks_elapsed);
    e874:	f06f 4000 	mvn.w	r0, #2147483648	; 0x80000000
    e878:	e7f5      	b.n	e866 <next_timeout+0x1a>
    e87a:	bf00      	nop
    e87c:	2000140c 	.word	0x2000140c
    e880:	20000630 	.word	0x20000630

0000e884 <z_add_timeout>:

void z_add_timeout(struct _timeout *to, _timeout_func_t fn, s32_t ticks)
{
    e884:	b570      	push	{r4, r5, r6, lr}
    e886:	4604      	mov	r4, r0
    e888:	4616      	mov	r6, r2
	__ASSERT(!sys_dnode_is_linked(&to->node), "");
	to->fn = fn;
    e88a:	60c1      	str	r1, [r0, #12]
	__asm__ volatile(
    e88c:	f04f 0320 	mov.w	r3, #32
    e890:	f3ef 8511 	mrs	r5, BASEPRI
    e894:	f383 8811 	msr	BASEPRI, r3
    e898:	f3bf 8f6f 	isb	sy
	ticks = MAX(1, ticks);

	LOCKED(&timeout_lock) {
		struct _timeout *t;

		to->dticks = ticks + elapsed();
    e89c:	f7ff ffb8 	bl	e810 <elapsed>
    e8a0:	2e01      	cmp	r6, #1
    e8a2:	bfac      	ite	ge
    e8a4:	1980      	addge	r0, r0, r6
    e8a6:	3001      	addlt	r0, #1
	return list->head == list;
    e8a8:	4b16      	ldr	r3, [pc, #88]	; (e904 <z_add_timeout+0x80>)
    e8aa:	60a0      	str	r0, [r4, #8]
    e8ac:	681a      	ldr	r2, [r3, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
    e8ae:	429a      	cmp	r2, r3
    e8b0:	d001      	beq.n	e8b6 <z_add_timeout+0x32>
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
    e8b2:	685e      	ldr	r6, [r3, #4]
		for (t = first(); t != NULL; t = next(t)) {
    e8b4:	b932      	cbnz	r2, e8c4 <z_add_timeout+0x40>
	node->prev = list->tail;
    e8b6:	685a      	ldr	r2, [r3, #4]
	node->next = list;
    e8b8:	6023      	str	r3, [r4, #0]
	node->prev = list->tail;
    e8ba:	6062      	str	r2, [r4, #4]
	list->tail->next = node;
    e8bc:	685a      	ldr	r2, [r3, #4]
    e8be:	6014      	str	r4, [r2, #0]
	list->tail = node;
    e8c0:	605c      	str	r4, [r3, #4]
    e8c2:	e00a      	b.n	e8da <z_add_timeout+0x56>
			__ASSERT(t->dticks >= 0, "");

			if (t->dticks > to->dticks) {
    e8c4:	6890      	ldr	r0, [r2, #8]
    e8c6:	68a1      	ldr	r1, [r4, #8]
    e8c8:	4288      	cmp	r0, r1
    e8ca:	dd15      	ble.n	e8f8 <z_add_timeout+0x74>
				t->dticks -= to->dticks;
    e8cc:	1a41      	subs	r1, r0, r1
    e8ce:	6091      	str	r1, [r2, #8]
	node->prev = successor->prev;
    e8d0:	6851      	ldr	r1, [r2, #4]
	node->next = successor;
    e8d2:	e9c4 2100 	strd	r2, r1, [r4]
	successor->prev->next = node;
    e8d6:	600c      	str	r4, [r1, #0]
	successor->prev = node;
    e8d8:	6054      	str	r4, [r2, #4]
	return list->head == list;
    e8da:	681a      	ldr	r2, [r3, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
    e8dc:	429a      	cmp	r2, r3
    e8de:	d006      	beq.n	e8ee <z_add_timeout+0x6a>

		if (t == NULL) {
			sys_dlist_append(&timeout_list, &to->node);
		}

		if (to == first()) {
    e8e0:	4294      	cmp	r4, r2
    e8e2:	d104      	bne.n	e8ee <z_add_timeout+0x6a>
			z_clock_set_timeout(next_timeout(), false);
    e8e4:	f7ff ffb2 	bl	e84c <next_timeout>
    e8e8:	2100      	movs	r1, #0
    e8ea:	f7fe f925 	bl	cb38 <z_clock_set_timeout>
	__asm__ volatile(
    e8ee:	f385 8811 	msr	BASEPRI, r5
    e8f2:	f3bf 8f6f 	isb	sy
		}
	}
}
    e8f6:	bd70      	pop	{r4, r5, r6, pc}
			to->dticks -= t->dticks;
    e8f8:	1a09      	subs	r1, r1, r0
	return (node == list->tail) ? NULL : node->next;
    e8fa:	4296      	cmp	r6, r2
    e8fc:	60a1      	str	r1, [r4, #8]
    e8fe:	d0da      	beq.n	e8b6 <z_add_timeout+0x32>
    e900:	6812      	ldr	r2, [r2, #0]
    e902:	e7d7      	b.n	e8b4 <z_add_timeout+0x30>
    e904:	2000140c 	.word	0x2000140c

0000e908 <z_clock_announce>:
		}
	}
}

void z_clock_announce(s32_t ticks)
{
    e908:	e92d 4bf0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, fp, lr}
    e90c:	4604      	mov	r4, r0
#ifdef CONFIG_TIMESLICING
	z_time_slice(ticks);
    e90e:	f7ff fde3 	bl	e4d8 <z_time_slice>
	__asm__ volatile(
    e912:	f04f 0320 	mov.w	r3, #32
    e916:	f3ef 8511 	mrs	r5, BASEPRI
    e91a:	f383 8811 	msr	BASEPRI, r3
    e91e:	f3bf 8f6f 	isb	sy
#endif

	k_spinlock_key_t key = k_spin_lock(&timeout_lock);

	announce_remaining = ticks;
    e922:	4f21      	ldr	r7, [pc, #132]	; (e9a8 <z_clock_announce+0xa0>)
    e924:	4e21      	ldr	r6, [pc, #132]	; (e9ac <z_clock_announce+0xa4>)
    e926:	46b8      	mov	r8, r7
	return list->head == list;
    e928:	f8df 9084 	ldr.w	r9, [pc, #132]	; e9b0 <z_clock_announce+0xa8>
    e92c:	6034      	str	r4, [r6, #0]
    e92e:	f8d9 4000 	ldr.w	r4, [r9]
    e932:	6832      	ldr	r2, [r6, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
    e934:	454c      	cmp	r4, r9
    e936:	e9d7 bc00 	ldrd	fp, ip, [r7]
    e93a:	d005      	beq.n	e948 <z_clock_announce+0x40>

	while (first() != NULL && first()->dticks <= announce_remaining) {
    e93c:	b124      	cbz	r4, e948 <z_clock_announce+0x40>
    e93e:	68a3      	ldr	r3, [r4, #8]
    e940:	4293      	cmp	r3, r2
    e942:	dd14      	ble.n	e96e <z_clock_announce+0x66>
		t->fn(t);
		key = k_spin_lock(&timeout_lock);
	}

	if (first() != NULL) {
		first()->dticks -= announce_remaining;
    e944:	1a9b      	subs	r3, r3, r2
    e946:	60a3      	str	r3, [r4, #8]
	}

	curr_tick += announce_remaining;
	announce_remaining = 0;
    e948:	2400      	movs	r4, #0
	curr_tick += announce_remaining;
    e94a:	eb1b 0002 	adds.w	r0, fp, r2
    e94e:	eb4c 71e2 	adc.w	r1, ip, r2, asr #31
    e952:	e9c8 0100 	strd	r0, r1, [r8]
	announce_remaining = 0;
    e956:	6034      	str	r4, [r6, #0]

	z_clock_set_timeout(next_timeout(), false);
    e958:	f7ff ff78 	bl	e84c <next_timeout>
    e95c:	4621      	mov	r1, r4
    e95e:	f7fe f8eb 	bl	cb38 <z_clock_set_timeout>
	__asm__ volatile(
    e962:	f385 8811 	msr	BASEPRI, r5
    e966:	f3bf 8f6f 	isb	sy

	k_spin_unlock(&timeout_lock, key);
}
    e96a:	e8bd 8bf0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, fp, pc}
		curr_tick += dt;
    e96e:	eb1b 0003 	adds.w	r0, fp, r3
    e972:	eb4c 71e3 	adc.w	r1, ip, r3, asr #31
		announce_remaining -= dt;
    e976:	1ad3      	subs	r3, r2, r3
    e978:	6033      	str	r3, [r6, #0]
		t->dticks = 0;
    e97a:	2300      	movs	r3, #0
		curr_tick += dt;
    e97c:	e9c7 0100 	strd	r0, r1, [r7]
		t->dticks = 0;
    e980:	60a3      	str	r3, [r4, #8]
		remove_timeout(t);
    e982:	4620      	mov	r0, r4
    e984:	f7ff ff4e 	bl	e824 <remove_timeout>
    e988:	f385 8811 	msr	BASEPRI, r5
    e98c:	f3bf 8f6f 	isb	sy
		t->fn(t);
    e990:	68e3      	ldr	r3, [r4, #12]
    e992:	4798      	blx	r3
	__asm__ volatile(
    e994:	f04f 0320 	mov.w	r3, #32
    e998:	f3ef 8511 	mrs	r5, BASEPRI
    e99c:	f383 8811 	msr	BASEPRI, r3
    e9a0:	f3bf 8f6f 	isb	sy
#endif

#ifdef SPIN_VALIDATE
	z_spin_lock_set_owner(l);
#endif
	return k;
    e9a4:	e7c3      	b.n	e92e <z_clock_announce+0x26>
    e9a6:	bf00      	nop
    e9a8:	20000000 	.word	0x20000000
    e9ac:	2000066c 	.word	0x2000066c
    e9b0:	2000140c 	.word	0x2000140c

0000e9b4 <init_static_pools>:
	z_waitq_init(&p->wait_q);
	z_sys_mem_pool_base_init(&p->base);
}

int init_static_pools(struct device *unused)
{
    e9b4:	b538      	push	{r3, r4, r5, lr}
	ARG_UNUSED(unused);

	Z_STRUCT_SECTION_FOREACH(k_mem_pool, p) {
    e9b6:	4c07      	ldr	r4, [pc, #28]	; (e9d4 <init_static_pools+0x20>)
    e9b8:	4d07      	ldr	r5, [pc, #28]	; (e9d8 <init_static_pools+0x24>)
    e9ba:	42ac      	cmp	r4, r5
    e9bc:	d301      	bcc.n	e9c2 <init_static_pools+0xe>
		k_mem_pool_init(p);
	}

	return 0;
}
    e9be:	2000      	movs	r0, #0
    e9c0:	bd38      	pop	{r3, r4, r5, pc}
	SYS_DLIST_FOR_EACH_CONTAINER(&((wq)->waitq), thread_ptr, \
				     base.qnode_dlist)

static inline void z_waitq_init(_wait_q_t *w)
{
	sys_dlist_init(&w->waitq);
    e9c2:	f104 0314 	add.w	r3, r4, #20
	z_sys_mem_pool_base_init(&p->base);
    e9c6:	4620      	mov	r0, r4
	list->tail = (sys_dnode_t *)list;
    e9c8:	e9c4 3305 	strd	r3, r3, [r4, #20]
    e9cc:	f000 feee 	bl	f7ac <z_sys_mem_pool_base_init>
	Z_STRUCT_SECTION_FOREACH(k_mem_pool, p) {
    e9d0:	341c      	adds	r4, #28
    e9d2:	e7f2      	b.n	e9ba <init_static_pools+0x6>
    e9d4:	200014d8 	.word	0x200014d8
    e9d8:	200014d8 	.word	0x200014d8

0000e9dc <CC_PalMemCopyPlat>:
    e9dc:	f001 ba45 	b.w	fe6a <memmove>

0000e9e0 <CC_PalMemSetZeroPlat>:
    e9e0:	460a      	mov	r2, r1
    e9e2:	2100      	movs	r1, #0
    e9e4:	f001 ba82 	b.w	feec <memset>

0000e9e8 <CC_PalInit>:
    e9e8:	b510      	push	{r4, lr}
    e9ea:	4811      	ldr	r0, [pc, #68]	; (ea30 <CC_PalInit+0x48>)
    e9ec:	f000 f848 	bl	ea80 <CC_PalMutexCreate>
    e9f0:	b100      	cbz	r0, e9f4 <CC_PalInit+0xc>
    e9f2:	bd10      	pop	{r4, pc}
    e9f4:	480f      	ldr	r0, [pc, #60]	; (ea34 <CC_PalInit+0x4c>)
    e9f6:	f000 f843 	bl	ea80 <CC_PalMutexCreate>
    e9fa:	2800      	cmp	r0, #0
    e9fc:	d1f9      	bne.n	e9f2 <CC_PalInit+0xa>
    e9fe:	4c0e      	ldr	r4, [pc, #56]	; (ea38 <CC_PalInit+0x50>)
    ea00:	4620      	mov	r0, r4
    ea02:	f000 f83d 	bl	ea80 <CC_PalMutexCreate>
    ea06:	2800      	cmp	r0, #0
    ea08:	d1f3      	bne.n	e9f2 <CC_PalInit+0xa>
    ea0a:	4b0c      	ldr	r3, [pc, #48]	; (ea3c <CC_PalInit+0x54>)
    ea0c:	480c      	ldr	r0, [pc, #48]	; (ea40 <CC_PalInit+0x58>)
    ea0e:	601c      	str	r4, [r3, #0]
    ea10:	f000 f836 	bl	ea80 <CC_PalMutexCreate>
    ea14:	4601      	mov	r1, r0
    ea16:	2800      	cmp	r0, #0
    ea18:	d1eb      	bne.n	e9f2 <CC_PalInit+0xa>
    ea1a:	f000 f82d 	bl	ea78 <CC_PalDmaInit>
    ea1e:	4604      	mov	r4, r0
    ea20:	b108      	cbz	r0, ea26 <CC_PalInit+0x3e>
    ea22:	4620      	mov	r0, r4
    ea24:	bd10      	pop	{r4, pc}
    ea26:	f000 f851 	bl	eacc <CC_PalPowerSaveModeInit>
    ea2a:	4620      	mov	r0, r4
    ea2c:	e7fa      	b.n	ea24 <CC_PalInit+0x3c>
    ea2e:	bf00      	nop
    ea30:	20001420 	.word	0x20001420
    ea34:	20001414 	.word	0x20001414
    ea38:	2000141c 	.word	0x2000141c
    ea3c:	20001424 	.word	0x20001424
    ea40:	20001418 	.word	0x20001418

0000ea44 <CC_PalTerminate>:
    ea44:	b508      	push	{r3, lr}
    ea46:	4808      	ldr	r0, [pc, #32]	; (ea68 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x8>)
    ea48:	f000 f824 	bl	ea94 <CC_PalMutexDestroy>
    ea4c:	4807      	ldr	r0, [pc, #28]	; (ea6c <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0xc>)
    ea4e:	f000 f821 	bl	ea94 <CC_PalMutexDestroy>
    ea52:	4807      	ldr	r0, [pc, #28]	; (ea70 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x10>)
    ea54:	f000 f81e 	bl	ea94 <CC_PalMutexDestroy>
    ea58:	4806      	ldr	r0, [pc, #24]	; (ea74 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x14>)
    ea5a:	f000 f81b 	bl	ea94 <CC_PalMutexDestroy>
    ea5e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    ea62:	f000 b80b 	b.w	ea7c <CC_PalDmaTerminate>
    ea66:	bf00      	nop
    ea68:	20001420 	.word	0x20001420
    ea6c:	20001414 	.word	0x20001414
    ea70:	2000141c 	.word	0x2000141c
    ea74:	20001418 	.word	0x20001418

0000ea78 <CC_PalDmaInit>:
    ea78:	2000      	movs	r0, #0
    ea7a:	4770      	bx	lr

0000ea7c <CC_PalDmaTerminate>:
    ea7c:	4770      	bx	lr
    ea7e:	bf00      	nop

0000ea80 <CC_PalMutexCreate>:
    ea80:	b508      	push	{r3, lr}
    ea82:	4b03      	ldr	r3, [pc, #12]	; (ea90 <CC_PalMutexCreate+0x10>)
    ea84:	6802      	ldr	r2, [r0, #0]
    ea86:	681b      	ldr	r3, [r3, #0]
    ea88:	6810      	ldr	r0, [r2, #0]
    ea8a:	4798      	blx	r3
    ea8c:	2000      	movs	r0, #0
    ea8e:	bd08      	pop	{r3, pc}
    ea90:	20001430 	.word	0x20001430

0000ea94 <CC_PalMutexDestroy>:
    ea94:	b508      	push	{r3, lr}
    ea96:	4b03      	ldr	r3, [pc, #12]	; (eaa4 <CC_PalMutexDestroy+0x10>)
    ea98:	6802      	ldr	r2, [r0, #0]
    ea9a:	685b      	ldr	r3, [r3, #4]
    ea9c:	6810      	ldr	r0, [r2, #0]
    ea9e:	4798      	blx	r3
    eaa0:	2000      	movs	r0, #0
    eaa2:	bd08      	pop	{r3, pc}
    eaa4:	20001430 	.word	0x20001430

0000eaa8 <CC_PalMutexLock>:
    eaa8:	6802      	ldr	r2, [r0, #0]
    eaaa:	4b02      	ldr	r3, [pc, #8]	; (eab4 <CC_PalMutexLock+0xc>)
    eaac:	6810      	ldr	r0, [r2, #0]
    eaae:	689b      	ldr	r3, [r3, #8]
    eab0:	4718      	bx	r3
    eab2:	bf00      	nop
    eab4:	20001430 	.word	0x20001430

0000eab8 <CC_PalMutexUnlock>:
    eab8:	b508      	push	{r3, lr}
    eaba:	4b03      	ldr	r3, [pc, #12]	; (eac8 <CC_PalMutexUnlock+0x10>)
    eabc:	6802      	ldr	r2, [r0, #0]
    eabe:	68db      	ldr	r3, [r3, #12]
    eac0:	6810      	ldr	r0, [r2, #0]
    eac2:	4798      	blx	r3
    eac4:	2000      	movs	r0, #0
    eac6:	bd08      	pop	{r3, pc}
    eac8:	20001430 	.word	0x20001430

0000eacc <CC_PalPowerSaveModeInit>:
    eacc:	b570      	push	{r4, r5, r6, lr}
    eace:	4c09      	ldr	r4, [pc, #36]	; (eaf4 <CC_PalPowerSaveModeInit+0x28>)
    ead0:	4d09      	ldr	r5, [pc, #36]	; (eaf8 <CC_PalPowerSaveModeInit+0x2c>)
    ead2:	6920      	ldr	r0, [r4, #16]
    ead4:	68ab      	ldr	r3, [r5, #8]
    ead6:	4798      	blx	r3
    ead8:	b118      	cbz	r0, eae2 <CC_PalPowerSaveModeInit+0x16>
    eada:	4b08      	ldr	r3, [pc, #32]	; (eafc <CC_PalPowerSaveModeInit+0x30>)
    eadc:	4808      	ldr	r0, [pc, #32]	; (eb00 <CC_PalPowerSaveModeInit+0x34>)
    eade:	685b      	ldr	r3, [r3, #4]
    eae0:	4798      	blx	r3
    eae2:	2100      	movs	r1, #0
    eae4:	4a07      	ldr	r2, [pc, #28]	; (eb04 <CC_PalPowerSaveModeInit+0x38>)
    eae6:	68eb      	ldr	r3, [r5, #12]
    eae8:	6011      	str	r1, [r2, #0]
    eaea:	6920      	ldr	r0, [r4, #16]
    eaec:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    eaf0:	4718      	bx	r3
    eaf2:	bf00      	nop
    eaf4:	20001440 	.word	0x20001440
    eaf8:	20001430 	.word	0x20001430
    eafc:	20001428 	.word	0x20001428
    eb00:	00010798 	.word	0x00010798
    eb04:	20000670 	.word	0x20000670

0000eb08 <CC_PalPowerSaveModeSelect>:
    eb08:	b570      	push	{r4, r5, r6, lr}
    eb0a:	4c14      	ldr	r4, [pc, #80]	; (eb5c <CC_PalPowerSaveModeSelect+0x54>)
    eb0c:	4d14      	ldr	r5, [pc, #80]	; (eb60 <CC_PalPowerSaveModeSelect+0x58>)
    eb0e:	4606      	mov	r6, r0
    eb10:	68ab      	ldr	r3, [r5, #8]
    eb12:	6920      	ldr	r0, [r4, #16]
    eb14:	4798      	blx	r3
    eb16:	b9f0      	cbnz	r0, eb56 <CC_PalPowerSaveModeSelect+0x4e>
    eb18:	4a12      	ldr	r2, [pc, #72]	; (eb64 <CC_PalPowerSaveModeSelect+0x5c>)
    eb1a:	6813      	ldr	r3, [r2, #0]
    eb1c:	b95e      	cbnz	r6, eb36 <CC_PalPowerSaveModeSelect+0x2e>
    eb1e:	b91b      	cbnz	r3, eb28 <CC_PalPowerSaveModeSelect+0x20>
    eb20:	2001      	movs	r0, #1
    eb22:	4911      	ldr	r1, [pc, #68]	; (eb68 <CC_PalPowerSaveModeSelect+0x60>)
    eb24:	f8c1 0500 	str.w	r0, [r1, #1280]	; 0x500
    eb28:	3301      	adds	r3, #1
    eb2a:	6013      	str	r3, [r2, #0]
    eb2c:	68eb      	ldr	r3, [r5, #12]
    eb2e:	6920      	ldr	r0, [r4, #16]
    eb30:	4798      	blx	r3
    eb32:	2000      	movs	r0, #0
    eb34:	bd70      	pop	{r4, r5, r6, pc}
    eb36:	2b00      	cmp	r3, #0
    eb38:	d0f8      	beq.n	eb2c <CC_PalPowerSaveModeSelect+0x24>
    eb3a:	2b01      	cmp	r3, #1
    eb3c:	bf08      	it	eq
    eb3e:	490a      	ldreq	r1, [pc, #40]	; (eb68 <CC_PalPowerSaveModeSelect+0x60>)
    eb40:	f103 33ff 	add.w	r3, r3, #4294967295	; 0xffffffff
    eb44:	bf08      	it	eq
    eb46:	f8c1 0500 	streq.w	r0, [r1, #1280]	; 0x500
    eb4a:	6920      	ldr	r0, [r4, #16]
    eb4c:	6013      	str	r3, [r2, #0]
    eb4e:	68eb      	ldr	r3, [r5, #12]
    eb50:	4798      	blx	r3
    eb52:	2000      	movs	r0, #0
    eb54:	e7ee      	b.n	eb34 <CC_PalPowerSaveModeSelect+0x2c>
    eb56:	4805      	ldr	r0, [pc, #20]	; (eb6c <CC_PalPowerSaveModeSelect+0x64>)
    eb58:	bd70      	pop	{r4, r5, r6, pc}
    eb5a:	bf00      	nop
    eb5c:	20001440 	.word	0x20001440
    eb60:	20001430 	.word	0x20001430
    eb64:	20000670 	.word	0x20000670
    eb68:	50840000 	.word	0x50840000
    eb6c:	ffff8fe9 	.word	0xffff8fe9

0000eb70 <CC_HalInit>:
    eb70:	2000      	movs	r0, #0
    eb72:	4770      	bx	lr

0000eb74 <CC_HalTerminate>:
    eb74:	2000      	movs	r0, #0
    eb76:	4770      	bx	lr

0000eb78 <CC_HalClearInterruptBit>:
    eb78:	0543      	lsls	r3, r0, #21
    eb7a:	d503      	bpl.n	eb84 <CC_HalClearInterruptBit+0xc>
    eb7c:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    eb80:	4b02      	ldr	r3, [pc, #8]	; (eb8c <CC_HalClearInterruptBit+0x14>)
    eb82:	601a      	str	r2, [r3, #0]
    eb84:	4b02      	ldr	r3, [pc, #8]	; (eb90 <CC_HalClearInterruptBit+0x18>)
    eb86:	6018      	str	r0, [r3, #0]
    eb88:	4770      	bx	lr
    eb8a:	bf00      	nop
    eb8c:	50841108 	.word	0x50841108
    eb90:	50841a08 	.word	0x50841a08

0000eb94 <CC_HalMaskInterrupt>:
    eb94:	4b01      	ldr	r3, [pc, #4]	; (eb9c <CC_HalMaskInterrupt+0x8>)
    eb96:	6018      	str	r0, [r3, #0]
    eb98:	4770      	bx	lr
    eb9a:	bf00      	nop
    eb9c:	50841a04 	.word	0x50841a04

0000eba0 <CC_HalWaitInterruptRND>:
    eba0:	b108      	cbz	r0, eba6 <CC_HalWaitInterruptRND+0x6>
    eba2:	f000 b803 	b.w	ebac <CC_PalWaitInterruptRND>
    eba6:	f44f 0075 	mov.w	r0, #16056320	; 0xf50000
    ebaa:	4770      	bx	lr

0000ebac <CC_PalWaitInterruptRND>:
    ebac:	4602      	mov	r2, r0
    ebae:	4807      	ldr	r0, [pc, #28]	; (ebcc <CC_PalWaitInterruptRND+0x20>)
    ebb0:	6803      	ldr	r3, [r0, #0]
    ebb2:	4213      	tst	r3, r2
    ebb4:	d0fc      	beq.n	ebb0 <CC_PalWaitInterruptRND+0x4>
    ebb6:	b121      	cbz	r1, ebc2 <CC_PalWaitInterruptRND+0x16>
    ebb8:	4b05      	ldr	r3, [pc, #20]	; (ebd0 <CC_PalWaitInterruptRND+0x24>)
    ebba:	4806      	ldr	r0, [pc, #24]	; (ebd4 <CC_PalWaitInterruptRND+0x28>)
    ebbc:	681b      	ldr	r3, [r3, #0]
    ebbe:	600b      	str	r3, [r1, #0]
    ebc0:	6003      	str	r3, [r0, #0]
    ebc2:	4b05      	ldr	r3, [pc, #20]	; (ebd8 <CC_PalWaitInterruptRND+0x2c>)
    ebc4:	2000      	movs	r0, #0
    ebc6:	601a      	str	r2, [r3, #0]
    ebc8:	4770      	bx	lr
    ebca:	bf00      	nop
    ebcc:	50841a00 	.word	0x50841a00
    ebd0:	50841104 	.word	0x50841104
    ebd4:	50841108 	.word	0x50841108
    ebd8:	50841a08 	.word	0x50841a08

0000ebdc <mbedtls_platform_setup>:
    ebdc:	f000 b8a0 	b.w	ed20 <nrf_cc310_platform_init>

0000ebe0 <mbedtls_platform_zeroize>:
    ebe0:	b130      	cbz	r0, ebf0 <mbedtls_platform_zeroize+0x10>
    ebe2:	b129      	cbz	r1, ebf0 <mbedtls_platform_zeroize+0x10>
    ebe4:	2300      	movs	r3, #0
    ebe6:	4401      	add	r1, r0
    ebe8:	7003      	strb	r3, [r0, #0]
    ebea:	3001      	adds	r0, #1
    ebec:	4281      	cmp	r1, r0
    ebee:	d1fb      	bne.n	ebe8 <mbedtls_platform_zeroize+0x8>
    ebf0:	4770      	bx	lr
    ebf2:	bf00      	nop

0000ebf4 <mbedtls_hardware_poll>:
    ebf4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    ebf8:	f5ad 7d1a 	sub.w	sp, sp, #616	; 0x268
    ebfc:	460f      	mov	r7, r1
    ebfe:	9205      	str	r2, [sp, #20]
    ec00:	2100      	movs	r1, #0
    ec02:	4614      	mov	r4, r2
    ec04:	a812      	add	r0, sp, #72	; 0x48
    ec06:	f44f 7208 	mov.w	r2, #544	; 0x220
    ec0a:	461e      	mov	r6, r3
    ec0c:	f001 f96e 	bl	feec <memset>
    ec10:	2300      	movs	r3, #0
    ec12:	a808      	add	r0, sp, #32
    ec14:	4619      	mov	r1, r3
    ec16:	2228      	movs	r2, #40	; 0x28
    ec18:	9306      	str	r3, [sp, #24]
    ec1a:	f001 f967 	bl	feec <memset>
    ec1e:	2f00      	cmp	r7, #0
    ec20:	d03c      	beq.n	ec9c <mbedtls_hardware_poll+0xa8>
    ec22:	2e00      	cmp	r6, #0
    ec24:	d03a      	beq.n	ec9c <mbedtls_hardware_poll+0xa8>
    ec26:	2c00      	cmp	r4, #0
    ec28:	d038      	beq.n	ec9c <mbedtls_hardware_poll+0xa8>
    ec2a:	2104      	movs	r1, #4
    ec2c:	a806      	add	r0, sp, #24
    ec2e:	f7ff fed7 	bl	e9e0 <CC_PalMemSetZeroPlat>
    ec32:	a808      	add	r0, sp, #32
    ec34:	2128      	movs	r1, #40	; 0x28
    ec36:	f7ff fed3 	bl	e9e0 <CC_PalMemSetZeroPlat>
    ec3a:	a808      	add	r0, sp, #32
    ec3c:	f000 f832 	bl	eca4 <RNG_PLAT_SetUserRngParameters>
    ec40:	b178      	cbz	r0, ec62 <mbedtls_hardware_poll+0x6e>
    ec42:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
    ec46:	a812      	add	r0, sp, #72	; 0x48
    ec48:	f44f 7108 	mov.w	r1, #544	; 0x220
    ec4c:	f7ff ffc8 	bl	ebe0 <mbedtls_platform_zeroize>
    ec50:	a806      	add	r0, sp, #24
    ec52:	2104      	movs	r1, #4
    ec54:	f7ff ffc4 	bl	ebe0 <mbedtls_platform_zeroize>
    ec58:	4628      	mov	r0, r5
    ec5a:	f50d 7d1a 	add.w	sp, sp, #616	; 0x268
    ec5e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    ec62:	ab12      	add	r3, sp, #72	; 0x48
    ec64:	f10d 081c 	add.w	r8, sp, #28
    ec68:	9003      	str	r0, [sp, #12]
    ec6a:	e9cd 6301 	strd	r6, r3, [sp, #4]
    ec6e:	4602      	mov	r2, r0
    ec70:	ab05      	add	r3, sp, #20
    ec72:	a908      	add	r1, sp, #32
    ec74:	f8cd 8000 	str.w	r8, [sp]
    ec78:	a806      	add	r0, sp, #24
    ec7a:	f000 fce9 	bl	f650 <LLF_RND_GetTrngSource>
    ec7e:	2800      	cmp	r0, #0
    ec80:	d1df      	bne.n	ec42 <mbedtls_hardware_poll+0x4e>
    ec82:	6833      	ldr	r3, [r6, #0]
    ec84:	42a3      	cmp	r3, r4
    ec86:	d3dc      	bcc.n	ec42 <mbedtls_hardware_poll+0x4e>
    ec88:	f8d8 1000 	ldr.w	r1, [r8]
    ec8c:	4605      	mov	r5, r0
    ec8e:	3108      	adds	r1, #8
    ec90:	4638      	mov	r0, r7
    ec92:	4622      	mov	r2, r4
    ec94:	f7ff fea2 	bl	e9dc <CC_PalMemCopyPlat>
    ec98:	6034      	str	r4, [r6, #0]
    ec9a:	e7d4      	b.n	ec46 <mbedtls_hardware_poll+0x52>
    ec9c:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
    eca0:	e7da      	b.n	ec58 <mbedtls_hardware_poll+0x64>
    eca2:	bf00      	nop

0000eca4 <RNG_PLAT_SetUserRngParameters>:
    eca4:	231c      	movs	r3, #28
    eca6:	b530      	push	{r4, r5, lr}
    eca8:	b083      	sub	sp, #12
    ecaa:	a902      	add	r1, sp, #8
    ecac:	f841 3d04 	str.w	r3, [r1, #-4]!
    ecb0:	4604      	mov	r4, r0
    ecb2:	f000 f9b1 	bl	f018 <CC_PalTrngParamGet>
    ecb6:	4605      	mov	r5, r0
    ecb8:	b9d8      	cbnz	r0, ecf2 <RNG_PLAT_SetUserRngParameters+0x4e>
    ecba:	9b01      	ldr	r3, [sp, #4]
    ecbc:	2b1c      	cmp	r3, #28
    ecbe:	d11b      	bne.n	ecf8 <RNG_PLAT_SetUserRngParameters+0x54>
    ecc0:	e9d4 3200 	ldrd	r3, r2, [r4]
    ecc4:	2101      	movs	r1, #1
    ecc6:	3300      	adds	r3, #0
    ecc8:	61e1      	str	r1, [r4, #28]
    ecca:	bf18      	it	ne
    eccc:	2301      	movne	r3, #1
    ecce:	b10a      	cbz	r2, ecd4 <RNG_PLAT_SetUserRngParameters+0x30>
    ecd0:	f043 0302 	orr.w	r3, r3, #2
    ecd4:	68a2      	ldr	r2, [r4, #8]
    ecd6:	b932      	cbnz	r2, ece6 <RNG_PLAT_SetUserRngParameters+0x42>
    ecd8:	68e2      	ldr	r2, [r4, #12]
    ecda:	b9aa      	cbnz	r2, ed08 <RNG_PLAT_SetUserRngParameters+0x64>
    ecdc:	e9c4 3208 	strd	r3, r2, [r4, #32]
    ece0:	b93b      	cbnz	r3, ecf2 <RNG_PLAT_SetUserRngParameters+0x4e>
    ece2:	4d0d      	ldr	r5, [pc, #52]	; (ed18 <RNG_PLAT_SetUserRngParameters+0x74>)
    ece4:	e009      	b.n	ecfa <RNG_PLAT_SetUserRngParameters+0x56>
    ece6:	68e2      	ldr	r2, [r4, #12]
    ece8:	f043 0304 	orr.w	r3, r3, #4
    ecec:	b962      	cbnz	r2, ed08 <RNG_PLAT_SetUserRngParameters+0x64>
    ecee:	e9c4 3208 	strd	r3, r2, [r4, #32]
    ecf2:	4628      	mov	r0, r5
    ecf4:	b003      	add	sp, #12
    ecf6:	bd30      	pop	{r4, r5, pc}
    ecf8:	4d08      	ldr	r5, [pc, #32]	; (ed1c <RNG_PLAT_SetUserRngParameters+0x78>)
    ecfa:	4620      	mov	r0, r4
    ecfc:	211c      	movs	r1, #28
    ecfe:	f7ff fe6f 	bl	e9e0 <CC_PalMemSetZeroPlat>
    ed02:	4628      	mov	r0, r5
    ed04:	b003      	add	sp, #12
    ed06:	bd30      	pop	{r4, r5, pc}
    ed08:	2200      	movs	r2, #0
    ed0a:	4628      	mov	r0, r5
    ed0c:	f043 0308 	orr.w	r3, r3, #8
    ed10:	e9c4 3208 	strd	r3, r2, [r4, #32]
    ed14:	b003      	add	sp, #12
    ed16:	bd30      	pop	{r4, r5, pc}
    ed18:	00f00c0e 	.word	0x00f00c0e
    ed1c:	00f00c37 	.word	0x00f00c37

0000ed20 <nrf_cc310_platform_init>:
    ed20:	b510      	push	{r4, lr}
    ed22:	4c0c      	ldr	r4, [pc, #48]	; (ed54 <nrf_cc310_platform_init+0x34>)
    ed24:	6823      	ldr	r3, [r4, #0]
    ed26:	b113      	cbz	r3, ed2e <nrf_cc310_platform_init+0xe>
    ed28:	4b0b      	ldr	r3, [pc, #44]	; (ed58 <nrf_cc310_platform_init+0x38>)
    ed2a:	681b      	ldr	r3, [r3, #0]
    ed2c:	b96b      	cbnz	r3, ed4a <nrf_cc310_platform_init+0x2a>
    ed2e:	f000 f931 	bl	ef94 <CC_LibInit>
    ed32:	b138      	cbz	r0, ed44 <nrf_cc310_platform_init+0x24>
    ed34:	3801      	subs	r0, #1
    ed36:	2806      	cmp	r0, #6
    ed38:	bf96      	itet	ls
    ed3a:	4b08      	ldrls	r3, [pc, #32]	; (ed5c <nrf_cc310_platform_init+0x3c>)
    ed3c:	4808      	ldrhi	r0, [pc, #32]	; (ed60 <nrf_cc310_platform_init+0x40>)
    ed3e:	f853 0020 	ldrls.w	r0, [r3, r0, lsl #2]
    ed42:	bd10      	pop	{r4, pc}
    ed44:	2201      	movs	r2, #1
    ed46:	4b04      	ldr	r3, [pc, #16]	; (ed58 <nrf_cc310_platform_init+0x38>)
    ed48:	601a      	str	r2, [r3, #0]
    ed4a:	2301      	movs	r3, #1
    ed4c:	2000      	movs	r0, #0
    ed4e:	6023      	str	r3, [r4, #0]
    ed50:	bd10      	pop	{r4, pc}
    ed52:	bf00      	nop
    ed54:	20000674 	.word	0x20000674
    ed58:	20000678 	.word	0x20000678
    ed5c:	000107b8 	.word	0x000107b8
    ed60:	ffff8ffe 	.word	0xffff8ffe

0000ed64 <nrf_cc310_platform_init_no_rng>:
    ed64:	b510      	push	{r4, lr}
    ed66:	4c09      	ldr	r4, [pc, #36]	; (ed8c <nrf_cc310_platform_init_no_rng+0x28>)
    ed68:	6823      	ldr	r3, [r4, #0]
    ed6a:	b11b      	cbz	r3, ed74 <nrf_cc310_platform_init_no_rng+0x10>
    ed6c:	2301      	movs	r3, #1
    ed6e:	2000      	movs	r0, #0
    ed70:	6023      	str	r3, [r4, #0]
    ed72:	bd10      	pop	{r4, pc}
    ed74:	f000 f87c 	bl	ee70 <CC_LibInitNoRng>
    ed78:	2800      	cmp	r0, #0
    ed7a:	d0f7      	beq.n	ed6c <nrf_cc310_platform_init_no_rng+0x8>
    ed7c:	3801      	subs	r0, #1
    ed7e:	2806      	cmp	r0, #6
    ed80:	bf96      	itet	ls
    ed82:	4b03      	ldrls	r3, [pc, #12]	; (ed90 <nrf_cc310_platform_init_no_rng+0x2c>)
    ed84:	4803      	ldrhi	r0, [pc, #12]	; (ed94 <nrf_cc310_platform_init_no_rng+0x30>)
    ed86:	f853 0020 	ldrls.w	r0, [r3, r0, lsl #2]
    ed8a:	bd10      	pop	{r4, pc}
    ed8c:	20000674 	.word	0x20000674
    ed90:	000107b8 	.word	0x000107b8
    ed94:	ffff8ffe 	.word	0xffff8ffe

0000ed98 <nrf_cc310_platform_abort>:
    ed98:	f3bf 8f4f 	dsb	sy
    ed9c:	4905      	ldr	r1, [pc, #20]	; (edb4 <nrf_cc310_platform_abort+0x1c>)
    ed9e:	4b06      	ldr	r3, [pc, #24]	; (edb8 <nrf_cc310_platform_abort+0x20>)
    eda0:	68ca      	ldr	r2, [r1, #12]
    eda2:	f402 62e0 	and.w	r2, r2, #1792	; 0x700
    eda6:	4313      	orrs	r3, r2
    eda8:	60cb      	str	r3, [r1, #12]
    edaa:	f3bf 8f4f 	dsb	sy
    edae:	bf00      	nop
    edb0:	e7fd      	b.n	edae <nrf_cc310_platform_abort+0x16>
    edb2:	bf00      	nop
    edb4:	e000ed00 	.word	0xe000ed00
    edb8:	05fa0004 	.word	0x05fa0004

0000edbc <CC_PalAbort>:
    edbc:	4b01      	ldr	r3, [pc, #4]	; (edc4 <CC_PalAbort+0x8>)
    edbe:	685b      	ldr	r3, [r3, #4]
    edc0:	4718      	bx	r3
    edc2:	bf00      	nop
    edc4:	20001428 	.word	0x20001428

0000edc8 <nrf_cc310_platform_set_abort>:
    edc8:	4b02      	ldr	r3, [pc, #8]	; (edd4 <nrf_cc310_platform_set_abort+0xc>)
    edca:	e9d0 1200 	ldrd	r1, r2, [r0]
    edce:	e9c3 1200 	strd	r1, r2, [r3]
    edd2:	4770      	bx	lr
    edd4:	20001428 	.word	0x20001428

0000edd8 <mutex_free>:
    edd8:	4770      	bx	lr
    edda:	bf00      	nop

0000eddc <mutex_unlock>:
    eddc:	b510      	push	{r4, lr}
    edde:	4604      	mov	r4, r0
    ede0:	b120      	cbz	r0, edec <mutex_unlock+0x10>
    ede2:	f3bf 8f5f 	dmb	sy
    ede6:	2000      	movs	r0, #0
    ede8:	6020      	str	r0, [r4, #0]
    edea:	bd10      	pop	{r4, pc}
    edec:	4803      	ldr	r0, [pc, #12]	; (edfc <mutex_unlock+0x20>)
    edee:	f7ff ffe5 	bl	edbc <CC_PalAbort>
    edf2:	f3bf 8f5f 	dmb	sy
    edf6:	2000      	movs	r0, #0
    edf8:	6020      	str	r0, [r4, #0]
    edfa:	bd10      	pop	{r4, pc}
    edfc:	000107f8 	.word	0x000107f8

0000ee00 <mutex_init>:
    ee00:	b510      	push	{r4, lr}
    ee02:	4604      	mov	r4, r0
    ee04:	b110      	cbz	r0, ee0c <mutex_init+0xc>
    ee06:	2300      	movs	r3, #0
    ee08:	6023      	str	r3, [r4, #0]
    ee0a:	bd10      	pop	{r4, pc}
    ee0c:	4802      	ldr	r0, [pc, #8]	; (ee18 <mutex_init+0x18>)
    ee0e:	f7ff ffd5 	bl	edbc <CC_PalAbort>
    ee12:	2300      	movs	r3, #0
    ee14:	6023      	str	r3, [r4, #0]
    ee16:	bd10      	pop	{r4, pc}
    ee18:	000107d4 	.word	0x000107d4

0000ee1c <mutex_lock>:
    ee1c:	b150      	cbz	r0, ee34 <mutex_lock+0x18>
    ee1e:	2201      	movs	r2, #1
    ee20:	e8d0 3fef 	ldaex	r3, [r0]
    ee24:	e8c0 2fe1 	stlex	r1, r2, [r0]
    ee28:	2900      	cmp	r1, #0
    ee2a:	d1f9      	bne.n	ee20 <mutex_lock+0x4>
    ee2c:	2b01      	cmp	r3, #1
    ee2e:	d0f7      	beq.n	ee20 <mutex_lock+0x4>
    ee30:	f3bf 8f5f 	dmb	sy
    ee34:	2000      	movs	r0, #0
    ee36:	4770      	bx	lr

0000ee38 <nrf_cc310_platform_set_mutexes>:
    ee38:	b470      	push	{r4, r5, r6}
    ee3a:	4b0b      	ldr	r3, [pc, #44]	; (ee68 <nrf_cc310_platform_set_mutexes+0x30>)
    ee3c:	6806      	ldr	r6, [r0, #0]
    ee3e:	68c2      	ldr	r2, [r0, #12]
    ee40:	e9d0 5401 	ldrd	r5, r4, [r0, #4]
    ee44:	e9c3 4202 	strd	r4, r2, [r3, #8]
    ee48:	e9c3 6500 	strd	r6, r5, [r3]
    ee4c:	e9d1 0203 	ldrd	r0, r2, [r1, #12]
    ee50:	680e      	ldr	r6, [r1, #0]
    ee52:	4b06      	ldr	r3, [pc, #24]	; (ee6c <nrf_cc310_platform_set_mutexes+0x34>)
    ee54:	e9d1 5401 	ldrd	r5, r4, [r1, #4]
    ee58:	e9c3 6500 	strd	r6, r5, [r3]
    ee5c:	e9c3 4002 	strd	r4, r0, [r3, #8]
    ee60:	611a      	str	r2, [r3, #16]
    ee62:	bc70      	pop	{r4, r5, r6}
    ee64:	4770      	bx	lr
    ee66:	bf00      	nop
    ee68:	20001430 	.word	0x20001430
    ee6c:	20001440 	.word	0x20001440

0000ee70 <CC_LibInitNoRng>:
    ee70:	b510      	push	{r4, lr}
    ee72:	f7ff fe7d 	bl	eb70 <CC_HalInit>
    ee76:	b970      	cbnz	r0, ee96 <CC_LibInitNoRng+0x26>
    ee78:	f7ff fdb6 	bl	e9e8 <CC_PalInit>
    ee7c:	b980      	cbnz	r0, eea0 <CC_LibInitNoRng+0x30>
    ee7e:	f7ff fe43 	bl	eb08 <CC_PalPowerSaveModeSelect>
    ee82:	b980      	cbnz	r0, eea6 <CC_LibInitNoRng+0x36>
    ee84:	4b11      	ldr	r3, [pc, #68]	; (eecc <CC_LibInitNoRng+0x5c>)
    ee86:	681b      	ldr	r3, [r3, #0]
    ee88:	0e1b      	lsrs	r3, r3, #24
    ee8a:	2bf0      	cmp	r3, #240	; 0xf0
    ee8c:	d00d      	beq.n	eeaa <CC_LibInitNoRng+0x3a>
    ee8e:	2406      	movs	r4, #6
    ee90:	f7ff fe70 	bl	eb74 <CC_HalTerminate>
    ee94:	e000      	b.n	ee98 <CC_LibInitNoRng+0x28>
    ee96:	2403      	movs	r4, #3
    ee98:	f7ff fdd4 	bl	ea44 <CC_PalTerminate>
    ee9c:	4620      	mov	r0, r4
    ee9e:	bd10      	pop	{r4, pc}
    eea0:	2404      	movs	r4, #4
    eea2:	4620      	mov	r0, r4
    eea4:	bd10      	pop	{r4, pc}
    eea6:	2400      	movs	r4, #0
    eea8:	e7f2      	b.n	ee90 <CC_LibInitNoRng+0x20>
    eeaa:	4a09      	ldr	r2, [pc, #36]	; (eed0 <CC_LibInitNoRng+0x60>)
    eeac:	4b09      	ldr	r3, [pc, #36]	; (eed4 <CC_LibInitNoRng+0x64>)
    eeae:	6812      	ldr	r2, [r2, #0]
    eeb0:	429a      	cmp	r2, r3
    eeb2:	d001      	beq.n	eeb8 <CC_LibInitNoRng+0x48>
    eeb4:	2407      	movs	r4, #7
    eeb6:	e7eb      	b.n	ee90 <CC_LibInitNoRng+0x20>
    eeb8:	2001      	movs	r0, #1
    eeba:	f7ff fe25 	bl	eb08 <CC_PalPowerSaveModeSelect>
    eebe:	2800      	cmp	r0, #0
    eec0:	d1f1      	bne.n	eea6 <CC_LibInitNoRng+0x36>
    eec2:	4b05      	ldr	r3, [pc, #20]	; (eed8 <CC_LibInitNoRng+0x68>)
    eec4:	4604      	mov	r4, r0
    eec6:	6018      	str	r0, [r3, #0]
    eec8:	e7e8      	b.n	ee9c <CC_LibInitNoRng+0x2c>
    eeca:	bf00      	nop
    eecc:	50841928 	.word	0x50841928
    eed0:	50841a24 	.word	0x50841a24
    eed4:	20e00000 	.word	0x20e00000
    eed8:	50841a0c 	.word	0x50841a0c

0000eedc <CC_LibInitRngModule>:
    eedc:	b530      	push	{r4, r5, lr}
    eede:	f5ad 7d15 	sub.w	sp, sp, #596	; 0x254
    eee2:	f44f 7208 	mov.w	r2, #544	; 0x220
    eee6:	2100      	movs	r1, #0
    eee8:	a80c      	add	r0, sp, #48	; 0x30
    eeea:	f000 ffff 	bl	feec <memset>
    eeee:	2300      	movs	r3, #0
    eef0:	a802      	add	r0, sp, #8
    eef2:	4619      	mov	r1, r3
    eef4:	2228      	movs	r2, #40	; 0x28
    eef6:	9301      	str	r3, [sp, #4]
    eef8:	f000 fff8 	bl	feec <memset>
    eefc:	a802      	add	r0, sp, #8
    eefe:	f7ff fed1 	bl	eca4 <RNG_PLAT_SetUserRngParameters>
    ef02:	b118      	cbz	r0, ef0c <CC_LibInitRngModule+0x30>
    ef04:	2005      	movs	r0, #5
    ef06:	f50d 7d15 	add.w	sp, sp, #596	; 0x254
    ef0a:	bd30      	pop	{r4, r5, pc}
    ef0c:	4d1c      	ldr	r5, [pc, #112]	; (ef80 <CC_LibInitRngModule+0xa4>)
    ef0e:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    ef12:	6828      	ldr	r0, [r5, #0]
    ef14:	f7ff fdc8 	bl	eaa8 <CC_PalMutexLock>
    ef18:	4604      	mov	r4, r0
    ef1a:	b9f0      	cbnz	r0, ef5a <CC_LibInitRngModule+0x7e>
    ef1c:	2000      	movs	r0, #0
    ef1e:	f7ff fdf3 	bl	eb08 <CC_PalPowerSaveModeSelect>
    ef22:	b9b0      	cbnz	r0, ef52 <CC_LibInitRngModule+0x76>
    ef24:	aa0c      	add	r2, sp, #48	; 0x30
    ef26:	a902      	add	r1, sp, #8
    ef28:	a801      	add	r0, sp, #4
    ef2a:	f000 fbd5 	bl	f6d8 <LLF_RND_RunTrngStartupTest>
    ef2e:	4604      	mov	r4, r0
    ef30:	2001      	movs	r0, #1
    ef32:	f7ff fde9 	bl	eb08 <CC_PalPowerSaveModeSelect>
    ef36:	b9f0      	cbnz	r0, ef76 <CC_LibInitRngModule+0x9a>
    ef38:	6828      	ldr	r0, [r5, #0]
    ef3a:	f7ff fdbd 	bl	eab8 <CC_PalMutexUnlock>
    ef3e:	b110      	cbz	r0, ef46 <CC_LibInitRngModule+0x6a>
    ef40:	4810      	ldr	r0, [pc, #64]	; (ef84 <CC_LibInitRngModule+0xa8>)
    ef42:	f7ff ff3b 	bl	edbc <CC_PalAbort>
    ef46:	4620      	mov	r0, r4
    ef48:	2c00      	cmp	r4, #0
    ef4a:	d1db      	bne.n	ef04 <CC_LibInitRngModule+0x28>
    ef4c:	f50d 7d15 	add.w	sp, sp, #596	; 0x254
    ef50:	bd30      	pop	{r4, r5, pc}
    ef52:	480d      	ldr	r0, [pc, #52]	; (ef88 <CC_LibInitRngModule+0xac>)
    ef54:	f7ff ff32 	bl	edbc <CC_PalAbort>
    ef58:	e7e4      	b.n	ef24 <CC_LibInitRngModule+0x48>
    ef5a:	480c      	ldr	r0, [pc, #48]	; (ef8c <CC_LibInitRngModule+0xb0>)
    ef5c:	f7ff ff2e 	bl	edbc <CC_PalAbort>
    ef60:	2c01      	cmp	r4, #1
    ef62:	d1db      	bne.n	ef1c <CC_LibInitRngModule+0x40>
    ef64:	6828      	ldr	r0, [r5, #0]
    ef66:	f7ff fda7 	bl	eab8 <CC_PalMutexUnlock>
    ef6a:	2800      	cmp	r0, #0
    ef6c:	d0ca      	beq.n	ef04 <CC_LibInitRngModule+0x28>
    ef6e:	4805      	ldr	r0, [pc, #20]	; (ef84 <CC_LibInitRngModule+0xa8>)
    ef70:	f7ff ff24 	bl	edbc <CC_PalAbort>
    ef74:	e7c6      	b.n	ef04 <CC_LibInitRngModule+0x28>
    ef76:	4806      	ldr	r0, [pc, #24]	; (ef90 <CC_LibInitRngModule+0xb4>)
    ef78:	f7ff ff20 	bl	edbc <CC_PalAbort>
    ef7c:	e7dc      	b.n	ef38 <CC_LibInitRngModule+0x5c>
    ef7e:	bf00      	nop
    ef80:	20001424 	.word	0x20001424
    ef84:	00010830 	.word	0x00010830
    ef88:	00010848 	.word	0x00010848
    ef8c:	00010818 	.word	0x00010818
    ef90:	00010868 	.word	0x00010868

0000ef94 <CC_LibInit>:
    ef94:	b508      	push	{r3, lr}
    ef96:	f7ff fdeb 	bl	eb70 <CC_HalInit>
    ef9a:	b118      	cbz	r0, efa4 <CC_LibInit+0x10>
    ef9c:	f7ff fd52 	bl	ea44 <CC_PalTerminate>
    efa0:	2003      	movs	r0, #3
    efa2:	bd08      	pop	{r3, pc}
    efa4:	f7ff fd20 	bl	e9e8 <CC_PalInit>
    efa8:	b968      	cbnz	r0, efc6 <CC_LibInit+0x32>
    efaa:	f7ff fdad 	bl	eb08 <CC_PalPowerSaveModeSelect>
    efae:	b960      	cbnz	r0, efca <CC_LibInit+0x36>
    efb0:	4b15      	ldr	r3, [pc, #84]	; (f008 <CC_LibInit+0x74>)
    efb2:	681b      	ldr	r3, [r3, #0]
    efb4:	0e1b      	lsrs	r3, r3, #24
    efb6:	2bf0      	cmp	r3, #240	; 0xf0
    efb8:	d012      	beq.n	efe0 <CC_LibInit+0x4c>
    efba:	f7ff fddb 	bl	eb74 <CC_HalTerminate>
    efbe:	f7ff fd41 	bl	ea44 <CC_PalTerminate>
    efc2:	2006      	movs	r0, #6
    efc4:	bd08      	pop	{r3, pc}
    efc6:	2004      	movs	r0, #4
    efc8:	bd08      	pop	{r3, pc}
    efca:	f7ff fdd3 	bl	eb74 <CC_HalTerminate>
    efce:	f7ff fd39 	bl	ea44 <CC_PalTerminate>
    efd2:	f7ff ff83 	bl	eedc <CC_LibInitRngModule>
    efd6:	2800      	cmp	r0, #0
    efd8:	bf0c      	ite	eq
    efda:	2000      	moveq	r0, #0
    efdc:	2005      	movne	r0, #5
    efde:	bd08      	pop	{r3, pc}
    efe0:	4a0a      	ldr	r2, [pc, #40]	; (f00c <CC_LibInit+0x78>)
    efe2:	4b0b      	ldr	r3, [pc, #44]	; (f010 <CC_LibInit+0x7c>)
    efe4:	6812      	ldr	r2, [r2, #0]
    efe6:	429a      	cmp	r2, r3
    efe8:	d005      	beq.n	eff6 <CC_LibInit+0x62>
    efea:	f7ff fdc3 	bl	eb74 <CC_HalTerminate>
    efee:	f7ff fd29 	bl	ea44 <CC_PalTerminate>
    eff2:	2007      	movs	r0, #7
    eff4:	bd08      	pop	{r3, pc}
    eff6:	2001      	movs	r0, #1
    eff8:	f7ff fd86 	bl	eb08 <CC_PalPowerSaveModeSelect>
    effc:	2800      	cmp	r0, #0
    effe:	d1e4      	bne.n	efca <CC_LibInit+0x36>
    f000:	4b04      	ldr	r3, [pc, #16]	; (f014 <CC_LibInit+0x80>)
    f002:	6018      	str	r0, [r3, #0]
    f004:	e7e5      	b.n	efd2 <CC_LibInit+0x3e>
    f006:	bf00      	nop
    f008:	50841928 	.word	0x50841928
    f00c:	50841a24 	.word	0x50841a24
    f010:	20e00000 	.word	0x20e00000
    f014:	50841a0c 	.word	0x50841a0c

0000f018 <CC_PalTrngParamGet>:
    f018:	b118      	cbz	r0, f022 <CC_PalTrngParamGet+0xa>
    f01a:	b111      	cbz	r1, f022 <CC_PalTrngParamGet+0xa>
    f01c:	680b      	ldr	r3, [r1, #0]
    f01e:	2b1c      	cmp	r3, #28
    f020:	d001      	beq.n	f026 <CC_PalTrngParamGet+0xe>
    f022:	2001      	movs	r0, #1
    f024:	4770      	bx	lr
    f026:	f44f 037f 	mov.w	r3, #16711680	; 0xff0000
    f02a:	4a3a      	ldr	r2, [pc, #232]	; (f114 <CC_PalTrngParamGet+0xfc>)
    f02c:	f8d3 1c10 	ldr.w	r1, [r3, #3088]	; 0xc10
    f030:	4291      	cmp	r1, r2
    f032:	d05a      	beq.n	f0ea <CC_PalTrngParamGet+0xd2>
    f034:	f8d3 2c10 	ldr.w	r2, [r3, #3088]	; 0xc10
    f038:	3201      	adds	r2, #1
    f03a:	d056      	beq.n	f0ea <CC_PalTrngParamGet+0xd2>
    f03c:	f8d3 2c10 	ldr.w	r2, [r3, #3088]	; 0xc10
    f040:	f44f 037f 	mov.w	r3, #16711680	; 0xff0000
    f044:	6002      	str	r2, [r0, #0]
    f046:	f8d3 1c14 	ldr.w	r1, [r3, #3092]	; 0xc14
    f04a:	4a33      	ldr	r2, [pc, #204]	; (f118 <CC_PalTrngParamGet+0x100>)
    f04c:	4291      	cmp	r1, r2
    f04e:	d05e      	beq.n	f10e <CC_PalTrngParamGet+0xf6>
    f050:	f8d3 2c14 	ldr.w	r2, [r3, #3092]	; 0xc14
    f054:	3201      	adds	r2, #1
    f056:	d05a      	beq.n	f10e <CC_PalTrngParamGet+0xf6>
    f058:	f8d3 2c14 	ldr.w	r2, [r3, #3092]	; 0xc14
    f05c:	f44f 037f 	mov.w	r3, #16711680	; 0xff0000
    f060:	6042      	str	r2, [r0, #4]
    f062:	f8d3 2c18 	ldr.w	r2, [r3, #3096]	; 0xc18
    f066:	f512 7f94 	cmn.w	r2, #296	; 0x128
    f06a:	d04d      	beq.n	f108 <CC_PalTrngParamGet+0xf0>
    f06c:	f8d3 2c18 	ldr.w	r2, [r3, #3096]	; 0xc18
    f070:	3201      	adds	r2, #1
    f072:	d049      	beq.n	f108 <CC_PalTrngParamGet+0xf0>
    f074:	f8d3 2c18 	ldr.w	r2, [r3, #3096]	; 0xc18
    f078:	f44f 037f 	mov.w	r3, #16711680	; 0xff0000
    f07c:	6082      	str	r2, [r0, #8]
    f07e:	f8d3 1c1c 	ldr.w	r1, [r3, #3100]	; 0xc1c
    f082:	4a26      	ldr	r2, [pc, #152]	; (f11c <CC_PalTrngParamGet+0x104>)
    f084:	4291      	cmp	r1, r2
    f086:	d03c      	beq.n	f102 <CC_PalTrngParamGet+0xea>
    f088:	f8d3 2c1c 	ldr.w	r2, [r3, #3100]	; 0xc1c
    f08c:	3201      	adds	r2, #1
    f08e:	d038      	beq.n	f102 <CC_PalTrngParamGet+0xea>
    f090:	f8d3 2c1c 	ldr.w	r2, [r3, #3100]	; 0xc1c
    f094:	f44f 037f 	mov.w	r3, #16711680	; 0xff0000
    f098:	60c2      	str	r2, [r0, #12]
    f09a:	f8d3 2c00 	ldr.w	r2, [r3, #3072]	; 0xc00
    f09e:	3270      	adds	r2, #112	; 0x70
    f0a0:	d02d      	beq.n	f0fe <CC_PalTrngParamGet+0xe6>
    f0a2:	f8d3 2c00 	ldr.w	r2, [r3, #3072]	; 0xc00
    f0a6:	3201      	adds	r2, #1
    f0a8:	d029      	beq.n	f0fe <CC_PalTrngParamGet+0xe6>
    f0aa:	f8d3 2c00 	ldr.w	r2, [r3, #3072]	; 0xc00
    f0ae:	f44f 037f 	mov.w	r3, #16711680	; 0xff0000
    f0b2:	6102      	str	r2, [r0, #16]
    f0b4:	f8d3 2c04 	ldr.w	r2, [r3, #3076]	; 0xc04
    f0b8:	32af      	adds	r2, #175	; 0xaf
    f0ba:	d01e      	beq.n	f0fa <CC_PalTrngParamGet+0xe2>
    f0bc:	f8d3 2c04 	ldr.w	r2, [r3, #3076]	; 0xc04
    f0c0:	3201      	adds	r2, #1
    f0c2:	d01a      	beq.n	f0fa <CC_PalTrngParamGet+0xe2>
    f0c4:	f8d3 2c04 	ldr.w	r2, [r3, #3076]	; 0xc04
    f0c8:	f44f 037f 	mov.w	r3, #16711680	; 0xff0000
    f0cc:	6142      	str	r2, [r0, #20]
    f0ce:	f8d3 1c08 	ldr.w	r1, [r3, #3080]	; 0xc08
    f0d2:	4a13      	ldr	r2, [pc, #76]	; (f120 <CC_PalTrngParamGet+0x108>)
    f0d4:	4291      	cmp	r1, r2
    f0d6:	d00b      	beq.n	f0f0 <CC_PalTrngParamGet+0xd8>
    f0d8:	f8d3 2c08 	ldr.w	r2, [r3, #3080]	; 0xc08
    f0dc:	3201      	adds	r2, #1
    f0de:	d007      	beq.n	f0f0 <CC_PalTrngParamGet+0xd8>
    f0e0:	f8d3 3c08 	ldr.w	r3, [r3, #3080]	; 0xc08
    f0e4:	6183      	str	r3, [r0, #24]
    f0e6:	2000      	movs	r0, #0
    f0e8:	4770      	bx	lr
    f0ea:	f640 02fc 	movw	r2, #2300	; 0x8fc
    f0ee:	e7a7      	b.n	f040 <CC_PalTrngParamGet+0x28>
    f0f0:	f240 3337 	movw	r3, #823	; 0x337
    f0f4:	6183      	str	r3, [r0, #24]
    f0f6:	2000      	movs	r0, #0
    f0f8:	4770      	bx	lr
    f0fa:	2251      	movs	r2, #81	; 0x51
    f0fc:	e7e4      	b.n	f0c8 <CC_PalTrngParamGet+0xb0>
    f0fe:	2290      	movs	r2, #144	; 0x90
    f100:	e7d5      	b.n	f0ae <CC_PalTrngParamGet+0x96>
    f102:	f642 1204 	movw	r2, #10500	; 0x2904
    f106:	e7c5      	b.n	f094 <CC_PalTrngParamGet+0x7c>
    f108:	f640 62d8 	movw	r2, #3800	; 0xed8
    f10c:	e7b4      	b.n	f078 <CC_PalTrngParamGet+0x60>
    f10e:	f242 02d0 	movw	r2, #8400	; 0x20d0
    f112:	e7a3      	b.n	f05c <CC_PalTrngParamGet+0x44>
    f114:	fffff8fc 	.word	0xfffff8fc
    f118:	ffff20d0 	.word	0xffff20d0
    f11c:	ffff2904 	.word	0xffff2904
    f120:	fffff337 	.word	0xfffff337

0000f124 <LLF_RND_AdaptiveProportionTest>:
    f124:	b3a8      	cbz	r0, f192 <LLF_RND_AdaptiveProportionTest+0x6e>
    f126:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    f12a:	1e4c      	subs	r4, r1, #1
    f12c:	f5b4 7f04 	cmp.w	r4, #528	; 0x210
    f130:	d22c      	bcs.n	f18c <LLF_RND_AdaptiveProportionTest+0x68>
    f132:	b35b      	cbz	r3, f18c <LLF_RND_AdaptiveProportionTest+0x68>
    f134:	b352      	cbz	r2, f18c <LLF_RND_AdaptiveProportionTest+0x68>
    f136:	f04f 0c00 	mov.w	ip, #0
    f13a:	00c9      	lsls	r1, r1, #3
    f13c:	46e6      	mov	lr, ip
    f13e:	4665      	mov	r5, ip
    f140:	4664      	mov	r4, ip
    f142:	1e4f      	subs	r7, r1, #1
    f144:	f103 38ff 	add.w	r8, r3, #4294967295	; 0xffffffff
    f148:	e00c      	b.n	f164 <LLF_RND_AdaptiveProportionTest+0x40>
    f14a:	42ab      	cmp	r3, r5
    f14c:	d016      	beq.n	f17c <LLF_RND_AdaptiveProportionTest+0x58>
    f14e:	458e      	cmp	lr, r1
    f150:	d101      	bne.n	f156 <LLF_RND_AdaptiveProportionTest+0x32>
    f152:	f10c 0c01 	add.w	ip, ip, #1
    f156:	45a8      	cmp	r8, r5
    f158:	d016      	beq.n	f188 <LLF_RND_AdaptiveProportionTest+0x64>
    f15a:	3401      	adds	r4, #1
    f15c:	42bc      	cmp	r4, r7
    f15e:	f105 0501 	add.w	r5, r5, #1
    f162:	d818      	bhi.n	f196 <LLF_RND_AdaptiveProportionTest+0x72>
    f164:	0961      	lsrs	r1, r4, #5
    f166:	f850 1021 	ldr.w	r1, [r0, r1, lsl #2]
    f16a:	f004 061f 	and.w	r6, r4, #31
    f16e:	40f1      	lsrs	r1, r6
    f170:	2e1f      	cmp	r6, #31
    f172:	bf18      	it	ne
    f174:	f001 0101 	andne.w	r1, r1, #1
    f178:	2c00      	cmp	r4, #0
    f17a:	d1e6      	bne.n	f14a <LLF_RND_AdaptiveProportionTest+0x26>
    f17c:	2500      	movs	r5, #0
    f17e:	45a8      	cmp	r8, r5
    f180:	468e      	mov	lr, r1
    f182:	f04f 0c01 	mov.w	ip, #1
    f186:	d1e8      	bne.n	f15a <LLF_RND_AdaptiveProportionTest+0x36>
    f188:	4562      	cmp	r2, ip
    f18a:	d2e6      	bcs.n	f15a <LLF_RND_AdaptiveProportionTest+0x36>
    f18c:	4803      	ldr	r0, [pc, #12]	; (f19c <LLF_RND_AdaptiveProportionTest+0x78>)
    f18e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    f192:	4802      	ldr	r0, [pc, #8]	; (f19c <LLF_RND_AdaptiveProportionTest+0x78>)
    f194:	4770      	bx	lr
    f196:	2000      	movs	r0, #0
    f198:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    f19c:	00f10c37 	.word	0x00f10c37

0000f1a0 <getTrngSource>:
    f1a0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    f1a4:	b08f      	sub	sp, #60	; 0x3c
    f1a6:	460d      	mov	r5, r1
    f1a8:	e9dd 4119 	ldrd	r4, r1, [sp, #100]	; 0x64
    f1ac:	4683      	mov	fp, r0
    f1ae:	2900      	cmp	r1, #0
    f1b0:	d157      	bne.n	f262 <getTrngSource+0xc2>
    f1b2:	6929      	ldr	r1, [r5, #16]
    f1b4:	9103      	str	r1, [sp, #12]
    f1b6:	2100      	movs	r1, #0
    f1b8:	601c      	str	r4, [r3, #0]
    f1ba:	9b18      	ldr	r3, [sp, #96]	; 0x60
    f1bc:	6019      	str	r1, [r3, #0]
    f1be:	2a00      	cmp	r2, #0
    f1c0:	f000 8122 	beq.w	f408 <getTrngSource+0x268>
    f1c4:	4a81      	ldr	r2, [pc, #516]	; (f3cc <getTrngSource+0x22c>)
    f1c6:	4b82      	ldr	r3, [pc, #520]	; (f3d0 <getTrngSource+0x230>)
    f1c8:	6811      	ldr	r1, [r2, #0]
    f1ca:	6a6a      	ldr	r2, [r5, #36]	; 0x24
    f1cc:	681b      	ldr	r3, [r3, #0]
    f1ce:	429a      	cmp	r2, r3
    f1d0:	d157      	bne.n	f282 <getTrngSource+0xe2>
    f1d2:	290a      	cmp	r1, #10
    f1d4:	d155      	bne.n	f282 <getTrngSource+0xe2>
    f1d6:	f89b 3003 	ldrb.w	r3, [fp, #3]
    f1da:	9306      	str	r3, [sp, #24]
    f1dc:	9903      	ldr	r1, [sp, #12]
    f1de:	2304      	movs	r3, #4
    f1e0:	4608      	mov	r0, r1
    f1e2:	4a7c      	ldr	r2, [pc, #496]	; (f3d4 <getTrngSource+0x234>)
    f1e4:	9302      	str	r3, [sp, #8]
    f1e6:	fba2 0200 	umull	r0, r2, r2, r0
    f1ea:	0892      	lsrs	r2, r2, #2
    f1ec:	00cb      	lsls	r3, r1, #3
    f1ee:	eb02 0242 	add.w	r2, r2, r2, lsl #1
    f1f2:	f104 0008 	add.w	r0, r4, #8
    f1f6:	eba1 0242 	sub.w	r2, r1, r2, lsl #1
    f1fa:	3b01      	subs	r3, #1
    f1fc:	f8df 91d0 	ldr.w	r9, [pc, #464]	; f3d0 <getTrngSource+0x230>
    f200:	f8df a200 	ldr.w	sl, [pc, #512]	; f404 <getTrngSource+0x264>
    f204:	9004      	str	r0, [sp, #16]
    f206:	9200      	str	r2, [sp, #0]
    f208:	9305      	str	r3, [sp, #20]
    f20a:	9b18      	ldr	r3, [sp, #96]	; 0x60
    f20c:	9c03      	ldr	r4, [sp, #12]
    f20e:	601c      	str	r4, [r3, #0]
    f210:	2c00      	cmp	r4, #0
    f212:	f000 80cc 	beq.w	f3ae <getTrngSource+0x20e>
    f216:	2600      	movs	r6, #0
    f218:	9f04      	ldr	r7, [sp, #16]
    f21a:	f000 faa9 	bl	f770 <LLF_RND_TurnOffTrng>
    f21e:	2300      	movs	r3, #0
    f220:	9307      	str	r3, [sp, #28]
    f222:	9b06      	ldr	r3, [sp, #24]
    f224:	f1bb 0f00 	cmp.w	fp, #0
    f228:	d03a      	beq.n	f2a0 <getTrngSource+0x100>
    f22a:	2d00      	cmp	r5, #0
    f22c:	d034      	beq.n	f298 <getTrngSource+0xf8>
    f22e:	bb53      	cbnz	r3, f286 <getTrngSource+0xe6>
    f230:	005b      	lsls	r3, r3, #1
    f232:	9306      	str	r3, [sp, #24]
    f234:	f1bb 0f00 	cmp.w	fp, #0
    f238:	d036      	beq.n	f2a8 <getTrngSource+0x108>
    f23a:	2d00      	cmp	r5, #0
    f23c:	d034      	beq.n	f2a8 <getTrngSource+0x108>
    f23e:	b1e3      	cbz	r3, f27a <getTrngSource+0xda>
    f240:	a906      	add	r1, sp, #24
    f242:	4628      	mov	r0, r5
    f244:	f000 fa84 	bl	f750 <LLF_RND_GetFastestRosc>
    f248:	2800      	cmp	r0, #0
    f24a:	f000 817d 	beq.w	f548 <getTrngSource+0x3a8>
    f24e:	4b62      	ldr	r3, [pc, #392]	; (f3d8 <getTrngSource+0x238>)
    f250:	4298      	cmp	r0, r3
    f252:	d012      	beq.n	f27a <getTrngSource+0xda>
    f254:	9000      	str	r0, [sp, #0]
    f256:	f000 fa8b 	bl	f770 <LLF_RND_TurnOffTrng>
    f25a:	9800      	ldr	r0, [sp, #0]
    f25c:	b00f      	add	sp, #60	; 0x3c
    f25e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    f262:	f44f 017f 	mov.w	r1, #16711680	; 0xff0000
    f266:	f8d1 0c0c 	ldr.w	r0, [r1, #3084]	; 0xc0c
    f26a:	3001      	adds	r0, #1
    f26c:	bf0c      	ite	eq
    f26e:	f44f 7104 	moveq.w	r1, #528	; 0x210
    f272:	f8d1 1c0c 	ldrne.w	r1, [r1, #3084]	; 0xc0c
    f276:	9103      	str	r1, [sp, #12]
    f278:	e79d      	b.n	f1b6 <getTrngSource+0x16>
    f27a:	6a2b      	ldr	r3, [r5, #32]
    f27c:	b973      	cbnz	r3, f29c <getTrngSource+0xfc>
    f27e:	4856      	ldr	r0, [pc, #344]	; (f3d8 <getTrngSource+0x238>)
    f280:	e7e8      	b.n	f254 <getTrngSource+0xb4>
    f282:	4856      	ldr	r0, [pc, #344]	; (f3dc <getTrngSource+0x23c>)
    f284:	e7e6      	b.n	f254 <getTrngSource+0xb4>
    f286:	a906      	add	r1, sp, #24
    f288:	4628      	mov	r0, r5
    f28a:	f000 fa61 	bl	f750 <LLF_RND_GetFastestRosc>
    f28e:	b168      	cbz	r0, f2ac <getTrngSource+0x10c>
    f290:	4b53      	ldr	r3, [pc, #332]	; (f3e0 <getTrngSource+0x240>)
    f292:	4298      	cmp	r0, r3
    f294:	d0de      	beq.n	f254 <getTrngSource+0xb4>
    f296:	9b06      	ldr	r3, [sp, #24]
    f298:	2b08      	cmp	r3, #8
    f29a:	d1c9      	bne.n	f230 <getTrngSource+0x90>
    f29c:	4851      	ldr	r0, [pc, #324]	; (f3e4 <getTrngSource+0x244>)
    f29e:	e7d9      	b.n	f254 <getTrngSource+0xb4>
    f2a0:	2b08      	cmp	r3, #8
    f2a2:	d0fb      	beq.n	f29c <getTrngSource+0xfc>
    f2a4:	005b      	lsls	r3, r3, #1
    f2a6:	9306      	str	r3, [sp, #24]
    f2a8:	484f      	ldr	r0, [pc, #316]	; (f3e8 <getTrngSource+0x248>)
    f2aa:	e7d3      	b.n	f254 <getTrngSource+0xb4>
    f2ac:	4629      	mov	r1, r5
    f2ae:	9806      	ldr	r0, [sp, #24]
    f2b0:	f000 fa30 	bl	f714 <LLF_RND_GetRoscSampleCnt>
    f2b4:	2800      	cmp	r0, #0
    f2b6:	d1eb      	bne.n	f290 <getTrngSource+0xf0>
    f2b8:	9b06      	ldr	r3, [sp, #24]
    f2ba:	2b08      	cmp	r3, #8
    f2bc:	f000 810e 	beq.w	f4dc <getTrngSource+0x33c>
    f2c0:	2b04      	cmp	r3, #4
    f2c2:	f000 8131 	beq.w	f528 <getTrngSource+0x388>
    f2c6:	f1a3 0302 	sub.w	r3, r3, #2
    f2ca:	fab3 f383 	clz	r3, r3
    f2ce:	095b      	lsrs	r3, r3, #5
    f2d0:	9301      	str	r3, [sp, #4]
    f2d2:	2301      	movs	r3, #1
    f2d4:	4619      	mov	r1, r3
    f2d6:	4a45      	ldr	r2, [pc, #276]	; (f3ec <getTrngSource+0x24c>)
    f2d8:	6013      	str	r3, [r2, #0]
    f2da:	f842 3c84 	str.w	r3, [r2, #-132]
    f2de:	4b43      	ldr	r3, [pc, #268]	; (f3ec <getTrngSource+0x24c>)
    f2e0:	6019      	str	r1, [r3, #0]
    f2e2:	6a6b      	ldr	r3, [r5, #36]	; 0x24
    f2e4:	f8c9 3000 	str.w	r3, [r9]
    f2e8:	f8d9 2000 	ldr.w	r2, [r9]
    f2ec:	6a6b      	ldr	r3, [r5, #36]	; 0x24
    f2ee:	429a      	cmp	r2, r3
    f2f0:	d1f5      	bne.n	f2de <getTrngSource+0x13e>
    f2f2:	f04f 0800 	mov.w	r8, #0
    f2f6:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    f2fa:	f8ca 8000 	str.w	r8, [sl]
    f2fe:	f7ff fc3b 	bl	eb78 <CC_HalClearInterruptBit>
    f302:	4a3b      	ldr	r2, [pc, #236]	; (f3f0 <getTrngSource+0x250>)
    f304:	4b3b      	ldr	r3, [pc, #236]	; (f3f4 <getTrngSource+0x254>)
    f306:	4640      	mov	r0, r8
    f308:	601a      	str	r2, [r3, #0]
    f30a:	f7ff fc43 	bl	eb94 <CC_HalMaskInterrupt>
    f30e:	220a      	movs	r2, #10
    f310:	9801      	ldr	r0, [sp, #4]
    f312:	4939      	ldr	r1, [pc, #228]	; (f3f8 <getTrngSource+0x258>)
    f314:	4b2d      	ldr	r3, [pc, #180]	; (f3cc <getTrngSource+0x22c>)
    f316:	6008      	str	r0, [r1, #0]
    f318:	601a      	str	r2, [r3, #0]
    f31a:	692a      	ldr	r2, [r5, #16]
    f31c:	f1a8 3855 	sub.w	r8, r8, #1431655765	; 0x55555555
    f320:	fba8 1202 	umull	r1, r2, r8, r2
    f324:	6a6b      	ldr	r3, [r5, #36]	; 0x24
    f326:	0912      	lsrs	r2, r2, #4
    f328:	eb03 0343 	add.w	r3, r3, r3, lsl #1
    f32c:	03db      	lsls	r3, r3, #15
    f32e:	fb03 f302 	mul.w	r3, r3, r2
    f332:	4a32      	ldr	r2, [pc, #200]	; (f3fc <getTrngSource+0x25c>)
    f334:	099b      	lsrs	r3, r3, #6
    f336:	6013      	str	r3, [r2, #0]
    f338:	2301      	movs	r3, #1
    f33a:	f8ca 3000 	str.w	r3, [sl]
    f33e:	9906      	ldr	r1, [sp, #24]
    f340:	f8db 2000 	ldr.w	r2, [fp]
    f344:	020b      	lsls	r3, r1, #8
    f346:	ea43 6301 	orr.w	r3, r3, r1, lsl #24
    f34a:	f022 427f 	bic.w	r2, r2, #4278190080	; 0xff000000
    f34e:	4313      	orrs	r3, r2
    f350:	f8cb 3000 	str.w	r3, [fp]
    f354:	a807      	add	r0, sp, #28
    f356:	f000 f9cd 	bl	f6f4 <LLF_RND_WaitRngInterrupt>
    f35a:	2800      	cmp	r0, #0
    f35c:	d198      	bne.n	f290 <getTrngSource+0xf0>
    f35e:	4b28      	ldr	r3, [pc, #160]	; (f400 <getTrngSource+0x260>)
    f360:	fba8 2804 	umull	r2, r8, r8, r4
    f364:	681a      	ldr	r2, [r3, #0]
    f366:	3314      	adds	r3, #20
    f368:	9208      	str	r2, [sp, #32]
    f36a:	f853 2c10 	ldr.w	r2, [r3, #-16]
    f36e:	ebb6 0f98 	cmp.w	r6, r8, lsr #2
    f372:	9209      	str	r2, [sp, #36]	; 0x24
    f374:	f853 2c0c 	ldr.w	r2, [r3, #-12]
    f378:	920a      	str	r2, [sp, #40]	; 0x28
    f37a:	f853 2c08 	ldr.w	r2, [r3, #-8]
    f37e:	920b      	str	r2, [sp, #44]	; 0x2c
    f380:	f853 2c04 	ldr.w	r2, [r3, #-4]
    f384:	920c      	str	r2, [sp, #48]	; 0x30
    f386:	681b      	ldr	r3, [r3, #0]
    f388:	930d      	str	r3, [sp, #52]	; 0x34
    f38a:	d101      	bne.n	f390 <getTrngSource+0x1f0>
    f38c:	9b00      	ldr	r3, [sp, #0]
    f38e:	b99b      	cbnz	r3, f3b8 <getTrngSource+0x218>
    f390:	4638      	mov	r0, r7
    f392:	2218      	movs	r2, #24
    f394:	a908      	add	r1, sp, #32
    f396:	f7ff fb21 	bl	e9dc <CC_PalMemCopyPlat>
    f39a:	3c18      	subs	r4, #24
    f39c:	3718      	adds	r7, #24
    f39e:	3601      	adds	r6, #1
    f3a0:	2c00      	cmp	r4, #0
    f3a2:	f47f af3a 	bne.w	f21a <getTrngSource+0x7a>
    f3a6:	9b04      	ldr	r3, [sp, #16]
    f3a8:	2b00      	cmp	r3, #0
    f3aa:	f040 809a 	bne.w	f4e2 <getTrngSource+0x342>
    f3ae:	2300      	movs	r3, #0
    f3b0:	9a18      	ldr	r2, [sp, #96]	; 0x60
    f3b2:	6013      	str	r3, [r2, #0]
    f3b4:	9b06      	ldr	r3, [sp, #24]
    f3b6:	e76f      	b.n	f298 <getTrngSource+0xf8>
    f3b8:	461a      	mov	r2, r3
    f3ba:	4638      	mov	r0, r7
    f3bc:	a908      	add	r1, sp, #32
    f3be:	1ae4      	subs	r4, r4, r3
    f3c0:	f7ff fb0c 	bl	e9dc <CC_PalMemCopyPlat>
    f3c4:	9b00      	ldr	r3, [sp, #0]
    f3c6:	441f      	add	r7, r3
    f3c8:	e7e9      	b.n	f39e <getTrngSource+0x1fe>
    f3ca:	bf00      	nop
    f3cc:	50841138 	.word	0x50841138
    f3d0:	50841130 	.word	0x50841130
    f3d4:	aaaaaaab 	.word	0xaaaaaaab
    f3d8:	00f10c31 	.word	0x00f10c31
    f3dc:	00f10c30 	.word	0x00f10c30
    f3e0:	00f10c02 	.word	0x00f10c02
    f3e4:	00f10c32 	.word	0x00f10c32
    f3e8:	00f10c35 	.word	0x00f10c35
    f3ec:	508411c4 	.word	0x508411c4
    f3f0:	0ffffffe 	.word	0x0ffffffe
    f3f4:	50841100 	.word	0x50841100
    f3f8:	5084110c 	.word	0x5084110c
    f3fc:	508411d8 	.word	0x508411d8
    f400:	50841114 	.word	0x50841114
    f404:	5084112c 	.word	0x5084112c
    f408:	f1bb 0f00 	cmp.w	fp, #0
    f40c:	f43f af4c 	beq.w	f2a8 <getTrngSource+0x108>
    f410:	2d00      	cmp	r5, #0
    f412:	f43f af49 	beq.w	f2a8 <getTrngSource+0x108>
    f416:	2301      	movs	r3, #1
    f418:	a90e      	add	r1, sp, #56	; 0x38
    f41a:	f841 3d20 	str.w	r3, [r1, #-32]!
    f41e:	f8cb 2000 	str.w	r2, [fp]
    f422:	4628      	mov	r0, r5
    f424:	f000 f994 	bl	f750 <LLF_RND_GetFastestRosc>
    f428:	2800      	cmp	r0, #0
    f42a:	f47f af13 	bne.w	f254 <getTrngSource+0xb4>
    f42e:	4629      	mov	r1, r5
    f430:	9806      	ldr	r0, [sp, #24]
    f432:	f000 f96f 	bl	f714 <LLF_RND_GetRoscSampleCnt>
    f436:	2800      	cmp	r0, #0
    f438:	f47f af0c 	bne.w	f254 <getTrngSource+0xb4>
    f43c:	9f06      	ldr	r7, [sp, #24]
    f43e:	2f08      	cmp	r7, #8
    f440:	f000 80eb 	beq.w	f61a <getTrngSource+0x47a>
    f444:	2f04      	cmp	r7, #4
    f446:	f000 80ea 	beq.w	f61e <getTrngSource+0x47e>
    f44a:	f1a7 0702 	sub.w	r7, r7, #2
    f44e:	fab7 f787 	clz	r7, r7
    f452:	097f      	lsrs	r7, r7, #5
    f454:	2201      	movs	r2, #1
    f456:	4616      	mov	r6, r2
    f458:	4b73      	ldr	r3, [pc, #460]	; (f628 <getTrngSource+0x488>)
    f45a:	4974      	ldr	r1, [pc, #464]	; (f62c <getTrngSource+0x48c>)
    f45c:	601a      	str	r2, [r3, #0]
    f45e:	4618      	mov	r0, r3
    f460:	600a      	str	r2, [r1, #0]
    f462:	3b94      	subs	r3, #148	; 0x94
    f464:	6006      	str	r6, [r0, #0]
    f466:	6a6a      	ldr	r2, [r5, #36]	; 0x24
    f468:	601a      	str	r2, [r3, #0]
    f46a:	6819      	ldr	r1, [r3, #0]
    f46c:	6a6a      	ldr	r2, [r5, #36]	; 0x24
    f46e:	4291      	cmp	r1, r2
    f470:	d1f8      	bne.n	f464 <getTrngSource+0x2c4>
    f472:	f04f 0800 	mov.w	r8, #0
    f476:	4b6e      	ldr	r3, [pc, #440]	; (f630 <getTrngSource+0x490>)
    f478:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    f47c:	f8c3 8000 	str.w	r8, [r3]
    f480:	f7ff fb7a 	bl	eb78 <CC_HalClearInterruptBit>
    f484:	4b6b      	ldr	r3, [pc, #428]	; (f634 <getTrngSource+0x494>)
    f486:	4a6c      	ldr	r2, [pc, #432]	; (f638 <getTrngSource+0x498>)
    f488:	4640      	mov	r0, r8
    f48a:	601a      	str	r2, [r3, #0]
    f48c:	f7ff fb82 	bl	eb94 <CC_HalMaskInterrupt>
    f490:	220a      	movs	r2, #10
    f492:	496a      	ldr	r1, [pc, #424]	; (f63c <getTrngSource+0x49c>)
    f494:	4b6a      	ldr	r3, [pc, #424]	; (f640 <getTrngSource+0x4a0>)
    f496:	600f      	str	r7, [r1, #0]
    f498:	601a      	str	r2, [r3, #0]
    f49a:	991a      	ldr	r1, [sp, #104]	; 0x68
    f49c:	692b      	ldr	r3, [r5, #16]
    f49e:	2901      	cmp	r1, #1
    f4a0:	6a6a      	ldr	r2, [r5, #36]	; 0x24
    f4a2:	f000 80b1 	beq.w	f608 <getTrngSource+0x468>
    f4a6:	4967      	ldr	r1, [pc, #412]	; (f644 <getTrngSource+0x4a4>)
    f4a8:	fba1 1303 	umull	r1, r3, r1, r3
    f4ac:	091b      	lsrs	r3, r3, #4
    f4ae:	2101      	movs	r1, #1
    f4b0:	eb02 0242 	add.w	r2, r2, r2, lsl #1
    f4b4:	03d2      	lsls	r2, r2, #15
    f4b6:	fb03 f302 	mul.w	r3, r3, r2
    f4ba:	4a63      	ldr	r2, [pc, #396]	; (f648 <getTrngSource+0x4a8>)
    f4bc:	099b      	lsrs	r3, r3, #6
    f4be:	6013      	str	r3, [r2, #0]
    f4c0:	4b5b      	ldr	r3, [pc, #364]	; (f630 <getTrngSource+0x490>)
    f4c2:	6019      	str	r1, [r3, #0]
    f4c4:	9906      	ldr	r1, [sp, #24]
    f4c6:	f8db 2000 	ldr.w	r2, [fp]
    f4ca:	020b      	lsls	r3, r1, #8
    f4cc:	ea43 6301 	orr.w	r3, r3, r1, lsl #24
    f4d0:	f022 427f 	bic.w	r2, r2, #4278190080	; 0xff000000
    f4d4:	4313      	orrs	r3, r2
    f4d6:	f8cb 3000 	str.w	r3, [fp]
    f4da:	e67f      	b.n	f1dc <getTrngSource+0x3c>
    f4dc:	2303      	movs	r3, #3
    f4de:	9301      	str	r3, [sp, #4]
    f4e0:	e6f7      	b.n	f2d2 <getTrngSource+0x132>
    f4e2:	9b03      	ldr	r3, [sp, #12]
    f4e4:	f5b3 7f04 	cmp.w	r3, #528	; 0x210
    f4e8:	f63f af61 	bhi.w	f3ae <getTrngSource+0x20e>
    f4ec:	e9dd 7c04 	ldrd	r7, ip, [sp, #16]
    f4f0:	4620      	mov	r0, r4
    f4f2:	4623      	mov	r3, r4
    f4f4:	696e      	ldr	r6, [r5, #20]
    f4f6:	e004      	b.n	f502 <getTrngSource+0x362>
    f4f8:	2001      	movs	r0, #1
    f4fa:	3301      	adds	r3, #1
    f4fc:	4563      	cmp	r3, ip
    f4fe:	4614      	mov	r4, r2
    f500:	d815      	bhi.n	f52e <getTrngSource+0x38e>
    f502:	095a      	lsrs	r2, r3, #5
    f504:	f857 2022 	ldr.w	r2, [r7, r2, lsl #2]
    f508:	f003 011f 	and.w	r1, r3, #31
    f50c:	40ca      	lsrs	r2, r1
    f50e:	291f      	cmp	r1, #31
    f510:	bf18      	it	ne
    f512:	f002 0201 	andne.w	r2, r2, #1
    f516:	2b00      	cmp	r3, #0
    f518:	d0ee      	beq.n	f4f8 <getTrngSource+0x358>
    f51a:	42a2      	cmp	r2, r4
    f51c:	d1ec      	bne.n	f4f8 <getTrngSource+0x358>
    f51e:	3001      	adds	r0, #1
    f520:	4286      	cmp	r6, r0
    f522:	d1ea      	bne.n	f4fa <getTrngSource+0x35a>
    f524:	4849      	ldr	r0, [pc, #292]	; (f64c <getTrngSource+0x4ac>)
    f526:	e00b      	b.n	f540 <getTrngSource+0x3a0>
    f528:	2302      	movs	r3, #2
    f52a:	9301      	str	r3, [sp, #4]
    f52c:	e6d1      	b.n	f2d2 <getTrngSource+0x132>
    f52e:	f44f 6380 	mov.w	r3, #1024	; 0x400
    f532:	e9dd 1003 	ldrd	r1, r0, [sp, #12]
    f536:	69aa      	ldr	r2, [r5, #24]
    f538:	f7ff fdf4 	bl	f124 <LLF_RND_AdaptiveProportionTest>
    f53c:	2800      	cmp	r0, #0
    f53e:	d05d      	beq.n	f5fc <getTrngSource+0x45c>
    f540:	2300      	movs	r3, #0
    f542:	9a18      	ldr	r2, [sp, #96]	; 0x60
    f544:	6013      	str	r3, [r2, #0]
    f546:	e6a3      	b.n	f290 <getTrngSource+0xf0>
    f548:	4629      	mov	r1, r5
    f54a:	9806      	ldr	r0, [sp, #24]
    f54c:	f000 f8e2 	bl	f714 <LLF_RND_GetRoscSampleCnt>
    f550:	2800      	cmp	r0, #0
    f552:	f47f ae7c 	bne.w	f24e <getTrngSource+0xae>
    f556:	9c06      	ldr	r4, [sp, #24]
    f558:	2c08      	cmp	r4, #8
    f55a:	d051      	beq.n	f600 <getTrngSource+0x460>
    f55c:	2c04      	cmp	r4, #4
    f55e:	d051      	beq.n	f604 <getTrngSource+0x464>
    f560:	f1a4 0402 	sub.w	r4, r4, #2
    f564:	fab4 f484 	clz	r4, r4
    f568:	0964      	lsrs	r4, r4, #5
    f56a:	2301      	movs	r3, #1
    f56c:	461e      	mov	r6, r3
    f56e:	4619      	mov	r1, r3
    f570:	4a2d      	ldr	r2, [pc, #180]	; (f628 <getTrngSource+0x488>)
    f572:	6013      	str	r3, [r2, #0]
    f574:	f842 3c84 	str.w	r3, [r2, #-132]
    f578:	4b2b      	ldr	r3, [pc, #172]	; (f628 <getTrngSource+0x488>)
    f57a:	6019      	str	r1, [r3, #0]
    f57c:	6a6b      	ldr	r3, [r5, #36]	; 0x24
    f57e:	f8c9 3000 	str.w	r3, [r9]
    f582:	f8d9 2000 	ldr.w	r2, [r9]
    f586:	6a6b      	ldr	r3, [r5, #36]	; 0x24
    f588:	429a      	cmp	r2, r3
    f58a:	d1f5      	bne.n	f578 <getTrngSource+0x3d8>
    f58c:	2700      	movs	r7, #0
    f58e:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    f592:	f8ca 7000 	str.w	r7, [sl]
    f596:	f7ff faef 	bl	eb78 <CC_HalClearInterruptBit>
    f59a:	4b26      	ldr	r3, [pc, #152]	; (f634 <getTrngSource+0x494>)
    f59c:	4a26      	ldr	r2, [pc, #152]	; (f638 <getTrngSource+0x498>)
    f59e:	4638      	mov	r0, r7
    f5a0:	601a      	str	r2, [r3, #0]
    f5a2:	f7ff faf7 	bl	eb94 <CC_HalMaskInterrupt>
    f5a6:	220a      	movs	r2, #10
    f5a8:	4924      	ldr	r1, [pc, #144]	; (f63c <getTrngSource+0x49c>)
    f5aa:	4b25      	ldr	r3, [pc, #148]	; (f640 <getTrngSource+0x4a0>)
    f5ac:	600c      	str	r4, [r1, #0]
    f5ae:	601a      	str	r2, [r3, #0]
    f5b0:	692a      	ldr	r2, [r5, #16]
    f5b2:	4924      	ldr	r1, [pc, #144]	; (f644 <getTrngSource+0x4a4>)
    f5b4:	6a6b      	ldr	r3, [r5, #36]	; 0x24
    f5b6:	fba1 1202 	umull	r1, r2, r1, r2
    f5ba:	eb03 0343 	add.w	r3, r3, r3, lsl #1
    f5be:	0912      	lsrs	r2, r2, #4
    f5c0:	03db      	lsls	r3, r3, #15
    f5c2:	fb03 f302 	mul.w	r3, r3, r2
    f5c6:	4a20      	ldr	r2, [pc, #128]	; (f648 <getTrngSource+0x4a8>)
    f5c8:	099b      	lsrs	r3, r3, #6
    f5ca:	6013      	str	r3, [r2, #0]
    f5cc:	f8ca 6000 	str.w	r6, [sl]
    f5d0:	9b06      	ldr	r3, [sp, #24]
    f5d2:	f8db 1000 	ldr.w	r1, [fp]
    f5d6:	021a      	lsls	r2, r3, #8
    f5d8:	ea42 6303 	orr.w	r3, r2, r3, lsl #24
    f5dc:	f021 427f 	bic.w	r2, r1, #4278190080	; 0xff000000
    f5e0:	431a      	orrs	r2, r3
    f5e2:	0a13      	lsrs	r3, r2, #8
    f5e4:	f403 037f 	and.w	r3, r3, #16711680	; 0xff0000
    f5e8:	4313      	orrs	r3, r2
    f5ea:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
    f5ee:	f8cb 3000 	str.w	r3, [fp]
    f5f2:	9b02      	ldr	r3, [sp, #8]
    f5f4:	3b01      	subs	r3, #1
    f5f6:	9302      	str	r3, [sp, #8]
    f5f8:	f47f ae07 	bne.w	f20a <getTrngSource+0x6a>
    f5fc:	2000      	movs	r0, #0
    f5fe:	e629      	b.n	f254 <getTrngSource+0xb4>
    f600:	2403      	movs	r4, #3
    f602:	e7b2      	b.n	f56a <getTrngSource+0x3ca>
    f604:	2402      	movs	r4, #2
    f606:	e7b0      	b.n	f56a <getTrngSource+0x3ca>
    f608:	f44f 037f 	mov.w	r3, #16711680	; 0xff0000
    f60c:	f8d3 1c0c 	ldr.w	r1, [r3, #3084]	; 0xc0c
    f610:	3101      	adds	r1, #1
    f612:	d006      	beq.n	f622 <getTrngSource+0x482>
    f614:	f8d3 3c0c 	ldr.w	r3, [r3, #3084]	; 0xc0c
    f618:	e745      	b.n	f4a6 <getTrngSource+0x306>
    f61a:	2703      	movs	r7, #3
    f61c:	e71a      	b.n	f454 <getTrngSource+0x2b4>
    f61e:	2702      	movs	r7, #2
    f620:	e718      	b.n	f454 <getTrngSource+0x2b4>
    f622:	2316      	movs	r3, #22
    f624:	e743      	b.n	f4ae <getTrngSource+0x30e>
    f626:	bf00      	nop
    f628:	508411c4 	.word	0x508411c4
    f62c:	50841140 	.word	0x50841140
    f630:	5084112c 	.word	0x5084112c
    f634:	50841100 	.word	0x50841100
    f638:	0ffffffe 	.word	0x0ffffffe
    f63c:	5084110c 	.word	0x5084110c
    f640:	50841138 	.word	0x50841138
    f644:	aaaaaaab 	.word	0xaaaaaaab
    f648:	508411d8 	.word	0x508411d8
    f64c:	00f10c36 	.word	0x00f10c36

0000f650 <LLF_RND_GetTrngSource>:
    f650:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    f654:	4c1b      	ldr	r4, [pc, #108]	; (f6c4 <LLF_RND_GetTrngSource+0x74>)
    f656:	b085      	sub	sp, #20
    f658:	4607      	mov	r7, r0
    f65a:	e9dd 560d 	ldrd	r5, r6, [sp, #52]	; 0x34
    f65e:	4688      	mov	r8, r1
    f660:	6820      	ldr	r0, [r4, #0]
    f662:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    f666:	4691      	mov	r9, r2
    f668:	f7ff fa1e 	bl	eaa8 <CC_PalMutexLock>
    f66c:	bb28      	cbnz	r0, f6ba <LLF_RND_GetTrngSource+0x6a>
    f66e:	2000      	movs	r0, #0
    f670:	f7ff fa4a 	bl	eb08 <CC_PalPowerSaveModeSelect>
    f674:	b9e8      	cbnz	r0, f6b2 <LLF_RND_GetTrngSource+0x62>
    f676:	2300      	movs	r3, #0
    f678:	e9cd 5600 	strd	r5, r6, [sp]
    f67c:	9302      	str	r3, [sp, #8]
    f67e:	464a      	mov	r2, r9
    f680:	4641      	mov	r1, r8
    f682:	4638      	mov	r0, r7
    f684:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    f686:	f7ff fd8b 	bl	f1a0 <getTrngSource>
    f68a:	4605      	mov	r5, r0
    f68c:	2001      	movs	r0, #1
    f68e:	f7ff fa3b 	bl	eb08 <CC_PalPowerSaveModeSelect>
    f692:	b950      	cbnz	r0, f6aa <LLF_RND_GetTrngSource+0x5a>
    f694:	6820      	ldr	r0, [r4, #0]
    f696:	f7ff fa0f 	bl	eab8 <CC_PalMutexUnlock>
    f69a:	b110      	cbz	r0, f6a2 <LLF_RND_GetTrngSource+0x52>
    f69c:	480a      	ldr	r0, [pc, #40]	; (f6c8 <LLF_RND_GetTrngSource+0x78>)
    f69e:	f7ff fb8d 	bl	edbc <CC_PalAbort>
    f6a2:	4628      	mov	r0, r5
    f6a4:	b005      	add	sp, #20
    f6a6:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    f6aa:	4808      	ldr	r0, [pc, #32]	; (f6cc <LLF_RND_GetTrngSource+0x7c>)
    f6ac:	f7ff fb86 	bl	edbc <CC_PalAbort>
    f6b0:	e7f0      	b.n	f694 <LLF_RND_GetTrngSource+0x44>
    f6b2:	4807      	ldr	r0, [pc, #28]	; (f6d0 <LLF_RND_GetTrngSource+0x80>)
    f6b4:	f7ff fb82 	bl	edbc <CC_PalAbort>
    f6b8:	e7dd      	b.n	f676 <LLF_RND_GetTrngSource+0x26>
    f6ba:	4806      	ldr	r0, [pc, #24]	; (f6d4 <LLF_RND_GetTrngSource+0x84>)
    f6bc:	f7ff fb7e 	bl	edbc <CC_PalAbort>
    f6c0:	e7d5      	b.n	f66e <LLF_RND_GetTrngSource+0x1e>
    f6c2:	bf00      	nop
    f6c4:	20001424 	.word	0x20001424
    f6c8:	00010830 	.word	0x00010830
    f6cc:	00010868 	.word	0x00010868
    f6d0:	00010848 	.word	0x00010848
    f6d4:	00010818 	.word	0x00010818

0000f6d8 <LLF_RND_RunTrngStartupTest>:
    f6d8:	b510      	push	{r4, lr}
    f6da:	2401      	movs	r4, #1
    f6dc:	b086      	sub	sp, #24
    f6de:	ab05      	add	r3, sp, #20
    f6e0:	e9cd 2401 	strd	r2, r4, [sp, #4]
    f6e4:	9300      	str	r3, [sp, #0]
    f6e6:	2200      	movs	r2, #0
    f6e8:	ab04      	add	r3, sp, #16
    f6ea:	f7ff fd59 	bl	f1a0 <getTrngSource>
    f6ee:	b006      	add	sp, #24
    f6f0:	bd10      	pop	{r4, pc}
    f6f2:	bf00      	nop

0000f6f4 <LLF_RND_WaitRngInterrupt>:
    f6f4:	b508      	push	{r3, lr}
    f6f6:	4601      	mov	r1, r0
    f6f8:	f44f 6080 	mov.w	r0, #1024	; 0x400
    f6fc:	f7ff fa50 	bl	eba0 <CC_HalWaitInterruptRND>
    f700:	2300      	movs	r3, #0
    f702:	4902      	ldr	r1, [pc, #8]	; (f70c <LLF_RND_WaitRngInterrupt+0x18>)
    f704:	4a02      	ldr	r2, [pc, #8]	; (f710 <LLF_RND_WaitRngInterrupt+0x1c>)
    f706:	600b      	str	r3, [r1, #0]
    f708:	6013      	str	r3, [r2, #0]
    f70a:	bd08      	pop	{r3, pc}
    f70c:	508411c8 	.word	0x508411c8
    f710:	5084112c 	.word	0x5084112c

0000f714 <LLF_RND_GetRoscSampleCnt>:
    f714:	3801      	subs	r0, #1
    f716:	2807      	cmp	r0, #7
    f718:	d815      	bhi.n	f746 <LLF_RND_GetRoscSampleCnt+0x32>
    f71a:	e8df f000 	tbb	[pc, r0]
    f71e:	0c10      	.short	0x0c10
    f720:	14140814 	.word	0x14140814
    f724:	0414      	.short	0x0414
    f726:	68cb      	ldr	r3, [r1, #12]
    f728:	2000      	movs	r0, #0
    f72a:	624b      	str	r3, [r1, #36]	; 0x24
    f72c:	4770      	bx	lr
    f72e:	688b      	ldr	r3, [r1, #8]
    f730:	2000      	movs	r0, #0
    f732:	624b      	str	r3, [r1, #36]	; 0x24
    f734:	4770      	bx	lr
    f736:	684b      	ldr	r3, [r1, #4]
    f738:	2000      	movs	r0, #0
    f73a:	624b      	str	r3, [r1, #36]	; 0x24
    f73c:	4770      	bx	lr
    f73e:	680b      	ldr	r3, [r1, #0]
    f740:	2000      	movs	r0, #0
    f742:	624b      	str	r3, [r1, #36]	; 0x24
    f744:	4770      	bx	lr
    f746:	4801      	ldr	r0, [pc, #4]	; (f74c <LLF_RND_GetRoscSampleCnt+0x38>)
    f748:	4770      	bx	lr
    f74a:	bf00      	nop
    f74c:	00f10c31 	.word	0x00f10c31

0000f750 <LLF_RND_GetFastestRosc>:
    f750:	680b      	ldr	r3, [r1, #0]
    f752:	e002      	b.n	f75a <LLF_RND_GetFastestRosc+0xa>
    f754:	2b08      	cmp	r3, #8
    f756:	600b      	str	r3, [r1, #0]
    f758:	d806      	bhi.n	f768 <LLF_RND_GetFastestRosc+0x18>
    f75a:	6a02      	ldr	r2, [r0, #32]
    f75c:	4213      	tst	r3, r2
    f75e:	ea4f 0343 	mov.w	r3, r3, lsl #1
    f762:	d0f7      	beq.n	f754 <LLF_RND_GetFastestRosc+0x4>
    f764:	2000      	movs	r0, #0
    f766:	4770      	bx	lr
    f768:	4800      	ldr	r0, [pc, #0]	; (f76c <LLF_RND_GetFastestRosc+0x1c>)
    f76a:	4770      	bx	lr
    f76c:	00f10c31 	.word	0x00f10c31

0000f770 <LLF_RND_TurnOffTrng>:
    f770:	2300      	movs	r3, #0
    f772:	4904      	ldr	r1, [pc, #16]	; (f784 <LLF_RND_TurnOffTrng+0x14>)
    f774:	4a04      	ldr	r2, [pc, #16]	; (f788 <LLF_RND_TurnOffTrng+0x18>)
    f776:	600b      	str	r3, [r1, #0]
    f778:	f44f 6080 	mov.w	r0, #1024	; 0x400
    f77c:	6013      	str	r3, [r2, #0]
    f77e:	f7ff b9fb 	b.w	eb78 <CC_HalClearInterruptBit>
    f782:	bf00      	nop
    f784:	5084112c 	.word	0x5084112c
    f788:	508411c4 	.word	0x508411c4

0000f78c <main>:
 *  0 kB  |---------------------|
 */


void main(void)
{
    f78c:	b508      	push	{r3, lr}
	spm_config();
    f78e:	f7fd fad5 	bl	cd3c <spm_config>
	spm_jump();
}
    f792:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	spm_jump();
    f796:	f7fd ba65 	b.w	cc64 <spm_jump>

0000f79a <arm_cmse_mpu_region_get>:
__CMSE_TT_ASM ()

__extension__ static __inline __attribute__ ((__always_inline__))
cmse_address_info_t
cmse_TT (void *__p)
__CMSE_TT_ASM ()
    f79a:	e840 f300 	tt	r3, r0

int arm_cmse_mpu_region_get(u32_t addr)
{
	cmse_address_info_t addr_info =	cmse_TT((void *)addr);

	if (addr_info.flags.mpu_region_valid) {
    f79e:	f413 3f80 	tst.w	r3, #65536	; 0x10000
    f7a2:	b2d8      	uxtb	r0, r3
		return addr_info.flags.mpu_region;
	}

	return -EINVAL;
}
    f7a4:	bf08      	it	eq
    f7a6:	f06f 0015 	mvneq.w	r0, #21
    f7aa:	4770      	bx	lr

0000f7ac <z_sys_mem_pool_base_init>:
{
	int i;
	size_t buflen = p->n_max * p->max_sz, sz = p->max_sz;
	u32_t *bits = (u32_t *)((u8_t *)p->buf + buflen);

	p->max_inline_level = -1;
    f7ac:	23ff      	movs	r3, #255	; 0xff
{
    f7ae:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	size_t buflen = p->n_max * p->max_sz, sz = p->max_sz;
    f7b2:	6846      	ldr	r6, [r0, #4]
	p->max_inline_level = -1;
    f7b4:	72c3      	strb	r3, [r0, #11]
	size_t buflen = p->n_max * p->max_sz, sz = p->max_sz;
    f7b6:	4632      	mov	r2, r6

	for (i = 0; i < p->n_levels; i++) {
    f7b8:	2300      	movs	r3, #0
		int nblocks = buflen / sz;

		sys_dlist_init(&p->levels[i].free_list);
    f7ba:	f04f 090c 	mov.w	r9, #12
	size_t buflen = p->n_max * p->max_sz, sz = p->max_sz;
    f7be:	8907      	ldrh	r7, [r0, #8]
	u32_t *bits = (u32_t *)((u8_t *)p->buf + buflen);
    f7c0:	6801      	ldr	r1, [r0, #0]
	size_t buflen = p->n_max * p->max_sz, sz = p->max_sz;
    f7c2:	fb06 fc07 	mul.w	ip, r6, r7
	for (i = 0; i < p->n_levels; i++) {
    f7c6:	f890 800a 	ldrb.w	r8, [r0, #10]
	u32_t *bits = (u32_t *)((u8_t *)p->buf + buflen);
    f7ca:	4461      	add	r1, ip
	for (i = 0; i < p->n_levels; i++) {
    f7cc:	4598      	cmp	r8, r3
    f7ce:	dc05      	bgt.n	f7dc <z_sys_mem_pool_base_init+0x30>
    f7d0:	2300      	movs	r3, #0
		}

		sz = WB_DN(sz / 4);
	}

	for (i = 0; i < p->n_max; i++) {
    f7d2:	4619      	mov	r1, r3
    f7d4:	428f      	cmp	r7, r1
    f7d6:	dc20      	bgt.n	f81a <z_sys_mem_pool_base_init+0x6e>
		void *block = block_ptr(p, p->max_sz, i);

		sys_dlist_append(&p->levels[0].free_list, block);
	}
}
    f7d8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		int nblocks = buflen / sz;
    f7dc:	fbbc f5f2 	udiv	r5, ip, r2
		sys_dlist_init(&p->levels[i].free_list);
    f7e0:	fb09 fe03 	mul.w	lr, r9, r3
    f7e4:	f8d0 a00c 	ldr.w	sl, [r0, #12]
		if (nblocks <= sizeof(p->levels[i].bits)*8) {
    f7e8:	2d20      	cmp	r5, #32
		sys_dlist_init(&p->levels[i].free_list);
    f7ea:	eb0a 040e 	add.w	r4, sl, lr
    f7ee:	f104 0b04 	add.w	fp, r4, #4
    f7f2:	e9c4 bb01 	strd	fp, fp, [r4, #4]
		if (nblocks <= sizeof(p->levels[i].bits)*8) {
    f7f6:	d805      	bhi.n	f804 <z_sys_mem_pool_base_init+0x58>
			p->max_inline_level = i;
    f7f8:	72c3      	strb	r3, [r0, #11]
		sz = WB_DN(sz / 4);
    f7fa:	0892      	lsrs	r2, r2, #2
    f7fc:	f022 0203 	bic.w	r2, r2, #3
	for (i = 0; i < p->n_levels; i++) {
    f800:	3301      	adds	r3, #1
    f802:	e7e3      	b.n	f7cc <z_sys_mem_pool_base_init+0x20>
			bits += (nblocks + 31)/32;
    f804:	f115 041f 	adds.w	r4, r5, #31
    f808:	bf48      	it	mi
    f80a:	f105 043e 	addmi.w	r4, r5, #62	; 0x3e
    f80e:	1164      	asrs	r4, r4, #5
			p->levels[i].bits_p = bits;
    f810:	f84a 100e 	str.w	r1, [sl, lr]
			bits += (nblocks + 31)/32;
    f814:	eb01 0184 	add.w	r1, r1, r4, lsl #2
    f818:	e7ef      	b.n	f7fa <z_sys_mem_pool_base_init+0x4e>
		sys_dlist_append(&p->levels[0].free_list, block);
    f81a:	68c2      	ldr	r2, [r0, #12]
	return (u8_t *)p->buf + lsz * block;
    f81c:	6805      	ldr	r5, [r0, #0]
		sys_dlist_append(&p->levels[0].free_list, block);
    f81e:	f102 0c04 	add.w	ip, r2, #4
	return (u8_t *)p->buf + lsz * block;
    f822:	18ec      	adds	r4, r5, r3
	node->next = list;
    f824:	f845 c003 	str.w	ip, [r5, r3]
	node->prev = list->tail;
    f828:	6895      	ldr	r5, [r2, #8]
	for (i = 0; i < p->n_max; i++) {
    f82a:	3101      	adds	r1, #1
    f82c:	6065      	str	r5, [r4, #4]
	list->tail->next = node;
    f82e:	6895      	ldr	r5, [r2, #8]
    f830:	4433      	add	r3, r6
    f832:	602c      	str	r4, [r5, #0]
	list->tail = node;
    f834:	6094      	str	r4, [r2, #8]
    f836:	e7cd      	b.n	f7d4 <z_sys_mem_pool_base_init+0x28>

0000f838 <z_thread_entry>:
 * This routine does not return, and is marked as such so the compiler won't
 * generate preamble code that is only used by functions that actually return.
 */
FUNC_NORETURN void z_thread_entry(k_thread_entry_t entry,
				 void *p1, void *p2, void *p3)
{
    f838:	4604      	mov	r4, r0
    f83a:	b508      	push	{r3, lr}
    f83c:	4608      	mov	r0, r1
    f83e:	4611      	mov	r1, r2
	entry(p1, p2, p3);
    f840:	461a      	mov	r2, r3
    f842:	47a0      	blx	r4
	return z_impl_k_current_get();
    f844:	f7fe ff48 	bl	e6d8 <z_impl_k_current_get>
	z_impl_k_thread_abort(thread);
    f848:	f7fd ff48 	bl	d6dc <z_impl_k_thread_abort>

0000f84c <z_arch_printk_char_out>:
}
    f84c:	2000      	movs	r0, #0
    f84e:	4770      	bx	lr

0000f850 <print_err>:
{
    f850:	b570      	push	{r4, r5, r6, lr}
    f852:	460d      	mov	r5, r1
    f854:	4604      	mov	r4, r0
	out('E', ctx);
    f856:	2045      	movs	r0, #69	; 0x45
    f858:	47a0      	blx	r4
	out('R', ctx);
    f85a:	4629      	mov	r1, r5
    f85c:	2052      	movs	r0, #82	; 0x52
    f85e:	47a0      	blx	r4
	out('R', ctx);
    f860:	4629      	mov	r1, r5
    f862:	4623      	mov	r3, r4
}
    f864:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	out('R', ctx);
    f868:	2052      	movs	r0, #82	; 0x52
    f86a:	4718      	bx	r3

0000f86c <z_vprintk>:
{
    f86c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	char length_mod = 0;
    f870:	f04f 0800 	mov.w	r8, #0
{
    f874:	4606      	mov	r6, r0
    f876:	460f      	mov	r7, r1
	int min_width = -1;
    f878:	f04f 3aff 	mov.w	sl, #4294967295	; 0xffffffff
	enum pad_type padding = PAD_NONE;
    f87c:	46c1      	mov	r9, r8
{
    f87e:	b08b      	sub	sp, #44	; 0x2c
    f880:	461c      	mov	r4, r3
	while (*fmt) {
    f882:	1e53      	subs	r3, r2, #1
    f884:	9302      	str	r3, [sp, #8]
			might_format = 0;
    f886:	2500      	movs	r5, #0
					break;
    f888:	e005      	b.n	f896 <z_vprintk+0x2a>
		if (!might_format) {
    f88a:	b96d      	cbnz	r5, f8a8 <z_vprintk+0x3c>
			if (*fmt != '%') {
    f88c:	2825      	cmp	r0, #37	; 0x25
    f88e:	f000 814f 	beq.w	fb30 <z_vprintk+0x2c4>
				out((int)*fmt, ctx);
    f892:	4639      	mov	r1, r7
    f894:	47b0      	blx	r6
	while (*fmt) {
    f896:	9b02      	ldr	r3, [sp, #8]
    f898:	f813 0f01 	ldrb.w	r0, [r3, #1]!
    f89c:	9302      	str	r3, [sp, #8]
    f89e:	2800      	cmp	r0, #0
    f8a0:	d1f3      	bne.n	f88a <z_vprintk+0x1e>
}
    f8a2:	b00b      	add	sp, #44	; 0x2c
    f8a4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			switch (*fmt) {
    f8a8:	2864      	cmp	r0, #100	; 0x64
    f8aa:	d06e      	beq.n	f98a <z_vprintk+0x11e>
    f8ac:	d81a      	bhi.n	f8e4 <z_vprintk+0x78>
    f8ae:	2839      	cmp	r0, #57	; 0x39
    f8b0:	d80a      	bhi.n	f8c8 <z_vprintk+0x5c>
    f8b2:	2831      	cmp	r0, #49	; 0x31
    f8b4:	d260      	bcs.n	f978 <z_vprintk+0x10c>
    f8b6:	282d      	cmp	r0, #45	; 0x2d
    f8b8:	f000 8140 	beq.w	fb3c <z_vprintk+0x2d0>
    f8bc:	2830      	cmp	r0, #48	; 0x30
    f8be:	d04c      	beq.n	f95a <z_vprintk+0xee>
    f8c0:	2825      	cmp	r0, #37	; 0x25
    f8c2:	d107      	bne.n	f8d4 <z_vprintk+0x68>
				out((int)'%', ctx);
    f8c4:	4639      	mov	r1, r7
    f8c6:	e00b      	b.n	f8e0 <z_vprintk+0x74>
			switch (*fmt) {
    f8c8:	2858      	cmp	r0, #88	; 0x58
    f8ca:	f000 80bb 	beq.w	fa44 <z_vprintk+0x1d8>
    f8ce:	2863      	cmp	r0, #99	; 0x63
    f8d0:	f000 812a 	beq.w	fb28 <z_vprintk+0x2bc>
					out((int)'%', ctx);
    f8d4:	4639      	mov	r1, r7
    f8d6:	2025      	movs	r0, #37	; 0x25
    f8d8:	47b0      	blx	r6
					out((int)*fmt, ctx);
    f8da:	4639      	mov	r1, r7
    f8dc:	9b02      	ldr	r3, [sp, #8]
    f8de:	7818      	ldrb	r0, [r3, #0]
    f8e0:	47b0      	blx	r6
    f8e2:	e7d0      	b.n	f886 <z_vprintk+0x1a>
			switch (*fmt) {
    f8e4:	2870      	cmp	r0, #112	; 0x70
    f8e6:	f000 80a3 	beq.w	fa30 <z_vprintk+0x1c4>
    f8ea:	d811      	bhi.n	f910 <z_vprintk+0xa4>
    f8ec:	2869      	cmp	r0, #105	; 0x69
    f8ee:	d04c      	beq.n	f98a <z_vprintk+0x11e>
    f8f0:	286c      	cmp	r0, #108	; 0x6c
    f8f2:	d105      	bne.n	f900 <z_vprintk+0x94>
				} else if (*fmt == 'l' && length_mod == 'l') {
    f8f4:	f1b8 0f6c 	cmp.w	r8, #108	; 0x6c
    f8f8:	d12a      	bne.n	f950 <z_vprintk+0xe4>
					length_mod = 'L';
    f8fa:	f04f 084c 	mov.w	r8, #76	; 0x4c
    f8fe:	e7ca      	b.n	f896 <z_vprintk+0x2a>
			switch (*fmt) {
    f900:	2868      	cmp	r0, #104	; 0x68
    f902:	d1e7      	bne.n	f8d4 <z_vprintk+0x68>
				if (*fmt == 'h' && length_mod == 'h') {
    f904:	f1b8 0f68 	cmp.w	r8, #104	; 0x68
    f908:	d122      	bne.n	f950 <z_vprintk+0xe4>
					length_mod = 'H';
    f90a:	f04f 0848 	mov.w	r8, #72	; 0x48
    f90e:	e7c2      	b.n	f896 <z_vprintk+0x2a>
			switch (*fmt) {
    f910:	2875      	cmp	r0, #117	; 0x75
    f912:	d071      	beq.n	f9f8 <z_vprintk+0x18c>
    f914:	d818      	bhi.n	f948 <z_vprintk+0xdc>
    f916:	2873      	cmp	r0, #115	; 0x73
    f918:	d1dc      	bne.n	f8d4 <z_vprintk+0x68>
				char *s = va_arg(ap, char *);
    f91a:	f854 5b04 	ldr.w	r5, [r4], #4
				while (*s) {
    f91e:	46ab      	mov	fp, r5
    f920:	465b      	mov	r3, fp
    f922:	f81b 0b01 	ldrb.w	r0, [fp], #1
    f926:	2800      	cmp	r0, #0
    f928:	f040 80fb 	bne.w	fb22 <z_vprintk+0x2b6>
				if (padding == PAD_SPACE_AFTER) {
    f92c:	f1b9 0f03 	cmp.w	r9, #3
    f930:	f040 810a 	bne.w	fb48 <z_vprintk+0x2dc>
					int remaining = min_width - (s - start);
    f934:	1b5d      	subs	r5, r3, r5
    f936:	ebaa 0505 	sub.w	r5, sl, r5
					while (remaining-- > 0) {
    f93a:	2d00      	cmp	r5, #0
    f93c:	dda3      	ble.n	f886 <z_vprintk+0x1a>
						out(' ', ctx);
    f93e:	4639      	mov	r1, r7
    f940:	2020      	movs	r0, #32
    f942:	47b0      	blx	r6
    f944:	3d01      	subs	r5, #1
    f946:	e7f8      	b.n	f93a <z_vprintk+0xce>
			switch (*fmt) {
    f948:	2878      	cmp	r0, #120	; 0x78
    f94a:	d07b      	beq.n	fa44 <z_vprintk+0x1d8>
    f94c:	287a      	cmp	r0, #122	; 0x7a
    f94e:	d1c1      	bne.n	f8d4 <z_vprintk+0x68>
				} else if (length_mod == 0) {
    f950:	f1b8 0f00 	cmp.w	r8, #0
    f954:	d1be      	bne.n	f8d4 <z_vprintk+0x68>
    f956:	4680      	mov	r8, r0
    f958:	e79d      	b.n	f896 <z_vprintk+0x2a>
				if (min_width < 0 && padding == PAD_NONE) {
    f95a:	f1ba 0f00 	cmp.w	sl, #0
    f95e:	da0e      	bge.n	f97e <z_vprintk+0x112>
    f960:	f1b9 0f00 	cmp.w	r9, #0
    f964:	f000 80ed 	beq.w	fb42 <z_vprintk+0x2d6>
					min_width = *fmt - '0';
    f968:	f1a0 0a30 	sub.w	sl, r0, #48	; 0x30
					padding = PAD_SPACE_BEFORE;
    f96c:	f1b9 0f00 	cmp.w	r9, #0
    f970:	bf08      	it	eq
    f972:	f04f 0902 	moveq.w	r9, #2
    f976:	e78e      	b.n	f896 <z_vprintk+0x2a>
				if (min_width < 0) {
    f978:	f1ba 0f00 	cmp.w	sl, #0
    f97c:	dbf4      	blt.n	f968 <z_vprintk+0xfc>
					min_width = 10 * min_width + *fmt - '0';
    f97e:	230a      	movs	r3, #10
    f980:	fb03 0a0a 	mla	sl, r3, sl, r0
    f984:	f1aa 0a30 	sub.w	sl, sl, #48	; 0x30
    f988:	e7f0      	b.n	f96c <z_vprintk+0x100>
				if (length_mod == 'z') {
    f98a:	f1b8 0f7a 	cmp.w	r8, #122	; 0x7a
    f98e:	d102      	bne.n	f996 <z_vprintk+0x12a>
					d = va_arg(ap, int);
    f990:	f854 5b04 	ldr.w	r5, [r4], #4
    f994:	e01f      	b.n	f9d6 <z_vprintk+0x16a>
				} else if (length_mod == 'l') {
    f996:	f1b8 0f6c 	cmp.w	r8, #108	; 0x6c
    f99a:	d0f9      	beq.n	f990 <z_vprintk+0x124>
				} else if (length_mod == 'L') {
    f99c:	f1b8 0f4c 	cmp.w	r8, #76	; 0x4c
    f9a0:	d1f6      	bne.n	f990 <z_vprintk+0x124>
					long long lld = va_arg(ap, long long);
    f9a2:	3407      	adds	r4, #7
    f9a4:	f024 0407 	bic.w	r4, r4, #7
    f9a8:	e8f4 2302 	ldrd	r2, r3, [r4], #8
					if (lld > __LONG_MAX__ ||
    f9ac:	f112 4100 	adds.w	r1, r2, #2147483648	; 0x80000000
    f9b0:	9106      	str	r1, [sp, #24]
    f9b2:	f143 0100 	adc.w	r1, r3, #0
    f9b6:	9107      	str	r1, [sp, #28]
    f9b8:	2100      	movs	r1, #0
    f9ba:	e9dd bc06 	ldrd	fp, ip, [sp, #24]
    f9be:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    f9c2:	4561      	cmp	r1, ip
    f9c4:	bf08      	it	eq
    f9c6:	4558      	cmpeq	r0, fp
    f9c8:	d204      	bcs.n	f9d4 <z_vprintk+0x168>
						print_err(out, ctx);
    f9ca:	4639      	mov	r1, r7
    f9cc:	4630      	mov	r0, r6
    f9ce:	f7ff ff3f 	bl	f850 <print_err>
						break;
    f9d2:	e758      	b.n	f886 <z_vprintk+0x1a>
					d = lld;
    f9d4:	4615      	mov	r5, r2
				if (d < 0) {
    f9d6:	2d00      	cmp	r5, #0
    f9d8:	da05      	bge.n	f9e6 <z_vprintk+0x17a>
					out((int)'-', ctx);
    f9da:	4639      	mov	r1, r7
    f9dc:	202d      	movs	r0, #45	; 0x2d
    f9de:	47b0      	blx	r6
					d = -d;
    f9e0:	426d      	negs	r5, r5
					min_width--;
    f9e2:	f10a 3aff 	add.w	sl, sl, #4294967295	; 0xffffffff
				_printk_dec_ulong(out, ctx, d, padding,
    f9e6:	464b      	mov	r3, r9
    f9e8:	462a      	mov	r2, r5
    f9ea:	f8cd a000 	str.w	sl, [sp]
				_printk_dec_ulong(out, ctx, u, padding,
    f9ee:	4639      	mov	r1, r7
    f9f0:	4630      	mov	r0, r6
    f9f2:	f7fc ff77 	bl	c8e4 <_printk_dec_ulong>
				break;
    f9f6:	e746      	b.n	f886 <z_vprintk+0x1a>
				if (length_mod == 'z') {
    f9f8:	f1b8 0f7a 	cmp.w	r8, #122	; 0x7a
    f9fc:	d102      	bne.n	fa04 <z_vprintk+0x198>
					u = va_arg(ap, unsigned int);
    f9fe:	f854 2b04 	ldr.w	r2, [r4], #4
    fa02:	e011      	b.n	fa28 <z_vprintk+0x1bc>
				} else if (length_mod == 'l') {
    fa04:	f1b8 0f6c 	cmp.w	r8, #108	; 0x6c
    fa08:	d0f9      	beq.n	f9fe <z_vprintk+0x192>
				} else if (length_mod == 'L') {
    fa0a:	f1b8 0f4c 	cmp.w	r8, #76	; 0x4c
    fa0e:	d1f6      	bne.n	f9fe <z_vprintk+0x192>
					if (llu > ~0UL) {
    fa10:	2100      	movs	r1, #0
    fa12:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
					unsigned long long llu =
    fa16:	3407      	adds	r4, #7
    fa18:	f024 0407 	bic.w	r4, r4, #7
    fa1c:	e8f4 2302 	ldrd	r2, r3, [r4], #8
					if (llu > ~0UL) {
    fa20:	4299      	cmp	r1, r3
    fa22:	bf08      	it	eq
    fa24:	4290      	cmpeq	r0, r2
    fa26:	d3d0      	bcc.n	f9ca <z_vprintk+0x15e>
				_printk_dec_ulong(out, ctx, u, padding,
    fa28:	f8cd a000 	str.w	sl, [sp]
    fa2c:	464b      	mov	r3, r9
    fa2e:	e7de      	b.n	f9ee <z_vprintk+0x182>
				  out('0', ctx);
    fa30:	4639      	mov	r1, r7
    fa32:	2030      	movs	r0, #48	; 0x30
    fa34:	47b0      	blx	r6
				  out('x', ctx);
    fa36:	4639      	mov	r1, r7
    fa38:	2078      	movs	r0, #120	; 0x78
    fa3a:	47b0      	blx	r6
				  min_width = 8;
    fa3c:	f04f 0a08 	mov.w	sl, #8
				  padding = PAD_ZERO_BEFORE;
    fa40:	f04f 0901 	mov.w	r9, #1
				if (*fmt == 'p') {
    fa44:	9b02      	ldr	r3, [sp, #8]
    fa46:	781b      	ldrb	r3, [r3, #0]
    fa48:	2b70      	cmp	r3, #112	; 0x70
    fa4a:	d104      	bne.n	fa56 <z_vprintk+0x1ea>
					x = va_arg(ap, unsigned int);
    fa4c:	f854 3b04 	ldr.w	r3, [r4], #4
    fa50:	9304      	str	r3, [sp, #16]
    fa52:	2300      	movs	r3, #0
    fa54:	e00d      	b.n	fa72 <z_vprintk+0x206>
				} else if (length_mod == 'l') {
    fa56:	f1b8 0f6c 	cmp.w	r8, #108	; 0x6c
    fa5a:	d0f7      	beq.n	fa4c <z_vprintk+0x1e0>
				} else if (length_mod == 'L') {
    fa5c:	f1b8 0f4c 	cmp.w	r8, #76	; 0x4c
    fa60:	d1f4      	bne.n	fa4c <z_vprintk+0x1e0>
					x = va_arg(ap, unsigned long long);
    fa62:	3407      	adds	r4, #7
    fa64:	f024 0307 	bic.w	r3, r4, #7
    fa68:	461c      	mov	r4, r3
    fa6a:	f854 2b08 	ldr.w	r2, [r4], #8
    fa6e:	685b      	ldr	r3, [r3, #4]
    fa70:	9204      	str	r2, [sp, #16]
	int digits = 0;
    fa72:	2100      	movs	r1, #0
	int remaining = 16; /* 16 digits max */
    fa74:	2210      	movs	r2, #16
	int shift = sizeof(num) * 8;
    fa76:	f04f 0b40 	mov.w	fp, #64	; 0x40
	int digits = 0;
    fa7a:	9103      	str	r1, [sp, #12]
	int found_largest_digit = 0;
    fa7c:	9105      	str	r1, [sp, #20]
		shift -= 4;
    fa7e:	f1ab 0b04 	sub.w	fp, fp, #4
		nibble = (num >> shift) & 0xf;
    fa82:	9804      	ldr	r0, [sp, #16]
    fa84:	f1cb 0c20 	rsb	ip, fp, #32
    fa88:	f1ab 0120 	sub.w	r1, fp, #32
    fa8c:	fa20 f00b 	lsr.w	r0, r0, fp
    fa90:	fa03 fc0c 	lsl.w	ip, r3, ip
    fa94:	ea40 000c 	orr.w	r0, r0, ip
    fa98:	fa23 f101 	lsr.w	r1, r3, r1
    fa9c:	4308      	orrs	r0, r1
		if (nibble != 0 || found_largest_digit != 0 || shift == 0) {
    fa9e:	f010 000f 	ands.w	r0, r0, #15
    faa2:	d106      	bne.n	fab2 <z_vprintk+0x246>
    faa4:	9905      	ldr	r1, [sp, #20]
    faa6:	b911      	cbnz	r1, faae <z_vprintk+0x242>
    faa8:	f1bb 0f00 	cmp.w	fp, #0
    faac:	d122      	bne.n	faf4 <z_vprintk+0x288>
			nibble += nibble > 9 ? 87 : 48;
    faae:	2130      	movs	r1, #48	; 0x30
    fab0:	e003      	b.n	faba <z_vprintk+0x24e>
    fab2:	2809      	cmp	r0, #9
    fab4:	bf8c      	ite	hi
    fab6:	2157      	movhi	r1, #87	; 0x57
    fab8:	2130      	movls	r1, #48	; 0x30
    faba:	4408      	add	r0, r1
			out((int)nibble, ctx);
    fabc:	b240      	sxtb	r0, r0
    fabe:	4639      	mov	r1, r7
    fac0:	9308      	str	r3, [sp, #32]
    fac2:	9205      	str	r2, [sp, #20]
    fac4:	47b0      	blx	r6
			digits++;
    fac6:	9b03      	ldr	r3, [sp, #12]
	while (shift >= 4) {
    fac8:	9a05      	ldr	r2, [sp, #20]
			digits++;
    faca:	3301      	adds	r3, #1
    facc:	9303      	str	r3, [sp, #12]
	while (shift >= 4) {
    face:	9b08      	ldr	r3, [sp, #32]
    fad0:	f1bb 0f00 	cmp.w	fp, #0
    fad4:	d123      	bne.n	fb1e <z_vprintk+0x2b2>
	if (padding == PAD_SPACE_AFTER) {
    fad6:	f1b9 0f03 	cmp.w	r9, #3
    fada:	f47f aed4 	bne.w	f886 <z_vprintk+0x1a>
		remaining = min_width * 2 - digits;
    fade:	9b03      	ldr	r3, [sp, #12]
    fae0:	ebc3 054a 	rsb	r5, r3, sl, lsl #1
		while (remaining-- > 0) {
    fae4:	2d00      	cmp	r5, #0
    fae6:	f77f aece 	ble.w	f886 <z_vprintk+0x1a>
			out(' ', ctx);
    faea:	4639      	mov	r1, r7
    faec:	2020      	movs	r0, #32
    faee:	47b0      	blx	r6
    faf0:	3d01      	subs	r5, #1
    faf2:	e7f7      	b.n	fae4 <z_vprintk+0x278>
		if (remaining-- <= min_width) {
    faf4:	1e51      	subs	r1, r2, #1
    faf6:	4592      	cmp	sl, r2
    faf8:	9108      	str	r1, [sp, #32]
    fafa:	db07      	blt.n	fb0c <z_vprintk+0x2a0>
			if (padding == PAD_ZERO_BEFORE) {
    fafc:	f1b9 0f01 	cmp.w	r9, #1
    fb00:	d106      	bne.n	fb10 <z_vprintk+0x2a4>
				out('0', ctx);
    fb02:	4639      	mov	r1, r7
    fb04:	2030      	movs	r0, #48	; 0x30
    fb06:	9309      	str	r3, [sp, #36]	; 0x24
				out(' ', ctx);
    fb08:	47b0      	blx	r6
    fb0a:	9b09      	ldr	r3, [sp, #36]	; 0x24
			nibble += nibble > 9 ? 87 : 48;
    fb0c:	9a08      	ldr	r2, [sp, #32]
    fb0e:	e7b6      	b.n	fa7e <z_vprintk+0x212>
			} else if (padding == PAD_SPACE_BEFORE) {
    fb10:	f1b9 0f02 	cmp.w	r9, #2
    fb14:	d1fa      	bne.n	fb0c <z_vprintk+0x2a0>
    fb16:	9309      	str	r3, [sp, #36]	; 0x24
				out(' ', ctx);
    fb18:	4639      	mov	r1, r7
    fb1a:	2020      	movs	r0, #32
    fb1c:	e7f4      	b.n	fb08 <z_vprintk+0x29c>
			found_largest_digit = 1;
    fb1e:	9505      	str	r5, [sp, #20]
    fb20:	e7ad      	b.n	fa7e <z_vprintk+0x212>
					out((int)(*s++), ctx);
    fb22:	4639      	mov	r1, r7
    fb24:	47b0      	blx	r6
    fb26:	e6fb      	b.n	f920 <z_vprintk+0xb4>
				out(c, ctx);
    fb28:	4639      	mov	r1, r7
    fb2a:	f854 0b04 	ldr.w	r0, [r4], #4
    fb2e:	e6d7      	b.n	f8e0 <z_vprintk+0x74>
				length_mod = 0;
    fb30:	46a8      	mov	r8, r5
				padding = PAD_NONE;
    fb32:	46a9      	mov	r9, r5
				min_width = -1;
    fb34:	f04f 3aff 	mov.w	sl, #4294967295	; 0xffffffff
				might_format = 1;
    fb38:	2501      	movs	r5, #1
    fb3a:	e6ac      	b.n	f896 <z_vprintk+0x2a>
				padding = PAD_SPACE_AFTER;
    fb3c:	f04f 0903 	mov.w	r9, #3
    fb40:	e6a9      	b.n	f896 <z_vprintk+0x2a>
					padding = PAD_ZERO_BEFORE;
    fb42:	f04f 0901 	mov.w	r9, #1
    fb46:	e6a6      	b.n	f896 <z_vprintk+0x2a>
			might_format = 0;
    fb48:	4605      	mov	r5, r0
		++fmt;
    fb4a:	e6a4      	b.n	f896 <z_vprintk+0x2a>

0000fb4c <printk>:
{
    fb4c:	b40f      	push	{r0, r1, r2, r3}
    fb4e:	b507      	push	{r0, r1, r2, lr}
    fb50:	a904      	add	r1, sp, #16
    fb52:	f851 0b04 	ldr.w	r0, [r1], #4
	va_start(ap, fmt);
    fb56:	9101      	str	r1, [sp, #4]
		vprintk(fmt, ap);
    fb58:	f7fc ff16 	bl	c988 <vprintk>
}
    fb5c:	b003      	add	sp, #12
    fb5e:	f85d eb04 	ldr.w	lr, [sp], #4
    fb62:	b004      	add	sp, #16
    fb64:	4770      	bx	lr

0000fb66 <_ConfigAbsSyms>:
GEN_ABSOLUTE_SYM(CONFIG_OUTPUT_DISASSEMBLY, 1);
GEN_ABSOLUTE_SYM(CONFIG_OUTPUT_PRINT_MEMORY_USAGE, 1);
GEN_ABSOLUTE_SYM(CONFIG_BUILD_OUTPUT_BIN, 1);
GEN_ABSOLUTE_SYM(CONFIG_COMPAT_INCLUDES, 1);

GEN_ABS_SYM_END
    fb66:	4770      	bx	lr

0000fb68 <z_platform_init>:
	nrfx_coredep_delay_us(time_us);
}

void z_platform_init(void)
{
	SystemInit();
    fb68:	f7fe b88e 	b.w	dc88 <SystemInit>

0000fb6c <get_status>:
	struct nrf_clock_control *data = dev->driver_data;
    fb6c:	6883      	ldr	r3, [r0, #8]
	if (data->started) {
    fb6e:	7a5a      	ldrb	r2, [r3, #9]
    fb70:	b932      	cbnz	r2, fb80 <get_status+0x14>
	if (data->ref > 0) {
    fb72:	f993 0008 	ldrsb.w	r0, [r3, #8]
		return CLOCK_CONTROL_STATUS_ON;
    fb76:	2800      	cmp	r0, #0
    fb78:	bfcc      	ite	gt
    fb7a:	2000      	movgt	r0, #0
    fb7c:	2001      	movle	r0, #1
    fb7e:	4770      	bx	lr
    fb80:	2002      	movs	r0, #2
}
    fb82:	4770      	bx	lr

0000fb84 <clock_stop>:
	const struct nrf_clock_control_config *config =
    fb84:	6802      	ldr	r2, [r0, #0]
{
    fb86:	b570      	push	{r4, r5, r6, lr}
	const struct nrf_clock_control_config *config =
    fb88:	6895      	ldr	r5, [r2, #8]
	struct nrf_clock_control *data = dev->driver_data;
    fb8a:	6884      	ldr	r4, [r0, #8]
    fb8c:	f04f 0320 	mov.w	r3, #32
    fb90:	f3ef 8611 	mrs	r6, BASEPRI
    fb94:	f383 8811 	msr	BASEPRI, r3
    fb98:	f3bf 8f6f 	isb	sy
	data->ref--;
    fb9c:	7a23      	ldrb	r3, [r4, #8]
    fb9e:	3b01      	subs	r3, #1
    fba0:	b25b      	sxtb	r3, r3
	if (data->ref == 0) {
    fba2:	2b00      	cmp	r3, #0
	data->ref--;
    fba4:	7223      	strb	r3, [r4, #8]
	if (data->ref == 0) {
    fba6:	d118      	bne.n	fbda <clock_stop+0x56>
 * @param list A pointer on the list to initialize
 */
static inline void sys_slist_init(sys_slist_t *list)
{
	list->head = NULL;
	list->tail = NULL;
    fba8:	e9c4 3300 	strd	r3, r3, [r4]
		do_stop =  (config->stop_handler) ?
    fbac:	686b      	ldr	r3, [r5, #4]
				config->stop_handler(dev) : true;
    fbae:	b983      	cbnz	r3, fbd2 <clock_stop+0x4e>
    *((volatile uint32_t *)((uint8_t *)NRF_CLOCK + task)) = 0x1UL;
    fbb0:	2201      	movs	r2, #1
    fbb2:	7aeb      	ldrb	r3, [r5, #11]
    fbb4:	f103 2350 	add.w	r3, r3, #1342197760	; 0x50005000
    fbb8:	601a      	str	r2, [r3, #0]
    *((volatile uint32_t *)((uint8_t *)NRF_CLOCK + event)) = 0x0UL;
    fbba:	2200      	movs	r2, #0
    fbbc:	892b      	ldrh	r3, [r5, #8]
    fbbe:	f103 2350 	add.w	r3, r3, #1342197760	; 0x50005000
    fbc2:	601a      	str	r2, [r3, #0]
		data->started = false;
    fbc4:	2000      	movs	r0, #0
    fbc6:	7260      	strb	r0, [r4, #9]
	__asm__ volatile(
    fbc8:	f386 8811 	msr	BASEPRI, r6
    fbcc:	f3bf 8f6f 	isb	sy
}
    fbd0:	bd70      	pop	{r4, r5, r6, pc}
				config->stop_handler(dev) : true;
    fbd2:	4798      	blx	r3
    fbd4:	2800      	cmp	r0, #0
    fbd6:	d1eb      	bne.n	fbb0 <clock_stop+0x2c>
    fbd8:	e7f4      	b.n	fbc4 <clock_stop+0x40>
	} else if (data->ref < 0) {
    fbda:	f04f 0000 	mov.w	r0, #0
		data->ref = 0;
    fbde:	bfbc      	itt	lt
    fbe0:	7220      	strblt	r0, [r4, #8]
		err = -EALREADY;
    fbe2:	f06f 0044 	mvnlt.w	r0, #68	; 0x44
    fbe6:	e7ef      	b.n	fbc8 <clock_stop+0x44>

0000fbe8 <clock_async_start>:
{
    fbe8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	const struct nrf_clock_control_config *config =
    fbea:	6803      	ldr	r3, [r0, #0]
{
    fbec:	4606      	mov	r6, r0
    fbee:	4614      	mov	r4, r2
	const struct nrf_clock_control_config *config =
    fbf0:	689f      	ldr	r7, [r3, #8]
	struct nrf_clock_control *clk_data = dev->driver_data;
    fbf2:	6885      	ldr	r5, [r0, #8]
	__asm__ volatile(
    fbf4:	f04f 0320 	mov.w	r3, #32
    fbf8:	f3ef 8211 	mrs	r2, BASEPRI
    fbfc:	f383 8811 	msr	BASEPRI, r3
    fc00:	f3bf 8f6f 	isb	sy
	ref = ++clk_data->ref;
    fc04:	7a2b      	ldrb	r3, [r5, #8]
    fc06:	3301      	adds	r3, #1
    fc08:	b25b      	sxtb	r3, r3
    fc0a:	722b      	strb	r3, [r5, #8]
	__asm__ volatile(
    fc0c:	f382 8811 	msr	BASEPRI, r2
    fc10:	f3bf 8f6f 	isb	sy
	if (clk_data->started) {
    fc14:	7a6a      	ldrb	r2, [r5, #9]
    fc16:	b132      	cbz	r2, fc26 <clock_async_start+0x3e>
		if (data) {
    fc18:	b90c      	cbnz	r4, fc1e <clock_async_start+0x36>
	return 0;
    fc1a:	2000      	movs	r0, #0
}
    fc1c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			data->cb(dev, data->user_data);
    fc1e:	e9d4 3101 	ldrd	r3, r1, [r4, #4]
    fc22:	4798      	blx	r3
    fc24:	e7f9      	b.n	fc1a <clock_async_start+0x32>
		if (ref == 1) {
    fc26:	2b01      	cmp	r3, #1
    fc28:	d106      	bne.n	fc38 <clock_async_start+0x50>
			do_start =  (config->start_handler) ?
    fc2a:	683b      	ldr	r3, [r7, #0]
					config->start_handler(dev) : true;
    fc2c:	b933      	cbnz	r3, fc3c <clock_async_start+0x54>
    *((volatile uint32_t *)((uint8_t *)NRF_CLOCK + task)) = 0x1UL;
    fc2e:	2201      	movs	r2, #1
    fc30:	7abb      	ldrb	r3, [r7, #10]
    fc32:	f103 2350 	add.w	r3, r3, #1342197760	; 0x50005000
    fc36:	601a      	str	r2, [r3, #0]
		if (data) {
    fc38:	b94c      	cbnz	r4, fc4e <clock_async_start+0x66>
    fc3a:	e7ee      	b.n	fc1a <clock_async_start+0x32>
					config->start_handler(dev) : true;
    fc3c:	4798      	blx	r3
    fc3e:	2800      	cmp	r0, #0
    fc40:	d1f5      	bne.n	fc2e <clock_async_start+0x46>
			} else if (data) {
    fc42:	2c00      	cmp	r4, #0
    fc44:	d0e9      	beq.n	fc1a <clock_async_start+0x32>
				data->cb(dev, data->user_data);
    fc46:	e9d4 3101 	ldrd	r3, r1, [r4, #4]
    fc4a:	4630      	mov	r0, r6
    fc4c:	4798      	blx	r3
	sys_snode_t *item = sys_slist_peek_head(list);
    fc4e:	682b      	ldr	r3, [r5, #0]
		if (item == node) {
    fc50:	429c      	cmp	r4, r3
    fc52:	d00d      	beq.n	fc70 <clock_async_start+0x88>
 *
 * @return a pointer on the next node (or NULL if none)
 */
static inline sys_snode_t *sys_slist_peek_next(sys_snode_t *node);

Z_GENLIST_PEEK_NEXT(slist, snode)
    fc54:	b113      	cbz	r3, fc5c <clock_async_start+0x74>
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
    fc56:	681b      	ldr	r3, [r3, #0]
	} while (item);
    fc58:	2b00      	cmp	r3, #0
    fc5a:	d1f9      	bne.n	fc50 <clock_async_start+0x68>
	parent->next = child;
    fc5c:	2000      	movs	r0, #0
    fc5e:	6020      	str	r0, [r4, #0]
 * @param node A pointer on the node to append
 */
static inline void sys_slist_append(sys_slist_t *list,
				    sys_snode_t *node);

Z_GENLIST_APPEND(slist, snode)
    fc60:	686b      	ldr	r3, [r5, #4]
    fc62:	b913      	cbnz	r3, fc6a <clock_async_start+0x82>
	list->head = node;
    fc64:	e9c5 4400 	strd	r4, r4, [r5]
    fc68:	e7d7      	b.n	fc1a <clock_async_start+0x32>
	parent->next = child;
    fc6a:	601c      	str	r4, [r3, #0]
	list->tail = node;
    fc6c:	606c      	str	r4, [r5, #4]
    fc6e:	e7d5      	b.n	fc1c <clock_async_start+0x34>
				return -EALREADY;
    fc70:	f06f 0044 	mvn.w	r0, #68	; 0x44
    fc74:	e7d2      	b.n	fc1c <clock_async_start+0x34>

0000fc76 <clock_start>:
	return clock_async_start(dev, sub_system, NULL);
    fc76:	2200      	movs	r2, #0
    fc78:	f7ff bfb6 	b.w	fbe8 <clock_async_start>

0000fc7c <lfclk_init>:
	sys_slist_init(&((struct nrf_clock_control *)dev->driver_data)->list);
    fc7c:	6883      	ldr	r3, [r0, #8]
	list->head = NULL;
    fc7e:	2000      	movs	r0, #0
	list->tail = NULL;
    fc80:	e9c3 0000 	strd	r0, r0, [r3]
}
    fc84:	4770      	bx	lr

0000fc86 <hfclk_init>:
{
    fc86:	b510      	push	{r4, lr}
	IRQ_CONNECT(DT_INST_0_NORDIC_NRF_CLOCK_IRQ_0,
    fc88:	2200      	movs	r2, #0
{
    fc8a:	4604      	mov	r4, r0
	IRQ_CONNECT(DT_INST_0_NORDIC_NRF_CLOCK_IRQ_0,
    fc8c:	2101      	movs	r1, #1
    fc8e:	2005      	movs	r0, #5
    fc90:	f7fd fb4e 	bl	d330 <z_arm_irq_priority_set>
	irq_enable(DT_INST_0_NORDIC_NRF_CLOCK_IRQ_0);
    fc94:	2005      	movs	r0, #5
    fc96:	f7fd fb3b 	bl	d310 <z_arch_irq_enable>
}

__STATIC_INLINE void nrf_clock_lf_src_set(nrf_clock_lfclk_t source)
{
    NRF_CLOCK->LFCLKSRC = (uint32_t)(source);
    fc9a:	f04f 2350 	mov.w	r3, #1342197760	; 0x50005000
    fc9e:	2202      	movs	r2, #2
    fca0:	f8c3 2518 	str.w	r2, [r3, #1304]	; 0x518
    NRF_CLOCK->INTENSET = int_mask;
    fca4:	2203      	movs	r2, #3
	list->head = NULL;
    fca6:	2000      	movs	r0, #0
    fca8:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
	sys_slist_init(&((struct nrf_clock_control *)dev->driver_data)->list);
    fcac:	68a3      	ldr	r3, [r4, #8]
	list->tail = NULL;
    fcae:	e9c3 0000 	strd	r0, r0, [r3]
}
    fcb2:	bd10      	pop	{r4, pc}

0000fcb4 <clkstarted_handle>:
{
    fcb4:	b538      	push	{r3, r4, r5, lr}
	struct nrf_clock_control *data = dev->driver_data;
    fcb6:	6884      	ldr	r4, [r0, #8]
{
    fcb8:	4605      	mov	r5, r0
Z_GENLIST_IS_EMPTY(slist)
    fcba:	6823      	ldr	r3, [r4, #0]
 *
 * @return A pointer to the first node of the list (or NULL if empty)
 */
static inline sys_snode_t *sys_slist_get(sys_slist_t *list);

Z_GENLIST_GET(slist, snode)
    fcbc:	b12b      	cbz	r3, fcca <clkstarted_handle+0x16>
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
    fcbe:	6861      	ldr	r1, [r4, #4]
    fcc0:	681a      	ldr	r2, [r3, #0]
    fcc2:	428b      	cmp	r3, r1
	list->head = node;
    fcc4:	6022      	str	r2, [r4, #0]
	list->tail = node;
    fcc6:	bf08      	it	eq
    fcc8:	6062      	streq	r2, [r4, #4]
	data->started = true;
    fcca:	2201      	movs	r2, #1
    fccc:	7262      	strb	r2, [r4, #9]
	while (node != NULL) {
    fcce:	b903      	cbnz	r3, fcd2 <clkstarted_handle+0x1e>
}
    fcd0:	bd38      	pop	{r3, r4, r5, pc}
		async_data->cb(dev, async_data->user_data);
    fcd2:	e9d3 2101 	ldrd	r2, r1, [r3, #4]
    fcd6:	4628      	mov	r0, r5
    fcd8:	4790      	blx	r2
Z_GENLIST_IS_EMPTY(slist)
    fcda:	6823      	ldr	r3, [r4, #0]
Z_GENLIST_GET(slist, snode)
    fcdc:	2b00      	cmp	r3, #0
    fcde:	d0f7      	beq.n	fcd0 <clkstarted_handle+0x1c>
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
    fce0:	6861      	ldr	r1, [r4, #4]
    fce2:	681a      	ldr	r2, [r3, #0]
    fce4:	428b      	cmp	r3, r1
	list->head = node;
    fce6:	6022      	str	r2, [r4, #0]
	list->tail = node;
    fce8:	bf08      	it	eq
    fcea:	6062      	streq	r2, [r4, #4]
    fcec:	e7ef      	b.n	fcce <clkstarted_handle+0x1a>

0000fcee <z_clock_isr>:
/* Weak-linked noop defaults for optional driver interfaces: */

void __weak z_clock_isr(void *arg)
{
	__ASSERT_NO_MSG(false);
}
    fcee:	4770      	bx	lr

0000fcf0 <z_clock_idle_exit>:
{
}

void __weak z_clock_idle_exit(void)
{
}
    fcf0:	4770      	bx	lr

0000fcf2 <spm_secure_services_init>:
	mbedtls_platform_context platform_ctx = {0};
    fcf2:	2300      	movs	r3, #0
{
    fcf4:	b507      	push	{r0, r1, r2, lr}
	err = mbedtls_platform_setup(&platform_ctx);
    fcf6:	a801      	add	r0, sp, #4
	mbedtls_platform_context platform_ctx = {0};
    fcf8:	f88d 3004 	strb.w	r3, [sp, #4]
	err = mbedtls_platform_setup(&platform_ctx);
    fcfc:	f7fe ff6e 	bl	ebdc <mbedtls_platform_setup>
}
    fd00:	b003      	add	sp, #12
    fd02:	f85d fb04 	ldr.w	pc, [sp], #4

0000fd06 <__acle_se_spm_request_random_number>:
	if (len != MBEDTLS_ENTROPY_MAX_GATHER) {
    fd06:	2990      	cmp	r1, #144	; 0x90
{
    fd08:	b508      	push	{r3, lr}
    fd0a:	4613      	mov	r3, r2
	if (len != MBEDTLS_ENTROPY_MAX_GATHER) {
    fd0c:	d139      	bne.n	fd82 <__acle_se_spm_request_random_number+0x7c>
	err = mbedtls_hardware_poll(NULL, output, len, olen);
    fd0e:	460a      	mov	r2, r1
    fd10:	4601      	mov	r1, r0
    fd12:	2000      	movs	r0, #0
    fd14:	f7fe ff6e 	bl	ebf4 <mbedtls_hardware_poll>
}
    fd18:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    fd1c:	4671      	mov	r1, lr
    fd1e:	4672      	mov	r2, lr
    fd20:	4673      	mov	r3, lr
    fd22:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
    fd26:	eef7 0a00 	vmov.f32	s1, #112	; 0x3f800000  1.0
    fd2a:	eeb7 1a00 	vmov.f32	s2, #112	; 0x3f800000  1.0
    fd2e:	eef7 1a00 	vmov.f32	s3, #112	; 0x3f800000  1.0
    fd32:	eeb7 2a00 	vmov.f32	s4, #112	; 0x3f800000  1.0
    fd36:	eef7 2a00 	vmov.f32	s5, #112	; 0x3f800000  1.0
    fd3a:	eeb7 3a00 	vmov.f32	s6, #112	; 0x3f800000  1.0
    fd3e:	eef7 3a00 	vmov.f32	s7, #112	; 0x3f800000  1.0
    fd42:	eeb7 4a00 	vmov.f32	s8, #112	; 0x3f800000  1.0
    fd46:	eef7 4a00 	vmov.f32	s9, #112	; 0x3f800000  1.0
    fd4a:	eeb7 5a00 	vmov.f32	s10, #112	; 0x3f800000  1.0
    fd4e:	eef7 5a00 	vmov.f32	s11, #112	; 0x3f800000  1.0
    fd52:	eeb7 6a00 	vmov.f32	s12, #112	; 0x3f800000  1.0
    fd56:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
    fd5a:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
    fd5e:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
    fd62:	f38e 8c00 	msr	CPSR_fs, lr
    fd66:	b410      	push	{r4}
    fd68:	eef1 ca10 	vmrs	ip, fpscr
    fd6c:	f64f 7460 	movw	r4, #65376	; 0xff60
    fd70:	f6c0 74ff 	movt	r4, #4095	; 0xfff
    fd74:	ea0c 0c04 	and.w	ip, ip, r4
    fd78:	eee1 ca10 	vmsr	fpscr, ip
    fd7c:	bc10      	pop	{r4}
    fd7e:	46f4      	mov	ip, lr
    fd80:	4774      	bxns	lr
		return -EINVAL;
    fd82:	f06f 0015 	mvn.w	r0, #21
    fd86:	e7c7      	b.n	fd18 <__acle_se_spm_request_random_number+0x12>

0000fd88 <abort_function>:
	while(1);
    fd88:	e7fe      	b.n	fd88 <abort_function>

0000fd8a <z_irq_spurious>:
 * @return N/A
 */
void z_irq_spurious(void *unused)
{
	ARG_UNUSED(unused);
	z_arm_reserved();
    fd8a:	f7fd bb43 	b.w	d414 <z_arm_bus_fault>

0000fd8e <irq_target_state_set>:
 *
 * @return N/A
 */
void irq_target_state_set(unsigned int irq, int secure_state)
{
	if (secure_state) {
    fd8e:	b243      	sxtb	r3, r0
    fd90:	b1a9      	cbz	r1, fdbe <irq_target_state_set+0x30>
  if ((int32_t)(IRQn) >= 0)
    fd92:	2b00      	cmp	r3, #0
    fd94:	db12      	blt.n	fdbc <irq_target_state_set+0x2e>
    NVIC->ITNS[(((uint32_t)IRQn) >> 5UL)] &= ~((uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL)));
    fd96:	2101      	movs	r1, #1
    fd98:	095b      	lsrs	r3, r3, #5
    fd9a:	009b      	lsls	r3, r3, #2
    fd9c:	f103 4360 	add.w	r3, r3, #3758096384	; 0xe0000000
    fda0:	f503 4361 	add.w	r3, r3, #57600	; 0xe100
    fda4:	f8d3 2280 	ldr.w	r2, [r3, #640]	; 0x280
    fda8:	f000 001f 	and.w	r0, r0, #31
    fdac:	fa01 f000 	lsl.w	r0, r1, r0
    fdb0:	ea22 0200 	bic.w	r2, r2, r0
    fdb4:	f8c3 2280 	str.w	r2, [r3, #640]	; 0x280
    return((uint32_t)(((NVIC->ITNS[(((uint32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
    fdb8:	f8d3 3280 	ldr.w	r3, [r3, #640]	; 0x280
		/* Set target state to Non-Secure */
		if (NVIC_SetTargetState(irq) != 1) {
			__ASSERT(0, "NVIC SetTargetState error");
		}
	}
}
    fdbc:	4770      	bx	lr
  if ((int32_t)(IRQn) >= 0)
    fdbe:	2b00      	cmp	r3, #0
    fdc0:	dbfc      	blt.n	fdbc <irq_target_state_set+0x2e>
    NVIC->ITNS[(((uint32_t)IRQn) >> 5UL)] |=  ((uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL)));
    fdc2:	2201      	movs	r2, #1
    fdc4:	095b      	lsrs	r3, r3, #5
    fdc6:	009b      	lsls	r3, r3, #2
    fdc8:	f103 4360 	add.w	r3, r3, #3758096384	; 0xe0000000
    fdcc:	f503 4361 	add.w	r3, r3, #57600	; 0xe100
    fdd0:	f8d3 1280 	ldr.w	r1, [r3, #640]	; 0x280
    fdd4:	f000 001f 	and.w	r0, r0, #31
    fdd8:	fa02 f000 	lsl.w	r0, r2, r0
    fddc:	4308      	orrs	r0, r1
    fdde:	f8c3 0280 	str.w	r0, [r3, #640]	; 0x280
    fde2:	e7e9      	b.n	fdb8 <irq_target_state_set+0x2a>

0000fde4 <z_arm_fatal_error>:
{

	if (esf != NULL) {
		esf_dump(esf);
	}
	z_fatal_error(reason, esf);
    fde4:	f000 b8fb 	b.w	ffde <z_fatal_error>

0000fde8 <z_do_kernel_oops>:
}

void z_do_kernel_oops(const z_arch_esf_t *esf)
{
    fde8:	4601      	mov	r1, r0
	z_fatal_error(reason, esf);
    fdea:	6800      	ldr	r0, [r0, #0]
    fdec:	f000 b8f7 	b.w	ffde <z_fatal_error>

0000fdf0 <z_arm_nmi>:
 *
 * @return N/A
 */

void z_arm_nmi(void)
{
    fdf0:	b508      	push	{r3, lr}
	handler();
    fdf2:	f7fd fb21 	bl	d438 <z_SysNmiOnReset>
	z_arm_exc_exit();
}
    fdf6:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	z_arm_exc_exit();
    fdfa:	f7fd ba27 	b.w	d24c <z_arm_exc_exit>

0000fdfe <z_arm_configure_dynamic_mpu_regions>:
 *
 * For some MPU architectures, such as the unmodified ARMv8-M MPU,
 * the function must execute with MPU enabled.
 */
void z_arm_configure_dynamic_mpu_regions(struct k_thread *thread)
{
    fdfe:	b507      	push	{r0, r1, r2, lr}

	region_num++;
#endif /* CONFIG_MPU_STACK_GUARD */

	/* Configure the dynamic MPU regions */
	arm_core_mpu_configure_dynamic_mpu_regions(
    fe00:	2100      	movs	r1, #0
    fe02:	a801      	add	r0, sp, #4
    fe04:	f7fd fe02 	bl	da0c <arm_core_mpu_configure_dynamic_mpu_regions>
		(const struct k_mem_partition **)dynamic_regions,
		region_num);
}
    fe08:	b003      	add	sp, #12
    fe0a:	f85d fb04 	ldr.w	pc, [sp], #4

0000fe0e <mpu_configure_region>:
{
    fe0e:	b530      	push	{r4, r5, lr}
	region_conf.base = new_region->start;
    fe10:	680b      	ldr	r3, [r1, #0]
{
    fe12:	b085      	sub	sp, #20
	get_region_attr_from_k_mem_partition_info(&region_conf.attr,
    fe14:	684c      	ldr	r4, [r1, #4]
	p_attr->rbar = attr->rbar &
    fe16:	f89d 2008 	ldrb.w	r2, [sp, #8]
    fe1a:	890d      	ldrh	r5, [r1, #8]
	p_attr->r_limit = REGION_LIMIT_ADDR(base, size);
    fe1c:	3c01      	subs	r4, #1
	region_conf.base = new_region->start;
    fe1e:	9300      	str	r3, [sp, #0]
	p_attr->mair_idx = attr->mair_idx;
    fe20:	8949      	ldrh	r1, [r1, #10]
	p_attr->r_limit = REGION_LIMIT_ADDR(base, size);
    fe22:	f023 031f 	bic.w	r3, r3, #31
    fe26:	4423      	add	r3, r4
	p_attr->rbar = attr->rbar &
    fe28:	f365 0204 	bfi	r2, r5, #0, #5
	p_attr->mair_idx = attr->mair_idx;
    fe2c:	f361 1247 	bfi	r2, r1, #5, #3
	p_attr->r_limit = REGION_LIMIT_ADDR(base, size);
    fe30:	f023 031f 	bic.w	r3, r3, #31
	if (index > (get_num_regions() - 1)) {
    fe34:	280f      	cmp	r0, #15
	p_attr->mair_idx = attr->mair_idx;
    fe36:	f88d 2008 	strb.w	r2, [sp, #8]
	p_attr->r_limit = REGION_LIMIT_ADDR(base, size);
    fe3a:	9303      	str	r3, [sp, #12]
    fe3c:	4604      	mov	r4, r0
    fe3e:	d805      	bhi.n	fe4c <mpu_configure_region+0x3e>
	region_init(index, region_conf);
    fe40:	4669      	mov	r1, sp
    fe42:	f7fd fc9b 	bl	d77c <region_init>
}
    fe46:	4620      	mov	r0, r4
    fe48:	b005      	add	sp, #20
    fe4a:	bd30      	pop	{r4, r5, pc}
		return -EINVAL;
    fe4c:	f06f 0415 	mvn.w	r4, #21
	return region_allocate_and_init(index,
    fe50:	e7f9      	b.n	fe46 <mpu_configure_region+0x38>

0000fe52 <strcmp>:
 * @return negative # if <s1> < <s2>, 0 if <s1> == <s2>, else positive #
 */

int strcmp(const char *s1, const char *s2)
{
	while ((*s1 == *s2) && (*s1 != '\0')) {
    fe52:	3801      	subs	r0, #1
    fe54:	3901      	subs	r1, #1
    fe56:	f810 3f01 	ldrb.w	r3, [r0, #1]!
    fe5a:	f811 2f01 	ldrb.w	r2, [r1, #1]!
    fe5e:	4293      	cmp	r3, r2
    fe60:	d101      	bne.n	fe66 <strcmp+0x14>
    fe62:	2b00      	cmp	r3, #0
    fe64:	d1f7      	bne.n	fe56 <strcmp+0x4>
		s1++;
		s2++;
	}

	return *s1 - *s2;
}
    fe66:	1a98      	subs	r0, r3, r2
    fe68:	4770      	bx	lr

0000fe6a <memmove>:
void *memmove(void *d, const void *s, size_t n)
{
	char *dest = d;
	const char *src  = s;

	if ((size_t) (dest - src) < n) {
    fe6a:	1a43      	subs	r3, r0, r1
    fe6c:	4293      	cmp	r3, r2
{
    fe6e:	b510      	push	{r4, lr}
    fe70:	eb00 0302 	add.w	r3, r0, r2
	if ((size_t) (dest - src) < n) {
    fe74:	d308      	bcc.n	fe88 <memmove+0x1e>
	char *dest = d;
    fe76:	4602      	mov	r2, r0
    fe78:	3901      	subs	r1, #1
			n--;
			dest[n] = src[n];
		}
	} else {
		/* It is safe to perform a forward-copy */
		while (n > 0) {
    fe7a:	429a      	cmp	r2, r3
    fe7c:	d00b      	beq.n	fe96 <memmove+0x2c>
			*dest = *src;
    fe7e:	f811 4f01 	ldrb.w	r4, [r1, #1]!
    fe82:	f802 4b01 	strb.w	r4, [r2], #1
			dest++;
			src++;
			n--;
    fe86:	e7f8      	b.n	fe7a <memmove+0x10>
    fe88:	440a      	add	r2, r1
			dest[n] = src[n];
    fe8a:	f812 4d01 	ldrb.w	r4, [r2, #-1]!
		while (n > 0) {
    fe8e:	428a      	cmp	r2, r1
			dest[n] = src[n];
    fe90:	f803 4d01 	strb.w	r4, [r3, #-1]!
		while (n > 0) {
    fe94:	d1f9      	bne.n	fe8a <memmove+0x20>
		}
	}

	return d;
}
    fe96:	bd10      	pop	{r4, pc}

0000fe98 <memcpy>:
 *
 * @return pointer to start of destination buffer
 */

void *memcpy(void *_MLIBC_RESTRICT d, const void *_MLIBC_RESTRICT s, size_t n)
{
    fe98:	b5f0      	push	{r4, r5, r6, r7, lr}

	unsigned char *d_byte = (unsigned char *)d;
	const unsigned char *s_byte = (const unsigned char *)s;
	const uintptr_t mask = sizeof(mem_word_t) - 1;

	if ((((uintptr_t)d ^ (uintptr_t)s_byte) & mask) == 0) {
    fe9a:	ea81 0400 	eor.w	r4, r1, r0
    fe9e:	07a5      	lsls	r5, r4, #30
    fea0:	4603      	mov	r3, r0
    fea2:	d00b      	beq.n	febc <memcpy+0x24>
    fea4:	3b01      	subs	r3, #1
    fea6:	440a      	add	r2, r1
		s_byte = (unsigned char *)s_word;
	}

	/* do byte-sized copying until finished */

	while (n > 0) {
    fea8:	4291      	cmp	r1, r2
    feaa:	d11a      	bne.n	fee2 <memcpy+0x4a>
		*(d_byte++) = *(s_byte++);
		n--;
	}

	return d;
}
    feac:	bdf0      	pop	{r4, r5, r6, r7, pc}
			if (n == 0) {
    feae:	2a00      	cmp	r2, #0
    feb0:	d0fc      	beq.n	feac <memcpy+0x14>
			*(d_byte++) = *(s_byte++);
    feb2:	f811 4b01 	ldrb.w	r4, [r1], #1
			n--;
    feb6:	3a01      	subs	r2, #1
			*(d_byte++) = *(s_byte++);
    feb8:	f803 4b01 	strb.w	r4, [r3], #1
		while (((uintptr_t)d_byte) & mask) {
    febc:	079c      	lsls	r4, r3, #30
    febe:	d1f6      	bne.n	feae <memcpy+0x16>
    fec0:	0895      	lsrs	r5, r2, #2
    fec2:	00ac      	lsls	r4, r5, #2
    fec4:	1f1e      	subs	r6, r3, #4
    fec6:	190f      	adds	r7, r1, r4
		while (n >= sizeof(mem_word_t)) {
    fec8:	42b9      	cmp	r1, r7
    feca:	d105      	bne.n	fed8 <memcpy+0x40>
    fecc:	f06f 0603 	mvn.w	r6, #3
    fed0:	4423      	add	r3, r4
    fed2:	fb06 2205 	mla	r2, r6, r5, r2
    fed6:	e7e5      	b.n	fea4 <memcpy+0xc>
			*(d_word++) = *(s_word++);
    fed8:	f851 cb04 	ldr.w	ip, [r1], #4
    fedc:	f846 cf04 	str.w	ip, [r6, #4]!
			n -= sizeof(mem_word_t);
    fee0:	e7f2      	b.n	fec8 <memcpy+0x30>
		*(d_byte++) = *(s_byte++);
    fee2:	f811 4b01 	ldrb.w	r4, [r1], #1
    fee6:	f803 4f01 	strb.w	r4, [r3, #1]!
		n--;
    feea:	e7dd      	b.n	fea8 <memcpy+0x10>

0000feec <memset>:

void *memset(void *buf, int c, size_t n)
{
	/* do byte-sized initialization until word-aligned or finished */

	unsigned char *d_byte = (unsigned char *)buf;
    feec:	4603      	mov	r3, r0
{
    feee:	b570      	push	{r4, r5, r6, lr}
	unsigned char c_byte = (unsigned char)c;
    fef0:	b2c9      	uxtb	r1, r1

	while (((uintptr_t)d_byte) & (sizeof(mem_word_t) - 1)) {
    fef2:	079c      	lsls	r4, r3, #30
    fef4:	d110      	bne.n	ff18 <memset+0x2c>
	/* do word-sized initialization as long as possible */

	mem_word_t *d_word = (mem_word_t *)d_byte;
	mem_word_t c_word = (mem_word_t)c_byte;

	c_word |= c_word << 8;
    fef6:	ea41 2401 	orr.w	r4, r1, r1, lsl #8
	c_word |= c_word << 16;
    fefa:	ea44 4504 	orr.w	r5, r4, r4, lsl #16
#if Z_MEM_WORD_T_WIDTH > 32
	c_word |= c_word << 32;
#endif

	while (n >= sizeof(mem_word_t)) {
    fefe:	0894      	lsrs	r4, r2, #2
    ff00:	eb03 0684 	add.w	r6, r3, r4, lsl #2
    ff04:	42b3      	cmp	r3, r6
    ff06:	d10d      	bne.n	ff24 <memset+0x38>
    ff08:	f06f 0503 	mvn.w	r5, #3
    ff0c:	fb05 2404 	mla	r4, r5, r4, r2
    ff10:	441c      	add	r4, r3

	/* do byte-sized initialization until finished */

	d_byte = (unsigned char *)d_word;

	while (n > 0) {
    ff12:	42a3      	cmp	r3, r4
    ff14:	d109      	bne.n	ff2a <memset+0x3e>
		*(d_byte++) = c_byte;
		n--;
	}

	return buf;
}
    ff16:	bd70      	pop	{r4, r5, r6, pc}
		if (n == 0) {
    ff18:	2a00      	cmp	r2, #0
    ff1a:	d0fc      	beq.n	ff16 <memset+0x2a>
		*(d_byte++) = c_byte;
    ff1c:	f803 1b01 	strb.w	r1, [r3], #1
		n--;
    ff20:	3a01      	subs	r2, #1
    ff22:	e7e6      	b.n	fef2 <memset+0x6>
		*(d_word++) = c_word;
    ff24:	f843 5b04 	str.w	r5, [r3], #4
		n -= sizeof(mem_word_t);
    ff28:	e7ec      	b.n	ff04 <memset+0x18>
		*(d_byte++) = c_byte;
    ff2a:	f803 1b01 	strb.w	r1, [r3], #1
		n--;
    ff2e:	e7f0      	b.n	ff12 <memset+0x26>

0000ff30 <_stdout_hook_default>:
}
    ff30:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    ff34:	4770      	bx	lr

0000ff36 <uarte_nrfx_config_get>:
{
    ff36:	460b      	mov	r3, r1
	*cfg = get_dev_data(dev)->uart_config;
    ff38:	6882      	ldr	r2, [r0, #8]
    ff3a:	e892 0003 	ldmia.w	r2, {r0, r1}
    ff3e:	e883 0003 	stmia.w	r3, {r0, r1}
}
    ff42:	2000      	movs	r0, #0
    ff44:	4770      	bx	lr

0000ff46 <uarte_nrfx_err_check>:
	return dev->config->config_info;
    ff46:	6803      	ldr	r3, [r0, #0]
	return config->uarte_regs;
    ff48:	689b      	ldr	r3, [r3, #8]
    ff4a:	681b      	ldr	r3, [r3, #0]
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
    ff4c:	f8d3 0124 	ldr.w	r0, [r3, #292]	; 0x124
	if (nrf_uarte_event_check(uarte, NRF_UARTE_EVENT_ERROR)) {
    ff50:	b118      	cbz	r0, ff5a <uarte_nrfx_err_check+0x14>
    uint32_t errsrc_mask = p_reg->ERRORSRC;
    ff52:	f8d3 0480 	ldr.w	r0, [r3, #1152]	; 0x480
    p_reg->ERRORSRC = errsrc_mask;
    ff56:	f8c3 0480 	str.w	r0, [r3, #1152]	; 0x480
}
    ff5a:	4770      	bx	lr

0000ff5c <uarte_nrfx_poll_in>:
	return dev->config->config_info;
    ff5c:	6803      	ldr	r3, [r0, #0]
	const struct uarte_nrfx_data *data = get_dev_data(dev);
    ff5e:	6882      	ldr	r2, [r0, #8]
	return config->uarte_regs;
    ff60:	689b      	ldr	r3, [r3, #8]
    ff62:	681b      	ldr	r3, [r3, #0]
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
    ff64:	f8d3 0110 	ldr.w	r0, [r3, #272]	; 0x110
	if (!nrf_uarte_event_check(uarte, NRF_UARTE_EVENT_ENDRX)) {
    ff68:	b138      	cbz	r0, ff7a <uarte_nrfx_poll_in+0x1e>
	*c = data->rx_data;
    ff6a:	7a12      	ldrb	r2, [r2, #8]
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    ff6c:	2000      	movs	r0, #0
    ff6e:	700a      	strb	r2, [r1, #0]
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    ff70:	2201      	movs	r2, #1
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    ff72:	f8c3 0110 	str.w	r0, [r3, #272]	; 0x110
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    ff76:	601a      	str	r2, [r3, #0]
	return 0;
    ff78:	4770      	bx	lr
		return -1;
    ff7a:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
    ff7e:	4770      	bx	lr

0000ff80 <uarte_nrfx_poll_out>:
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    ff80:	2200      	movs	r2, #0
	return dev->config->config_info;
    ff82:	6803      	ldr	r3, [r0, #0]
{
    ff84:	b082      	sub	sp, #8
	return config->uarte_regs;
    ff86:	689b      	ldr	r3, [r3, #8]
{
    ff88:	f88d 1007 	strb.w	r1, [sp, #7]
	return config->uarte_regs;
    ff8c:	681b      	ldr	r3, [r3, #0]
    ff8e:	f8c3 2120 	str.w	r2, [r3, #288]	; 0x120
    p_reg->TXD.PTR    = (uint32_t)p_buffer;
    ff92:	f10d 0207 	add.w	r2, sp, #7
    ff96:	f8c3 2544 	str.w	r2, [r3, #1348]	; 0x544
    p_reg->TXD.MAXCNT = length;
    ff9a:	2201      	movs	r2, #1
    ff9c:	f8c3 2548 	str.w	r2, [r3, #1352]	; 0x548
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    ffa0:	609a      	str	r2, [r3, #8]
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
    ffa2:	f8d3 1120 	ldr.w	r1, [r3, #288]	; 0x120
	while (!nrf_uarte_event_check(uarte, NRF_UARTE_EVENT_ENDTX)) {
    ffa6:	2900      	cmp	r1, #0
    ffa8:	d0fb      	beq.n	ffa2 <uarte_nrfx_poll_out+0x22>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    ffaa:	60da      	str	r2, [r3, #12]
}
    ffac:	b002      	add	sp, #8
    ffae:	4770      	bx	lr

0000ffb0 <hw_cc310_init>:
#if CONFIG_HW_CC310

#include "nrf_cc310_platform.h"

static int hw_cc310_init(struct device *dev)
{
    ffb0:	b508      	push	{r3, lr}
	int res;

	__ASSERT_NO_MSG(dev != NULL);

	/* Set the RTOS abort APIs */
	nrf_cc310_platform_abort_init();
    ffb2:	f7fd f8b5 	bl	d120 <nrf_cc310_platform_abort_init>

	/* Set the RTOS mutex APIs */
	nrf_cc310_platform_mutex_init();
    ffb6:	f7fd f933 	bl	d220 <nrf_cc310_platform_mutex_init>
	res = nrf_cc310_platform_init();
#else
	res = nrf_cc310_platform_init_no_rng();
#endif
	return res;
}
    ffba:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	res = nrf_cc310_platform_init_no_rng();
    ffbe:	f7fe bed1 	b.w	ed64 <nrf_cc310_platform_init_no_rng>

0000ffc2 <_mbedtls_init>:
	ARG_UNUSED(device);

	init_heap();

	return 0;
}
    ffc2:	2000      	movs	r0, #0
    ffc4:	4770      	bx	lr

0000ffc6 <z_arch_system_halt>:
	__asm__ volatile(
    ffc6:	f04f 0220 	mov.w	r2, #32
    ffca:	f3ef 8311 	mrs	r3, BASEPRI
    ffce:	f382 8811 	msr	BASEPRI, r2
    ffd2:	f3bf 8f6f 	isb	sy
	 */

	(void)z_arch_irq_lock();
	for (;;) {
		/* Spin endlessly */
	}
    ffd6:	e7fe      	b.n	ffd6 <z_arch_system_halt+0x10>

0000ffd8 <k_sys_fatal_error_handler>:
/* LCOV_EXCL_STOP */

/* LCOV_EXCL_START */
__weak void k_sys_fatal_error_handler(unsigned int reason,
				      const z_arch_esf_t *esf)
{
    ffd8:	b508      	push	{r3, lr}
	ARG_UNUSED(esf);

	LOG_PANIC();
	LOG_ERR("Halting system");
	z_arch_system_halt(reason);
    ffda:	f7ff fff4 	bl	ffc6 <z_arch_system_halt>

0000ffde <z_fatal_error>:
	z_arch_system_halt(reason);
}
/* LCOV_EXCL_STOP */

void z_fatal_error(unsigned int reason, const z_arch_esf_t *esf)
{
    ffde:	b570      	push	{r4, r5, r6, lr}
    ffe0:	4605      	mov	r5, r0
    ffe2:	460e      	mov	r6, r1
	return z_impl_k_current_get();
    ffe4:	f7fe fb78 	bl	e6d8 <z_impl_k_current_get>
	 */

	LOG_ERR("Current thread: %p (%s)", thread,
		log_strdup(thread_name_get(thread)));

	k_sys_fatal_error_handler(reason, esf);
    ffe8:	4631      	mov	r1, r6
    ffea:	4604      	mov	r4, r0
    ffec:	4628      	mov	r0, r5
    ffee:	f7ff fff3 	bl	ffd8 <k_sys_fatal_error_handler>
	z_impl_k_thread_abort(thread);
    fff2:	4620      	mov	r0, r4
		/* FIXME: #17656 */
		__ASSERT(!k_is_in_isr(),
			 "Attempted to recover from a fatal error in ISR");
	}
	k_thread_abort(thread);
}
    fff4:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    fff8:	f7fd bb70 	b.w	d6dc <z_impl_k_thread_abort>

0000fffc <z_sys_power_save_idle_exit>:
	z_clock_idle_exit();
    fffc:	f7ff be78 	b.w	fcf0 <z_clock_idle_exit>

00010000 <k_mem_slab_init>:
{
   10000:	b530      	push	{r4, r5, lr}
	slab->num_used = 0U;
   10002:	2400      	movs	r4, #0
	slab->block_size = block_size;
   10004:	e9c0 3202 	strd	r3, r2, [r0, #8]
	slab->free_list = NULL;
   10008:	e9c0 4405 	strd	r4, r4, [r0, #20]
	slab->buffer = buffer;
   1000c:	6101      	str	r1, [r0, #16]
	for (j = 0U; j < slab->num_blocks; j++) {
   1000e:	42a3      	cmp	r3, r4
   10010:	d102      	bne.n	10018 <k_mem_slab_init+0x18>
	list->tail = (sys_dnode_t *)list;
   10012:	e9c0 0000 	strd	r0, r0, [r0]
}
   10016:	bd30      	pop	{r4, r5, pc}
		*(char **)p = slab->free_list;
   10018:	6945      	ldr	r5, [r0, #20]
	for (j = 0U; j < slab->num_blocks; j++) {
   1001a:	3401      	adds	r4, #1
		*(char **)p = slab->free_list;
   1001c:	600d      	str	r5, [r1, #0]
		slab->free_list = p;
   1001e:	6141      	str	r1, [r0, #20]
		p += slab->block_size;
   10020:	4411      	add	r1, r2
   10022:	e7f4      	b.n	1000e <k_mem_slab_init+0xe>

00010024 <z_impl_k_mutex_init>:
	mutex->owner = NULL;
   10024:	2300      	movs	r3, #0
   10026:	e9c0 0000 	strd	r0, r0, [r0]
	mutex->lock_count = 0U;
   1002a:	e9c0 3302 	strd	r3, r3, [r0, #8]
}
   1002e:	4770      	bx	lr

00010030 <z_is_thread_ready>:
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
   10030:	7b43      	ldrb	r3, [r0, #13]
   10032:	06db      	lsls	r3, r3, #27
   10034:	bf03      	ittte	eq
   10036:	6980      	ldreq	r0, [r0, #24]
   10038:	fab0 f080 	clzeq	r0, r0
   1003c:	0940      	lsreq	r0, r0, #5
   1003e:	2000      	movne	r0, #0
}
   10040:	4770      	bx	lr

00010042 <z_unpend_thread_no_timeout>:
{
   10042:	b538      	push	{r3, r4, r5, lr}
   10044:	4604      	mov	r4, r0
   10046:	f04f 0320 	mov.w	r3, #32
   1004a:	f3ef 8511 	mrs	r5, BASEPRI
   1004e:	f383 8811 	msr	BASEPRI, r3
   10052:	f3bf 8f6f 	isb	sy
		_priq_wait_remove(&pended_on(thread)->waitq, thread);
   10056:	4601      	mov	r1, r0
   10058:	6880      	ldr	r0, [r0, #8]
   1005a:	f7fe f975 	bl	e348 <z_priq_dumb_remove>
	thread->base.thread_state &= ~_THREAD_PENDING;
   1005e:	7b63      	ldrb	r3, [r4, #13]
   10060:	f023 0302 	bic.w	r3, r3, #2
   10064:	7363      	strb	r3, [r4, #13]
	__asm__ volatile(
   10066:	f385 8811 	msr	BASEPRI, r5
   1006a:	f3bf 8f6f 	isb	sy
	thread->base.pended_on = NULL;
   1006e:	2300      	movs	r3, #0
   10070:	60a3      	str	r3, [r4, #8]
}
   10072:	bd38      	pop	{r3, r4, r5, pc}

00010074 <z_reschedule>:
{
   10074:	b508      	push	{r3, lr}
	return z_arch_irq_unlocked(key) && !z_arch_is_in_isr();
   10076:	b939      	cbnz	r1, 10088 <z_reschedule+0x14>
   10078:	f7fe f8fe 	bl	e278 <resched.part.15>
	if (resched(key.key)) {
   1007c:	b120      	cbz	r0, 10088 <z_reschedule+0x14>
}
   1007e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
   10082:	4608      	mov	r0, r1
   10084:	f7fd b8f0 	b.w	d268 <z_arch_swap>
   10088:	f381 8811 	msr	BASEPRI, r1
   1008c:	f3bf 8f6f 	isb	sy
   10090:	bd08      	pop	{r3, pc}

00010092 <z_reschedule_irqlock>:
{
   10092:	b508      	push	{r3, lr}
	return z_arch_irq_unlocked(key) && !z_arch_is_in_isr();
   10094:	4602      	mov	r2, r0
   10096:	b938      	cbnz	r0, 100a8 <z_reschedule_irqlock+0x16>
   10098:	f7fe f8ee 	bl	e278 <resched.part.15>
	if (resched(key)) {
   1009c:	b120      	cbz	r0, 100a8 <z_reschedule_irqlock+0x16>
}
   1009e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
   100a2:	4610      	mov	r0, r2
   100a4:	f7fd b8e0 	b.w	d268 <z_arch_swap>
   100a8:	f382 8811 	msr	BASEPRI, r2
   100ac:	f3bf 8f6f 	isb	sy
   100b0:	bd08      	pop	{r3, pc}

000100b2 <z_reschedule_unlocked>:
	__asm__ volatile(
   100b2:	f04f 0320 	mov.w	r3, #32
   100b6:	f3ef 8011 	mrs	r0, BASEPRI
   100ba:	f383 8811 	msr	BASEPRI, r3
   100be:	f3bf 8f6f 	isb	sy
	(void) z_reschedule_irqlock(z_arch_irq_lock());
   100c2:	f7ff bfe6 	b.w	10092 <z_reschedule_irqlock>

000100c6 <z_priq_dumb_best>:
	return list->head == list;
   100c6:	6803      	ldr	r3, [r0, #0]
}
   100c8:	4298      	cmp	r0, r3
   100ca:	bf14      	ite	ne
   100cc:	4618      	movne	r0, r3
   100ce:	2000      	moveq	r0, #0
   100d0:	4770      	bx	lr

000100d2 <z_thread_timeout>:
	if (th->base.pended_on != NULL) {
   100d2:	f850 3c10 	ldr.w	r3, [r0, #-16]
{
   100d6:	b570      	push	{r4, r5, r6, lr}
   100d8:	4604      	mov	r4, r0
	struct k_thread *th = CONTAINER_OF(to, struct k_thread, base.timeout);
   100da:	f1a0 0518 	sub.w	r5, r0, #24
	if (th->base.pended_on != NULL) {
   100de:	b1cb      	cbz	r3, 10114 <z_thread_timeout+0x42>
   100e0:	f04f 0320 	mov.w	r3, #32
   100e4:	f3ef 8611 	mrs	r6, BASEPRI
   100e8:	f383 8811 	msr	BASEPRI, r3
   100ec:	f3bf 8f6f 	isb	sy
		_priq_wait_remove(&pended_on(thread)->waitq, thread);
   100f0:	4629      	mov	r1, r5
   100f2:	f850 0c10 	ldr.w	r0, [r0, #-16]
   100f6:	f7fe f927 	bl	e348 <z_priq_dumb_remove>
	thread->base.thread_state &= ~_THREAD_PENDING;
   100fa:	f814 3c0b 	ldrb.w	r3, [r4, #-11]
   100fe:	f023 0302 	bic.w	r3, r3, #2
   10102:	f804 3c0b 	strb.w	r3, [r4, #-11]
	__asm__ volatile(
   10106:	f386 8811 	msr	BASEPRI, r6
   1010a:	f3bf 8f6f 	isb	sy
	thread->base.pended_on = NULL;
   1010e:	2300      	movs	r3, #0
   10110:	f844 3c10 	str.w	r3, [r4, #-16]
	thread->base.thread_state &= ~_THREAD_SUSPENDED;
   10114:	f814 3c0b 	ldrb.w	r3, [r4, #-11]
	if (z_is_thread_ready(thread)) {
   10118:	4628      	mov	r0, r5
	thread->base.thread_state &= ~_THREAD_SUSPENDED;
   1011a:	f023 0314 	bic.w	r3, r3, #20
   1011e:	f804 3c0b 	strb.w	r3, [r4, #-11]
	if (z_is_thread_ready(thread)) {
   10122:	f7ff ff85 	bl	10030 <z_is_thread_ready>
   10126:	b120      	cbz	r0, 10132 <z_thread_timeout+0x60>
		z_add_thread_to_ready_q(thread);
   10128:	4628      	mov	r0, r5
}
   1012a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
   1012e:	f7fe b95b 	b.w	e3e8 <z_add_thread_to_ready_q>
   10132:	bd70      	pop	{r4, r5, r6, pc}

00010134 <z_unpend_first_thread>:
{
   10134:	b538      	push	{r3, r4, r5, lr}
	__asm__ volatile(
   10136:	f04f 0320 	mov.w	r3, #32
   1013a:	f3ef 8211 	mrs	r2, BASEPRI
   1013e:	f383 8811 	msr	BASEPRI, r3
   10142:	f3bf 8f6f 	isb	sy
		ret = _priq_wait_best(&wait_q->waitq);
   10146:	f7ff ffbe 	bl	100c6 <z_priq_dumb_best>
   1014a:	4604      	mov	r4, r0
	__asm__ volatile(
   1014c:	f382 8811 	msr	BASEPRI, r2
   10150:	f3bf 8f6f 	isb	sy

static inline struct k_thread *z_unpend1_no_timeout(_wait_q_t *wait_q)
{
	struct k_thread *thread = z_find_first_thread_to_unpend(wait_q, NULL);

	if (thread != NULL) {
   10154:	b1c8      	cbz	r0, 1018a <z_unpend_first_thread+0x56>
	__asm__ volatile(
   10156:	f04f 0320 	mov.w	r3, #32
   1015a:	f3ef 8511 	mrs	r5, BASEPRI
   1015e:	f383 8811 	msr	BASEPRI, r3
   10162:	f3bf 8f6f 	isb	sy
		_priq_wait_remove(&pended_on(thread)->waitq, thread);
   10166:	4601      	mov	r1, r0
   10168:	6880      	ldr	r0, [r0, #8]
   1016a:	f7fe f8ed 	bl	e348 <z_priq_dumb_remove>
	thread->base.thread_state &= ~_THREAD_PENDING;
   1016e:	7b63      	ldrb	r3, [r4, #13]
   10170:	f023 0302 	bic.w	r3, r3, #2
   10174:	7363      	strb	r3, [r4, #13]
	__asm__ volatile(
   10176:	f385 8811 	msr	BASEPRI, r5
   1017a:	f3bf 8f6f 	isb	sy
	thread->base.pended_on = NULL;
   1017e:	2300      	movs	r3, #0
}

static inline int z_abort_thread_timeout(struct k_thread *thread)
{
	return z_abort_timeout(&thread->base.timeout);
   10180:	f104 0018 	add.w	r0, r4, #24
   10184:	60a3      	str	r3, [r4, #8]
   10186:	f000 f832 	bl	101ee <z_abort_timeout>
}
   1018a:	4620      	mov	r0, r4
   1018c:	bd38      	pop	{r3, r4, r5, pc}

0001018e <z_is_thread_ready>:
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
   1018e:	7b43      	ldrb	r3, [r0, #13]
   10190:	06db      	lsls	r3, r3, #27
   10192:	bf03      	ittte	eq
   10194:	6980      	ldreq	r0, [r0, #24]
   10196:	fab0 f080 	clzeq	r0, r0
   1019a:	0940      	lsreq	r0, r0, #5
   1019c:	2000      	movne	r0, #0
}
   1019e:	4770      	bx	lr

000101a0 <z_thread_single_abort>:
	if (thread->fn_abort != NULL) {
   101a0:	6d03      	ldr	r3, [r0, #80]	; 0x50
{
   101a2:	b510      	push	{r4, lr}
   101a4:	4604      	mov	r4, r0
	if (thread->fn_abort != NULL) {
   101a6:	b103      	cbz	r3, 101aa <z_thread_single_abort+0xa>
		thread->fn_abort();
   101a8:	4798      	blx	r3
	if (z_is_thread_ready(thread)) {
   101aa:	4620      	mov	r0, r4
   101ac:	f7ff ffef 	bl	1018e <z_is_thread_ready>
   101b0:	b138      	cbz	r0, 101c2 <z_thread_single_abort+0x22>
		z_remove_thread_from_ready_q(thread);
   101b2:	4620      	mov	r0, r4
   101b4:	f7fe f9c6 	bl	e544 <z_remove_thread_from_ready_q>
	thread->base.thread_state |= _THREAD_DEAD;
   101b8:	7b63      	ldrb	r3, [r4, #13]
   101ba:	f043 0308 	orr.w	r3, r3, #8
   101be:	7363      	strb	r3, [r4, #13]
}
   101c0:	bd10      	pop	{r4, pc}
		if (z_is_thread_pending(thread)) {
   101c2:	7b63      	ldrb	r3, [r4, #13]
   101c4:	079b      	lsls	r3, r3, #30
   101c6:	d502      	bpl.n	101ce <z_thread_single_abort+0x2e>
			z_unpend_thread_no_timeout(thread);
   101c8:	4620      	mov	r0, r4
   101ca:	f7ff ff3a 	bl	10042 <z_unpend_thread_no_timeout>
		if (z_is_thread_timeout_active(thread)) {
   101ce:	69a3      	ldr	r3, [r4, #24]
   101d0:	2b00      	cmp	r3, #0
   101d2:	d0f1      	beq.n	101b8 <z_thread_single_abort+0x18>
   101d4:	f104 0018 	add.w	r0, r4, #24
   101d8:	f000 f809 	bl	101ee <z_abort_timeout>
   101dc:	e7ec      	b.n	101b8 <z_thread_single_abort+0x18>

000101de <z_init_thread_base>:
void z_init_thread_base(struct _thread_base *thread_base, int priority,
		       u32_t initial_state, unsigned int options)
{
	/* k_q_node is initialized upon first insertion in a list */

	thread_base->user_options = (u8_t)options;
   101de:	7303      	strb	r3, [r0, #12]
	thread_base->thread_state = (u8_t)initial_state;

	thread_base->prio = priority;

	thread_base->sched_locked = 0U;
   101e0:	2300      	movs	r3, #0
	thread_base->thread_state = (u8_t)initial_state;
   101e2:	7342      	strb	r2, [r0, #13]
	thread_base->prio = priority;
   101e4:	7381      	strb	r1, [r0, #14]
	thread_base->sched_locked = 0U;
   101e6:	73c3      	strb	r3, [r0, #15]
	node->prev = NULL;
   101e8:	e9c0 3306 	strd	r3, r3, [r0, #24]
#endif

	/* swap_data does not need to be initialized */

	z_init_thread_timeout(thread_base);
}
   101ec:	4770      	bx	lr

000101ee <z_abort_timeout>:
{
   101ee:	b510      	push	{r4, lr}
	__asm__ volatile(
   101f0:	f04f 0220 	mov.w	r2, #32
   101f4:	f3ef 8411 	mrs	r4, BASEPRI
   101f8:	f382 8811 	msr	BASEPRI, r2
   101fc:	f3bf 8f6f 	isb	sy
		if (sys_dnode_is_linked(&to->node)) {
   10200:	6803      	ldr	r3, [r0, #0]
   10202:	b13b      	cbz	r3, 10214 <z_abort_timeout+0x26>
			remove_timeout(to);
   10204:	f7fe fb0e 	bl	e824 <remove_timeout>
			ret = 0;
   10208:	2000      	movs	r0, #0
	__asm__ volatile(
   1020a:	f384 8811 	msr	BASEPRI, r4
   1020e:	f3bf 8f6f 	isb	sy
}
   10212:	bd10      	pop	{r4, pc}
	int ret = -EINVAL;
   10214:	f06f 0015 	mvn.w	r0, #21
   10218:	e7f7      	b.n	1020a <z_abort_timeout+0x1c>

0001021a <z_get_next_timeout_expiry>:
{
   1021a:	b510      	push	{r4, lr}
	__asm__ volatile(
   1021c:	f04f 0320 	mov.w	r3, #32
   10220:	f3ef 8411 	mrs	r4, BASEPRI
   10224:	f383 8811 	msr	BASEPRI, r3
   10228:	f3bf 8f6f 	isb	sy
		ret = next_timeout();
   1022c:	f7fe fb0e 	bl	e84c <next_timeout>
	__asm__ volatile(
   10230:	f384 8811 	msr	BASEPRI, r4
   10234:	f3bf 8f6f 	isb	sy
}
   10238:	bd10      	pop	{r4, pc}

0001023a <z_set_timeout_expiry>:
{
   1023a:	b570      	push	{r4, r5, r6, lr}
   1023c:	4604      	mov	r4, r0
   1023e:	460e      	mov	r6, r1
	__asm__ volatile(
   10240:	f04f 0320 	mov.w	r3, #32
   10244:	f3ef 8511 	mrs	r5, BASEPRI
   10248:	f383 8811 	msr	BASEPRI, r3
   1024c:	f3bf 8f6f 	isb	sy
		int next = next_timeout();
   10250:	f7fe fafc 	bl	e84c <next_timeout>
		if (!imminent && (sooner || IS_ENABLED(CONFIG_SMP))) {
   10254:	2801      	cmp	r0, #1
   10256:	dd05      	ble.n	10264 <z_set_timeout_expiry+0x2a>
   10258:	42a0      	cmp	r0, r4
   1025a:	dd03      	ble.n	10264 <z_set_timeout_expiry+0x2a>
			z_clock_set_timeout(ticks, idle);
   1025c:	4631      	mov	r1, r6
   1025e:	4620      	mov	r0, r4
   10260:	f7fc fc6a 	bl	cb38 <z_clock_set_timeout>
	__asm__ volatile(
   10264:	f385 8811 	msr	BASEPRI, r5
   10268:	f3bf 8f6f 	isb	sy
}
   1026c:	bd70      	pop	{r4, r5, r6, pc}

0001026e <_OffsetAbsSyms>:
					    sizeof(struct _preempt_float));
#else
GEN_ABSOLUTE_SYM(_K_THREAD_NO_FLOAT_SIZEOF, sizeof(struct k_thread));
#endif

GEN_ABS_SYM_END
   1026e:	4770      	bx	lr

Disassembly of section .gnu.sgstubs:

00010d80 <spm_request_read-0x7260>:
	...

00017fe0 <spm_request_read>:
   17fe0:	e97f e97f 	sg
   17fe4:	f7f4 bfbe 	b.w	cf64 <__acle_se_spm_request_read>

00017fe8 <spm_firmware_info>:
   17fe8:	e97f e97f 	sg
   17fec:	f7f5 b818 	b.w	d020 <__acle_se_spm_firmware_info>

00017ff0 <spm_request_random_number>:
   17ff0:	e97f e97f 	sg
   17ff4:	f7f7 be87 	b.w	fd06 <__acle_se_spm_request_random_number>
	...
